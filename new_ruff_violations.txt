gal_friday/__init__.py:4:1: T201 `print` found
  |
3 | # Make the directory a package
4 | print("Gal Friday Package Initialized")  # You can keep or remove this print
  | ^^^^^ T201
  |
  = help: Remove `print`

gal_friday/backtest_historical_data_provider.py:5:22: TC003 Move standard library import `datetime.datetime` into a type-checking block
  |
3 | from __future__ import annotations
4 |
5 | from datetime import datetime
  |                      ^^^^^^^^ TC003
6 | from typing import Any
  |
  = help: Move into type-checking block

gal_friday/backtest_historical_data_provider.py:8:18: TC002 Move third-party import `pandas` into a type-checking block
  |
6 | from typing import Any
7 |
8 | import pandas as pd
  |                  ^^ TC002
  |
  = help: Move into type-checking block

gal_friday/backtest_historical_data_provider.py:14:31: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
   |
12 |     """Provides historical data for backtesting."""
13 |
14 |     def __init__(self, *args: Any, **kwargs: Any) -> None:
   |                               ^^^ ANN401
15 |         """Initialize the backtest historical data provider."""
   |

gal_friday/backtest_historical_data_provider.py:14:46: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   |
12 |     """Provides historical data for backtesting."""
13 |
14 |     def __init__(self, *args: Any, **kwargs: Any) -> None:
   |                                              ^^^ ANN401
15 |         """Initialize the backtest historical data provider."""
   |

gal_friday/backtesting_engine.py:333:30: TC004 Move import `.core.events.Event` out of type-checking block. Import is used for more than type hinting.
    |
332 | if TYPE_CHECKING:
333 |     from .core.events import Event
    |                              ^^^^^ TC004
334 |
335 |     class ExchangeInfoServiceImpl:  # type: ignore
    |
    = help: Move out of type-checking block

gal_friday/backtesting_engine.py:356:9: D107 Missing docstring in `__init__`
    |
354 |     """Provides historical data access for backtesting components."""
355 |
356 |     def __init__(
    |         ^^^^^^^^ D107
357 |         self,
358 |         all_historical_data: dict[str, pd.DataFrame],
    |

gal_friday/backtesting_engine.py:608:16: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
606 |             first_date = equity_curve.index[0]
607 |             last_date = equity_curve.index[-1]
608 |             if isinstance(first_date, (pd.Timestamp, datetime)) and isinstance(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
609 |                 last_date, (pd.Timestamp, datetime),
610 |             ):
    |
    = help: Convert to `X | Y`

gal_friday/backtesting_engine.py:608:69: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
606 |               first_date = equity_curve.index[0]
607 |               last_date = equity_curve.index[-1]
608 |               if isinstance(first_date, (pd.Timestamp, datetime)) and isinstance(
    |  _____________________________________________________________________^
609 | |                 last_date, (pd.Timestamp, datetime),
610 | |             ):
    | |_____________^ UP038
611 |                   duration_days = (last_date - first_date).total_seconds() / (60 * 60 * 24)
612 |                   if duration_days > 0:
    |
    = help: Convert to `X | Y`

gal_friday/backtesting_engine.py:1137:15: C901 `_execute_simulation` is too complex (34 > 15)
     |
1135 |         return results
1136 |
1137 |     async def _execute_simulation(  # noqa: PLR0912
     |               ^^^^^^^^^^^^^^^^^^^ C901
1138 |         self,
1139 |         services: dict[str, Any],
     |

gal_friday/backtesting_engine.py:1137:15: PLR0915 Too many statements (101 > 50)
     |
1135 |         return results
1136 |
1137 |     async def _execute_simulation(  # noqa: PLR0912
     |               ^^^^^^^^^^^^^^^^^^^ PLR0915
1138 |         self,
1139 |         services: dict[str, Any],
     |

gal_friday/backtesting_engine.py:1159:9: F841 Local variable `feature_engine` is assigned to but never used
     |
1157 |         portfolio_manager = services.get("portfolio_manager")
1158 |         execution_handler = services.get("execution_handler")
1159 |         feature_engine = services.get("feature_engine")
     |         ^^^^^^^^^^^^^^ F841
1160 |         prediction_service = services.get("prediction_service")
1161 |         strategy_arbitrator = services.get("strategy_arbitrator")
     |
     = help: Remove assignment to unused variable `feature_engine`

gal_friday/backtesting_engine.py:1161:9: F841 Local variable `strategy_arbitrator` is assigned to but never used
     |
1159 |         feature_engine = services.get("feature_engine")
1160 |         prediction_service = services.get("prediction_service")
1161 |         strategy_arbitrator = services.get("strategy_arbitrator")
     |         ^^^^^^^^^^^^^^^^^^^ F841
1162 |         risk_manager = services.get("risk_manager")
     |
     = help: Remove assignment to unused variable `strategy_arbitrator`

gal_friday/backtesting_engine.py:1162:9: F841 Local variable `risk_manager` is assigned to but never used
     |
1160 |         prediction_service = services.get("prediction_service")
1161 |         strategy_arbitrator = services.get("strategy_arbitrator")
1162 |         risk_manager = services.get("risk_manager")
     |         ^^^^^^^^^^^^ F841
1163 |
1164 |         if not all([market_price_service, portfolio_manager, execution_handler]):
     |
     = help: Remove assignment to unused variable `risk_manager`

gal_friday/backtesting_engine.py:1214:100: E501 Line too long (105 > 99)
     |
1212 |                 try:
1213 |                     # 1. Update market price service with current timestamp
1214 |                     if market_price_service is not None and hasattr(market_price_service, "update_time"):
     |                                                                                                    ^^^^^^ E501
1215 |                         market_price_service.update_time(current_timestamp)
     |

gal_friday/backtesting_engine.py:1224:100: E501 Line too long (113 > 99)
     |
1223 |                     # 3. Process any pending limit orders and stop-loss/take-profit
1224 |                     if execution_handler is not None and hasattr(execution_handler, "check_active_limit_orders"):
     |                                                                                                    ^^^^^^^^^^^^^^ E501
1225 |                         # Get current bar data for limit order processing
1226 |                         for pair in trading_pairs:
     |

gal_friday/backtesting_engine.py:1238:100: E501 Line too long (105 > 99)
     |
1237 |                     # 4. Update portfolio value and record equity curve
1238 |                     if portfolio_manager is not None and hasattr(portfolio_manager, "get_current_state"):
     |                                                                                                    ^^^^^^ E501
1239 |                         portfolio_state = portfolio_manager.get_current_state()
1240 |                         if portfolio_state and "total_value" in portfolio_state:
     |

gal_friday/backtesting_engine.py:1253:24: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
     |
1251 |                     log.error(f"Error processing timestamp {current_timestamp}: {e}")
1252 |                     # Continue processing unless it's a critical error
1253 |                     if isinstance(e, (KeyboardInterrupt, SystemExit)):
     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
1254 |                         raise
1255 |                     continue
     |
     = help: Convert to `X | Y`

gal_friday/backtesting_engine.py:1310:1: W293 Blank line contains whitespace
     |
1308 |     ) -> None:
1309 |         """Process market data for a specific trading pair and timestamp.
1310 |
     | ^^^^^^^^ W293
1311 |         Args:
1312 |             trading_pair: The trading pair to process
     |
     = help: Remove whitespace from blank line

gal_friday/backtesting_engine.py:1350:1: W293 Blank line contains whitespace
     |
1348 |     def _get_bar_at_timestamp(self, trading_pair: str, timestamp: datetime) -> pd.Series | None:
1349 |         """Get OHLCV bar data for a specific trading pair and timestamp.
1350 |
     | ^^^^^^^^ W293
1351 |         Args:
1352 |             trading_pair: Trading pair to get data for
     |
     = help: Remove whitespace from blank line

gal_friday/backtesting_engine.py:1354:1: W293 Blank line contains whitespace
     |
1352 |             trading_pair: Trading pair to get data for
1353 |             timestamp: Timestamp to look up
1354 |
     | ^^^^^^^^^^^^ W293
1355 |         Returns:
1356 |             Series containing OHLCV data or None if not found
     |
     = help: Remove whitespace from blank line

gal_friday/cli_service.py:28:12: TC004 Move import `typer` out of type-checking block. Import is used for more than type hinting.
   |
26 | # Create TYPE_CHECKING specific imports
27 | if TYPE_CHECKING:
28 |     import typer
   |            ^^^^^ TC004
29 |     from rich.console import Console
30 |     from rich.table import Table
   |
   = help: Move out of type-checking block

gal_friday/cli_service.py:32:33: TC004 Move import `.config_manager.ConfigManager` out of type-checking block. Import is used for more than type hinting.
   |
30 |     from rich.table import Table
31 |
32 |     from .config_manager import ConfigManager
   |                                 ^^^^^^^^^^^^^ TC004
33 |     from .core.halt_recovery import HaltRecoveryManager
34 |     from .core.pubsub import PubSubManager
   |
   = help: Move out of type-checking block

gal_friday/cli_service.py:34:30: TC004 Move import `.core.pubsub.PubSubManager` out of type-checking block. Import is used for more than type hinting.
   |
32 |     from .config_manager import ConfigManager
33 |     from .core.halt_recovery import HaltRecoveryManager
34 |     from .core.pubsub import PubSubManager
   |                              ^^^^^^^^^^^^^ TC004
35 |     from .logger_service import ExcInfoType, LoggerService
36 |     # Define a protocol for connection pools
   |
   = help: Move out of type-checking block

gal_friday/cli_service.py:35:33: TC004 Move import `.logger_service.ExcInfoType` out of type-checking block. Import is used for more than type hinting.
   |
33 |     from .core.halt_recovery import HaltRecoveryManager
34 |     from .core.pubsub import PubSubManager
35 |     from .logger_service import ExcInfoType, LoggerService
   |                                 ^^^^^^^^^^^ TC004
36 |     # Define a protocol for connection pools
37 |     class PoolProtocol(Protocol):
   |
   = help: Move out of type-checking block

gal_friday/cli_service.py:60:29: UP007 Use `X | Y` for type annotations
   |
59 |     # Allow GalFridayApp to be used where MainAppController is expected
60 |     MainAppControllerType = Union[MainAppController, "GalFridayApp"]
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP007
61 | else:
62 |     # Non-type checking imports
   |
   = help: Convert to `X | Y`

gal_friday/cli_service.py:76:29: UP007 Use `X | Y` for type annotations
   |
74 |     # For non-type checking compatibility
75 |     GalFridayApp = MainAppController
76 |     MainAppControllerType = Union[MainAppController, GalFridayApp]
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP007
77 |     T = TypeVar("T")
   |
   = help: Convert to `X | Y`

gal_friday/cli_service.py:187:13: T201 `print` found
    |
185 |                 source_module=self.__class__.__name__,
186 |             )
187 |             print("\n--- Gal-Friday CLI Ready (Fallback Mode) ---")
    |             ^^^^^ T201
188 |             print("Type a command (e.g., 'status', 'halt', 'stop') or '--help' and press Enter.")
189 |             print("(Note: CLI runs in a separate thread)")
    |
    = help: Remove `print`

gal_friday/cli_service.py:188:13: T201 `print` found
    |
186 |             )
187 |             print("\n--- Gal-Friday CLI Ready (Fallback Mode) ---")
188 |             print("Type a command (e.g., 'status', 'halt', 'stop') or '--help' and press Enter.")
    |             ^^^^^ T201
189 |             print("(Note: CLI runs in a separate thread)")
190 |             print("---")
    |
    = help: Remove `print`

gal_friday/cli_service.py:189:13: T201 `print` found
    |
187 |             print("\n--- Gal-Friday CLI Ready (Fallback Mode) ---")
188 |             print("Type a command (e.g., 'status', 'halt', 'stop') or '--help' and press Enter.")
189 |             print("(Note: CLI runs in a separate thread)")
    |             ^^^^^ T201
190 |             print("---")
191 |             self._input_thread = threading.Thread(target=self._threaded_input_loop, daemon=True)
    |
    = help: Remove `print`

gal_friday/cli_service.py:190:13: T201 `print` found
    |
188 |             print("Type a command (e.g., 'status', 'halt', 'stop') or '--help' and press Enter.")
189 |             print("(Note: CLI runs in a separate thread)")
190 |             print("---")
    |             ^^^^^ T201
191 |             self._input_thread = threading.Thread(target=self._threaded_input_loop, daemon=True)
192 |             self._input_thread.start()
    |
    = help: Remove `print`

gal_friday/cli_service.py:381:23: T201 `print` found
    |
379 |             "CLI service not initialized",
380 |             source_module="CLI_Command",
381 |         ) if cli else print("Error: CLI service not initialized")
    |                       ^^^^^ T201
382 |         return
    |
    = help: Remove `print`

gal_friday/cli_service.py:422:23: T201 `print` found
    |
420 |             "CLI service not initialized for halt command",
421 |             source_module="CLI_Command",
422 |         ) if cli else print("Error: CLI service not initialized")
    |                       ^^^^^ T201
423 |         return
    |
    = help: Remove `print`

gal_friday/cli_service.py:456:23: T201 `print` found
    |
454 |             "CLI service not initialized for resume command",
455 |             source_module="CLI_Command",
456 |         ) if cli else print("Error: CLI service not initialized")
    |                       ^^^^^ T201
457 |         return
    |
    = help: Remove `print`

gal_friday/cli_service.py:483:23: T201 `print` found
    |
481 |             "CLI service not initialized for stop command",
482 |             source_module="CLI_Command",
483 |         ) if cli else print("Error: CLI service not initialized")
    |                       ^^^^^ T201
484 |         return
    |
    = help: Remove `print`

gal_friday/cli_service.py:505:9: T201 `print` found
    |
503 |     cli = global_cli_instance.get_instance()
504 |     if not cli:
505 |         print("Error: CLI service not initialized")
    |         ^^^^^ T201
506 |         return
    |
    = help: Remove `print`

gal_friday/cli_service.py:509:9: T201 `print` found
    |
508 |     if not cli.recovery_manager:
509 |         print("Recovery manager not initialized")
    |         ^^^^^ T201
510 |         return
    |
    = help: Remove `print`

gal_friday/cli_service.py:539:9: T201 `print` found
    |
537 |     cli = global_cli_instance.get_instance()
538 |     if not cli:
539 |         print("Error: CLI service not initialized")
    |         ^^^^^ T201
540 |         return
    |
    = help: Remove `print`

gal_friday/cli_service.py:543:9: T201 `print` found
    |
542 |     if not cli.recovery_manager:
543 |         print("Recovery manager not initialized")
    |         ^^^^^ T201
544 |         return
    |
    = help: Remove `print`

gal_friday/cli_service.py:547:9: T201 `print` found
    |
546 |     if cli.recovery_manager.complete_item(item_id, completed_by):
547 |         print(f"✓ Item '{item_id}' marked complete by {completed_by}")
    |         ^^^^^ T201
548 |     else:
549 |         print(f"✗ Item '{item_id}' not found")
    |
    = help: Remove `print`

gal_friday/cli_service.py:549:9: T201 `print` found
    |
547 |         print(f"✓ Item '{item_id}' marked complete by {completed_by}")
548 |     else:
549 |         print(f"✗ Item '{item_id}' not found")
    |         ^^^^^ T201
    |
    = help: Remove `print`

gal_friday/cli_service.py:570:16: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
    |
568 |         self,
569 |         message: str,
570 |         *args: Any,
    |                ^^^ ANN401
571 |         source_module: str | None = None,
572 |         context: Mapping[str, object] | None = None,
    |

gal_friday/cli_service.py:575:9: T201 `print` found
    |
573 |     ) -> None:
574 |         """Log info message."""
575 |         print(f"INFO [{source_module}]: {message}")
    |         ^^^^^ T201
576 |
577 |     def debug(
    |
    = help: Remove `print`

gal_friday/cli_service.py:580:16: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
    |
578 |         self,
579 |         message: str,
580 |         *args: Any,
    |                ^^^ ANN401
581 |         source_module: str | None = None,
582 |         context: Mapping[str, object] | None = None,
    |

gal_friday/cli_service.py:585:9: T201 `print` found
    |
583 |     ) -> None:
584 |         """Log debug message."""
585 |         print(f"DEBUG [{source_module}]: {message}")
    |         ^^^^^ T201
586 |
587 |     def warning(
    |
    = help: Remove `print`

gal_friday/cli_service.py:590:16: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
    |
588 |         self,
589 |         message: str,
590 |         *args: Any,
    |                ^^^ ANN401
591 |         source_module: str | None = None,
592 |         context: Mapping[str, object] | None = None,
    |

gal_friday/cli_service.py:595:9: T201 `print` found
    |
593 |     ) -> None:
594 |         """Log warning message."""
595 |         print(f"WARN [{source_module}]: {message}")
    |         ^^^^^ T201
596 |
597 |     def error(
    |
    = help: Remove `print`

gal_friday/cli_service.py:600:16: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
    |
598 |         self,
599 |         message: str,
600 |         *args: Any,
    |                ^^^ ANN401
601 |         source_module: str | None = None,
602 |         context: Mapping[str, object] | None = None,
    |

gal_friday/cli_service.py:606:9: T201 `print` found
    |
604 |     ) -> None:
605 |         """Log error message."""
606 |         print(f"ERROR [{source_module}]: {message}")
    |         ^^^^^ T201
607 |         if exc_info and not isinstance(exc_info, bool):
608 |             print(f"Exception: {exc_info}")
    |
    = help: Remove `print`

gal_friday/cli_service.py:608:13: T201 `print` found
    |
606 |         print(f"ERROR [{source_module}]: {message}")
607 |         if exc_info and not isinstance(exc_info, bool):
608 |             print(f"Exception: {exc_info}")
    |             ^^^^^ T201
609 |
610 |     def exception(
    |
    = help: Remove `print`

gal_friday/cli_service.py:613:16: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
    |
611 |         self,
612 |         message: str,
613 |         *args: Any,
    |                ^^^ ANN401
614 |         source_module: str | None = None,
615 |         context: Mapping[str, object] | None = None,
    |

gal_friday/cli_service.py:623:16: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
    |
621 |         self,
622 |         message: str,
623 |         *args: Any,
    |                ^^^ ANN401
624 |         source_module: str | None = None,
625 |         context: Mapping[str, object] | None = None,
    |

gal_friday/cli_service.py:629:9: T201 `print` found
    |
627 |     ) -> None:
628 |         """Log critical message."""
629 |         print(f"CRITICAL [{source_module}]: {message}")
    |         ^^^^^ T201
630 |         if exc_info and not isinstance(exc_info, bool):
631 |             print(f"Exception: {exc_info}")
    |
    = help: Remove `print`

gal_friday/cli_service.py:631:13: T201 `print` found
    |
629 |         print(f"CRITICAL [{source_module}]: {message}")
630 |         if exc_info and not isinstance(exc_info, bool):
631 |             print(f"Exception: {exc_info}")
    |             ^^^^^ T201
    |
    = help: Remove `print`

gal_friday/cli_service.py:687:9: T201 `print` found
    |
685 |     async def trigger_halt(self, reason: str, source: str) -> None:
686 |         """Trigger a system halt."""
687 |         print(f"HALTING SYSTEM - Source: {source}, Reason: {reason}")
    |         ^^^^^ T201
688 |         self._halted = True
689 |         self._halt_reason = reason
    |
    = help: Remove `print`

gal_friday/cli_service.py:693:9: T201 `print` found
    |
691 |     async def trigger_resume(self, source: str) -> None:
692 |         """Resume the system from a halt."""
693 |         print(f"RESUMING SYSTEM - Source: {source}")
    |         ^^^^^ T201
694 |         self._halted = False
695 |         self._halt_reason = ""
    |
    = help: Remove `print`

gal_friday/cli_service.py:703:9: T201 `print` found
    |
701 |     async def stop(self) -> None:
702 |         """Stop the application."""
703 |         print("SHUTTING DOWN APPLICATION")
    |         ^^^^^ T201
    |
    = help: Remove `print`

gal_friday/cli_service.py:789:9: T201 `print` found
    |
787 |         # Clean up
788 |         await cli_service.stop()
789 |         print("Example CLI service stopped.")
    |         ^^^^^ T201
    |
    = help: Remove `print`

gal_friday/cli_service.py:800:5: T201 `print` found
    |
798 |         duration: How long to wait before automatic shutdown in seconds
799 |     """
800 |     print(f"\nExample will automatically shut down after {duration} seconds.")
    |     ^^^^^ T201
801 |     print("Use commands like 'status', 'halt', or 'stop' to interact with the system.")
802 |     print("Press Ctrl+C to exit early.")
    |
    = help: Remove `print`

gal_friday/cli_service.py:801:5: T201 `print` found
    |
799 |     """
800 |     print(f"\nExample will automatically shut down after {duration} seconds.")
801 |     print("Use commands like 'status', 'halt', or 'stop' to interact with the system.")
    |     ^^^^^ T201
802 |     print("Press Ctrl+C to exit early.")
    |
    = help: Remove `print`

gal_friday/cli_service.py:802:5: T201 `print` found
    |
800 |     print(f"\nExample will automatically shut down after {duration} seconds.")
801 |     print("Use commands like 'status', 'halt', or 'stop' to interact with the system.")
802 |     print("Press Ctrl+C to exit early.")
    |     ^^^^^ T201
803 |
804 |     try:
    |
    = help: Remove `print`

gal_friday/cli_service.py:806:9: T201 `print` found
    |
804 |     try:
805 |         await asyncio.sleep(duration)
806 |         print(f"\n{duration} seconds elapsed, triggering automatic shutdown...")
    |         ^^^^^ T201
807 |         await _mock_shutdown(cli_service)
808 |     except asyncio.CancelledError:
    |
    = help: Remove `print`

gal_friday/cli_service.py:809:9: T201 `print` found
    |
807 |         await _mock_shutdown(cli_service)
808 |     except asyncio.CancelledError:
809 |         print("Shutdown task cancelled.")
    |         ^^^^^ T201
    |
    = help: Remove `print`

gal_friday/cli_service.py:819:5: T201 `print` found
    |
817 |         cli_service: The CLI service being shut down
818 |     """
819 |     print("Example shutting down...")
    |     ^^^^^ T201
820 |     await cli_service.main_app_controller.stop()
821 |     await cli_service.stop()
    |
    = help: Remove `print`

gal_friday/cli_service_mocks.py:16:9: T201 `print` found
   |
14 |     def print(self, *args: str) -> None:
15 |         """Print to console, simplified version of rich.console.Console.print."""
16 |         print(*args)
   |         ^^^^^ T201
   |
   = help: Remove `print`

gal_friday/cli_service_mocks.py:28:13: T201 `print` found
   |
26 |         self.title = title
27 |         if title:
28 |             print(f"TABLE: {title}")
   |             ^^^^^ T201
29 |
30 |     def add_column(self, title: str, style: str | None = None) -> None:
   |
   = help: Remove `print`

gal_friday/cli_service_mocks.py:36:13: T201 `print` found
   |
34 |         """Add a row to the table."""
35 |         if len(args) >= self.MIN_ARGS_FOR_ROW_PRINT:
36 |             print(f"  {args[0]}: {args[1]}")
   |             ^^^^^ T201
   |
   = help: Remove `print`

gal_friday/cli_service_mocks.py:48:9: T201 `print` found
   |
46 |     async def trigger_halt(self, reason: str, source: str) -> None:
47 |         """Trigger a halt of the trading system."""
48 |         print(f"HALT triggered by {source}: {reason}")
   |         ^^^^^ T201
49 |
50 |     async def trigger_resume(self, source: str) -> None:
   |
   = help: Remove `print`

gal_friday/cli_service_mocks.py:52:9: T201 `print` found
   |
50 |     async def trigger_resume(self, source: str) -> None:
51 |         """Resume trading after a halt."""
52 |         print(f"RESUME triggered by {source}")
   |         ^^^^^ T201
   |
   = help: Remove `print`

gal_friday/cli_service_mocks.py:60:9: T201 `print` found
   |
58 |     async def stop(self) -> None:
59 |         """Stop the application."""
60 |         print("Shutdown requested by CLI.")
   |         ^^^^^ T201
   |
   = help: Remove `print`

gal_friday/cli_service_mocks.py:79:9: T201 `print` found
   |
77 |     ) -> None:
78 |         """Log info message."""
79 |         print(f"INFO: {message}")
   |         ^^^^^ T201
80 |
81 |     def warning(
   |
   = help: Remove `print`

gal_friday/cli_service_mocks.py:86:9: T201 `print` found
   |
84 |     ) -> None:
85 |         """Log warning message."""
86 |         print(f"WARNING: {message}")
   |         ^^^^^ T201
87 |
88 |     def error(
   |
   = help: Remove `print`

gal_friday/cli_service_mocks.py:94:9: T201 `print` found
   |
92 |     ) -> None:
93 |         """Log error message."""
94 |         print(f"ERROR: {message}")
   |         ^^^^^ T201
95 |         if exc_info:
96 |             print(f"Exception: {exc_info}")
   |
   = help: Remove `print`

gal_friday/cli_service_mocks.py:96:13: T201 `print` found
   |
94 |         print(f"ERROR: {message}")
95 |         if exc_info:
96 |             print(f"Exception: {exc_info}")
   |             ^^^^^ T201
97 |
98 |     def exception(
   |
   = help: Remove `print`

gal_friday/cli_service_mocks.py:105:9: T201 `print` found
    |
103 |     ) -> None:
104 |         """Log error message with exception info."""
105 |         print(f"EXCEPTION: {message}")
    |         ^^^^^ T201
106 |         if source_module:
107 |             print(f"Source: {source_module}")
    |
    = help: Remove `print`

gal_friday/cli_service_mocks.py:107:13: T201 `print` found
    |
105 |         print(f"EXCEPTION: {message}")
106 |         if source_module:
107 |             print(f"Source: {source_module}")
    |             ^^^^^ T201
108 |         if context:
109 |             print(f"Context: {context}")
    |
    = help: Remove `print`

gal_friday/cli_service_mocks.py:109:13: T201 `print` found
    |
107 |             print(f"Source: {source_module}")
108 |         if context:
109 |             print(f"Context: {context}")
    |             ^^^^^ T201
110 |         import sys
    |
    = help: Remove `print`

gal_friday/cli_service_mocks.py:112:9: T201 `print` found
    |
110 |         import sys
111 |
112 |         print(f"Exception: {sys.exc_info()[1]}")
    |         ^^^^^ T201
113 |
114 |     def debug(
    |
    = help: Remove `print`

gal_friday/cli_service_mocks.py:119:9: T201 `print` found
    |
117 |     ) -> None:
118 |         """Log debug message."""
119 |         print(f"DEBUG: {message}")
    |         ^^^^^ T201
120 |
121 |     def critical(
    |
    = help: Remove `print`

gal_friday/cli_service_mocks.py:127:9: T201 `print` found
    |
125 |     ) -> None:
126 |         """Log critical message."""
127 |         print(f"CRITICAL: {message}")
    |         ^^^^^ T201
128 |         if exc_info:
129 |             print(f"Exception: {exc_info}")
    |
    = help: Remove `print`

gal_friday/cli_service_mocks.py:129:13: T201 `print` found
    |
127 |         print(f"CRITICAL: {message}")
128 |         if exc_info:
129 |             print(f"Exception: {exc_info}")
    |             ^^^^^ T201
    |
    = help: Remove `print`

gal_friday/config_manager.py:287:100: E501 Line too long (107 > 99)
    |
285 |             for pair in pairs:
286 |                 if not self._is_valid_trading_pair(pair):
287 |                     errors.append(f"Invalid trading pair format: '{pair}' (expected format: 'BASE/QUOTE')")
    |                                                                                                    ^^^^^^^^ E501
288 |
289 |         # Validate exchange
    |

gal_friday/config_manager.py:302:100: E501 Line too long (100 > 99)
    |
301 |         # Validate key risk parameters
302 |         required_fields = ["max_total_drawdown_pct", "max_daily_drawdown_pct", "risk_per_trade_pct"]
    |                                                                                                    ^ E501
303 |         for field in required_fields:
304 |             value = risk_config.get(field)
    |

gal_friday/config_manager.py:310:55: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
308 |                 try:
309 |                     float_val = float(value)
310 |                     if float_val <= 0 or float_val >= 100:
    |                                                       ^^^ PLR2004
311 |                         errors.append(f"'risk.{field}' must be between 0 and 100 (exclusive)")
312 |                 except (ValueError, TypeError):
    |

gal_friday/config_manager.py:333:100: E501 Line too long (115 > 99)
    |
331 |                 missing_fields = []
332 |                 for field in required_api_fields:
333 |                     if not exchange_api_config.get(field) and not os.getenv(f"{exchange.upper()}_{field.upper()}"):
    |                                                                                                    ^^^^^^^^^^^^^^^^ E501
334 |                         missing_fields.append(field)
335 |                 if missing_fields:
    |

gal_friday/config_manager.py:359:100: E501 Line too long (104 > 99)
    |
357 |         # Check environment variables as fallback/override
358 |         api_key = service_config.get("api_key") or os.getenv(f"{service_name.upper()}_API_KEY")
359 |         api_secret = service_config.get("api_secret") or os.getenv(f"{service_name.upper()}_API_SECRET")
    |                                                                                                    ^^^^^ E501
360 |
361 |         return {
    |

gal_friday/config_manager.py:368:1: W293 Blank line contains whitespace
    |
366 |     def reload_config(self) -> list[str]:
367 |         """Explicitly reload configuration from file.
368 |
    | ^^^^^^^^ W293
369 |         This method provides controlled configuration reloading that requires
370 |         explicit user action (CLI command or system restart) rather than
    |
    = help: Remove whitespace from blank line

gal_friday/config_manager.py:372:1: W293 Blank line contains whitespace
    |
370 |         explicit user action (CLI command or system restart) rather than
371 |         automatic file watching.
372 |
    | ^^^^^^^^ W293
373 |         Returns:
374 |             List of validation errors (empty if successful)
    |
    = help: Remove whitespace from blank line

gal_friday/config_manager.py:411:1: W293 Blank line contains whitespace
    |
409 |     def get_secure_value(self, key: str, default: str | None = None) -> str | None:
410 |         """Get a secure value (API key, secret, etc.) from config or environment.
411 |
    | ^^^^^^^^ W293
412 |         This method checks the configuration file first, then falls back to
413 |         environment variables using a standardized naming convention.
    |
    = help: Remove whitespace from blank line

gal_friday/config_manager.py:414:1: W293 Blank line contains whitespace
    |
412 |         This method checks the configuration file first, then falls back to
413 |         environment variables using a standardized naming convention.
414 |
    | ^^^^^^^^ W293
415 |         Args:
416 |             key: Configuration key (e.g., 'kraken.api_key')
    |
    = help: Remove whitespace from blank line

gal_friday/config_manager.py:418:1: W293 Blank line contains whitespace
    |
416 |             key: Configuration key (e.g., 'kraken.api_key')
417 |             default: Default value if not found
418 |
    | ^^^^^^^^^^^^ W293
419 |         Returns:
420 |             The secure value or default
    |
    = help: Remove whitespace from blank line

gal_friday/config_manager.py:437:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
435 |         # Check alternative naming patterns
436 |         parts = key.split(".")
437 |         if len(parts) >= 2:
    |                          ^ PLR2004
438 |             alt_env_key = f"{parts[0].upper()}_{parts[-1].upper()}"
439 |             alt_env_value = os.getenv(alt_env_key)
    |

gal_friday/core/asset_registry.py:135:9: D107 Missing docstring in `__init__`
    |
133 |     """Central registry for asset and exchange specifications."""
134 |
135 |     def __init__(self) -> None:
    |         ^^^^^^^^ D107
136 |         self._assets: dict[str, dict[str, AssetSpecification]] = {}  # exchange_id -> symbol -> spec
137 |         self._exchanges: dict[str, ExchangeSpecification] = {}
    |

gal_friday/core/asset_registry.py:136:100: E501 Line too long (100 > 99)
    |
135 |     def __init__(self) -> None:
136 |         self._assets: dict[str, dict[str, AssetSpecification]] = {}  # exchange_id -> symbol -> spec
    |                                                                                                    ^ E501
137 |         self._exchanges: dict[str, ExchangeSpecification] = {}
138 |         self._symbol_mappings: dict[str, dict[str, dict[str, str]]] = {}  # from_exchange -> to_exchange -> symbol_map
    |

gal_friday/core/asset_registry.py:138:100: E501 Line too long (118 > 99)
    |
136 |         self._assets: dict[str, dict[str, AssetSpecification]] = {}  # exchange_id -> symbol -> spec
137 |         self._exchanges: dict[str, ExchangeSpecification] = {}
138 |         self._symbol_mappings: dict[str, dict[str, dict[str, str]]] = {}  # from_exchange -> to_exchange -> symbol_map
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
139 |
140 |     def register_exchange(self, exchange: ExchangeSpecification) -> None:
    |

gal_friday/core/asset_registry.py:214:9: SIM103 Return the negated condition directly
    |
213 |           # Add more sophisticated validation based on asset type and exchange capabilities
214 | /         if asset.asset_type == AssetType.OPTIONS and not exchange.provides_options_chain:
215 | |             return False
216 | |
217 | |         return True
    | |___________________^ SIM103
    |
    = help: Inline condition

gal_friday/core/asset_registry.py:293:1: W293 Blank line contains whitespace
    |
291 |         ]
292 |     )
293 |
    | ^^^^ W293
294 |     # Options exchange example
295 |     cboe_exchange = ExchangeSpecification(
    |
    = help: Remove whitespace from blank line

gal_friday/core/event_store.py:20:1: W293 Blank line contains whitespace
   |
18 | class EventStore:
19 |     """Enterprise-grade event store with persistence and caching.
20 |
   | ^^^^ W293
21 |     Features:
22 |     - Async PostgreSQL persistence
   |
   = help: Remove whitespace from blank line

gal_friday/core/event_store.py:37:1: W293 Blank line contains whitespace
   |
35 |     ) -> None:
36 |         """Initialize event store.
37 |
   | ^^^^^^^^ W293
38 |         Args:
39 |             session_maker: SQLAlchemy async session maker
   |
   = help: Remove whitespace from blank line

gal_friday/core/event_store.py:72:13: SIM105 Use `contextlib.suppress(asyncio.CancelledError)` instead of `try`-`except`-`pass`
   |
70 |           if self._cleanup_task:
71 |               self._cleanup_task.cancel()
72 | /             try:
73 | |                 await self._cleanup_task
74 | |             except asyncio.CancelledError:
75 | |                 pass
   | |____________________^ SIM105
76 |
77 |           self._cache.clear()
   |
   = help: Replace with `contextlib.suppress(asyncio.CancelledError)`

gal_friday/core/event_store.py:87:1: W293 Blank line contains whitespace
   |
85 |     async def store_event(self, event: Event) -> None:
86 |         """Store an event in both cache and database.
87 |
   | ^^^^^^^^ W293
88 |         Args:
89 |             event: Event to store
   |
   = help: Remove whitespace from blank line

gal_friday/core/event_store.py:100:100: E501 Line too long (112 > 99)
    |
 98 |                 if not isinstance(event_type_attr, EventType):
 99 |                     self.logger.error(
100 |                         f"Event {event.event_id} (source: {event.source_module}, type: {type(event).__name__}) "
    |                                                                                                    ^^^^^^^^^^^^^ E501
101 |                         f"is missing a valid 'event_type' attribute of type EventType.",
102 |                     )
    |

gal_friday/core/event_store.py:140:1: W293 Blank line contains whitespace
    |
138 |     ) -> T | None:
139 |         """Retrieve a single event by ID.
140 |
    | ^^^^^^^^ W293
141 |         Args:
142 |             event_id: Event ID to retrieve
    |
    = help: Remove whitespace from blank line

gal_friday/core/event_store.py:144:1: W293 Blank line contains whitespace
    |
142 |             event_id: Event ID to retrieve
143 |             event_type: Expected event type for type safety
144 |
    | ^^^^^^^^^^^^ W293
145 |         Returns:
146 |             Event if found, None otherwise
    |
    = help: Remove whitespace from blank line

gal_friday/core/event_store.py:204:1: W293 Blank line contains whitespace
    |
202 |     ) -> list[Event]:
203 |         """Retrieve all events with a specific correlation ID.
204 |
    | ^^^^^^^^ W293
205 |         Args:
206 |             correlation_id: Correlation ID (e.g., signal_id)
    |
    = help: Remove whitespace from blank line

gal_friday/core/event_store.py:210:1: W293 Blank line contains whitespace
    |
208 |             since: Start timestamp filter
209 |             until: End timestamp filter
210 |
    | ^^^^^^^^^^^^ W293
211 |         Returns:
212 |             List of matching events ordered by timestamp
    |
    = help: Remove whitespace from blank line

gal_friday/core/event_store.py:260:1: W293 Blank line contains whitespace
    |
258 |     ) -> list[T]:
259 |         """Retrieve events of a specific type.
260 |
    | ^^^^^^^^ W293
261 |         Args:
262 |             event_type: Event type to retrieve
    |
    = help: Remove whitespace from blank line

gal_friday/core/event_store.py:266:1: W293 Blank line contains whitespace
    |
264 |             until: End timestamp filter
265 |             limit: Maximum number of events to return
266 |
    | ^^^^^^^^^^^^ W293
267 |         Returns:
268 |             List of matching events ordered by timestamp desc
    |
    = help: Remove whitespace from blank line

gal_friday/core/event_store.py:312:9: S101 Use of `assert` detected
    |
310 |         # Remove oldest if at capacity
311 |         current_maxlen = self._cache_order.maxlen
312 |         assert current_maxlen is not None, "Deque maxlen should be set during initialization"
    |         ^^^^^^ S101
313 |         if len(self._cache) >= current_maxlen:
314 |             oldest_id = self._cache_order[0]
    |

gal_friday/core/event_store.py:396:100: E501 Line too long (104 > 99)
    |
394 |             # Ensure event_log.data is treated as dict for from_dict method
395 |             event_data_dict = cast("dict[str, Any]", event_log.data)
396 |             # The cast to Event was redundant, event_class.from_dict should return correctly typed event
    |                                                                                                    ^^^^^ E501
397 |             return event_class.from_dict(event_data_dict)
    |

gal_friday/core/events.py:45:9: D107 Missing docstring in `__init__`
   |
43 |     """Error raised when commission is specified but commission_asset is missing."""
44 |
45 |     def __init__(self) -> None:
   |         ^^^^^^^^ D107
46 |         super().__init__("Commission asset must be provided when commission is specified")
   |

gal_friday/core/events.py:52:9: D107 Missing docstring in `__init__`
   |
50 |     """Error raised when commission is negative."""
51 |
52 |     def __init__(self, commission: Decimal) -> None:
   |         ^^^^^^^^ D107
53 |         super().__init__(f"Commission cannot be negative: {commission}")
   |

gal_friday/core/events.py:59:9: D107 Missing docstring in `__init__`
   |
57 |     """Error raised when average_fill_price is missing for filled or partially filled orders."""
58 |
59 |     def __init__(self) -> None:
   |         ^^^^^^^^ D107
60 |         super().__init__(
61 |             "Average fill price must be provided for filled or partially filled orders",
   |

gal_friday/core/events.py:68:9: D107 Missing docstring in `__init__`
   |
66 |     """Error raised when limit_price is missing for LIMIT orders."""
67 |
68 |     def __init__(self) -> None:
   |         ^^^^^^^^ D107
69 |         super().__init__("Limit price must be provided for LIMIT orders")
   |

gal_friday/core/events.py:75:9: D107 Missing docstring in `__init__`
   |
73 |     """Error raised when limit_price is not positive."""
74 |
75 |     def __init__(self, limit_price: Decimal) -> None:
   |         ^^^^^^^^ D107
76 |         super().__init__(f"Limit price must be positive: {limit_price}")
   |

gal_friday/core/events.py:82:9: D107 Missing docstring in `__init__`
   |
80 |     """Error raised when average_fill_price is not positive."""
81 |
82 |     def __init__(self, average_fill_price: Decimal) -> None:
   |         ^^^^^^^^ D107
83 |         super().__init__(f"Average fill price must be positive: {average_fill_price}")
   |

gal_friday/core/events.py:89:9: D107 Missing docstring in `__init__`
   |
87 |     """Error raised when quantity_filled exceeds quantity_ordered."""
88 |
89 |     def __init__(self, quantity_filled: Decimal, quantity_ordered: Decimal) -> None:
   |         ^^^^^^^^ D107
90 |         message = (
91 |             f"Quantity filled ({quantity_filled}) cannot exceed "
   |

gal_friday/core/events.py:100:9: D107 Missing docstring in `__init__`
    |
 98 |     """Error raised when quantity_ordered is not positive."""
 99 |
100 |     def __init__(self, quantity_ordered: Decimal) -> None:
    |         ^^^^^^^^ D107
101 |         super().__init__(f"Quantity ordered must be positive: {quantity_ordered}")
    |

gal_friday/core/events.py:107:9: D107 Missing docstring in `__init__`
    |
105 |     """Error raised when quantity_filled is negative."""
106 |
107 |     def __init__(self, quantity_filled: Decimal) -> None:
    |         ^^^^^^^^ D107
108 |         super().__init__(f"Quantity filled cannot be negative: {quantity_filled}")
    |

gal_friday/core/events.py:114:9: D107 Missing docstring in `__init__`
    |
112 |     """Error raised when order_status is invalid."""
113 |
114 |     def __init__(self, order_status: str, valid_statuses: list[str]) -> None:
    |         ^^^^^^^^ D107
115 |         super().__init__(f"Invalid order_status: {order_status}. Must be one of {valid_statuses}")
    |

gal_friday/core/events.py:121:9: D107 Missing docstring in `__init__`
    |
119 |     """Error raised when order_type is invalid."""
120 |
121 |     def __init__(self, order_type: str, valid_order_types: list[str]) -> None:
    |         ^^^^^^^^ D107
122 |         super().__init__(f"Invalid order_type: {order_type}. Must be one of {valid_order_types}")
    |

gal_friday/core/events.py:128:9: D107 Missing docstring in `__init__`
    |
126 |     """Error raised when side is invalid."""
127 |
128 |     def __init__(self, side: str) -> None:
    |         ^^^^^^^^ D107
129 |         super().__init__(f"Invalid side: {side}. Must be 'BUY' or 'SELL'.")
    |

gal_friday/core/events.py:135:9: D107 Missing docstring in `__init__`
    |
133 |     """Error raised for SELL orders when take profit is not below entry price."""
134 |
135 |     def __init__(self, tp_price: Decimal, limit_price: Decimal) -> None:
    |         ^^^^^^^^ D107
136 |         message = (
137 |             f"For SELL orders, take profit price ({tp_price}) must be below "
    |

gal_friday/core/events.py:146:9: D107 Missing docstring in `__init__`
    |
144 |     """Error raised for SELL orders when stop loss is not above entry price."""
145 |
146 |     def __init__(self, sl_price: Decimal, limit_price: Decimal) -> None:
    |         ^^^^^^^^ D107
147 |         message = (
148 |             f"For SELL orders, stop loss price ({sl_price}) must be above "
    |

gal_friday/core/events.py:157:9: D107 Missing docstring in `__init__`
    |
155 |     """Error raised for invalid side in a trade signal."""
156 |
157 |     def __init__(self, side: str) -> None:
    |         ^^^^^^^^ D107
158 |         super().__init__(f"Invalid side: {side}. Must be 'BUY' or 'SELL'.")
    |

gal_friday/core/events.py:164:9: D107 Missing docstring in `__init__`
    |
162 |     """Error raised for invalid entry_type in a trade signal."""
163 |
164 |     def __init__(self, entry_type: str) -> None:
    |         ^^^^^^^^ D107
165 |         super().__init__(f"Invalid entry_type: {entry_type}. Must be 'LIMIT' or 'MARKET'.")
    |

gal_friday/core/events.py:171:9: D107 Missing docstring in `__init__`
    |
169 |     """Error raised when proposed_entry_price is missing for a LIMIT order."""
170 |
171 |     def __init__(self) -> None:
    |         ^^^^^^^^ D107
172 |         super().__init__("proposed_entry_price must be provided for LIMIT entry type.")
    |

gal_friday/core/events.py:178:9: D107 Missing docstring in `__init__`
    |
176 |     """Error raised when a stop loss price is not positive."""
177 |
178 |     def __init__(self, sl_price: Decimal) -> None:
    |         ^^^^^^^^ D107
179 |         super().__init__(f"Stop loss price must be positive: {sl_price}")
    |

gal_friday/core/events.py:185:9: D107 Missing docstring in `__init__`
    |
183 |     """Error raised when a take profit price is not positive."""
184 |
185 |     def __init__(self, tp_price: Decimal) -> None:
    |         ^^^^^^^^ D107
186 |         super().__init__(f"Take profit price must be positive: {tp_price}")
    |

gal_friday/core/events.py:192:9: D107 Missing docstring in `__init__`
    |
190 |     """Error raised when a proposed entry price is not positive."""
191 |
192 |     def __init__(self, entry_price: Decimal) -> None:
    |         ^^^^^^^^ D107
193 |         super().__init__(f"Entry price must be positive: {entry_price}")
    |

gal_friday/core/events.py:199:9: D107 Missing docstring in `__init__`
    |
197 |     """Error for BUY orders when stop loss is not below entry price."""
198 |
199 |     def __init__(self, sl_price: Decimal, entry_price: Decimal) -> None:
    |         ^^^^^^^^ D107
200 |         message = (
201 |             f"For BUY orders, stop loss price ({sl_price}) must be below "
    |

gal_friday/core/events.py:210:9: D107 Missing docstring in `__init__`
    |
208 |     """Error for BUY orders when take profit is not above entry price."""
209 |
210 |     def __init__(self, tp_price: Decimal, entry_price: Decimal) -> None:
    |         ^^^^^^^^ D107
211 |         message = (
212 |             f"For BUY orders, take profit price ({tp_price}) must be above "
    |

gal_friday/core/events.py:221:9: D107 Missing docstring in `__init__`
    |
219 |     """Error for SELL orders when stop loss is not above proposed entry price."""
220 |
221 |     def __init__(self, sl_price: Decimal, entry_price: Decimal) -> None:
    |         ^^^^^^^^ D107
222 |         message = (
223 |             f"For SELL orders, stop loss price ({sl_price}) must be above "
    |

gal_friday/core/events.py:232:9: D107 Missing docstring in `__init__`
    |
230 |     """Error for SELL orders when take profit is not below proposed entry price."""
231 |
232 |     def __init__(self, tp_price: Decimal, entry_price: Decimal) -> None:
    |         ^^^^^^^^ D107
233 |         message = (
234 |             f"For SELL orders, take profit price ({tp_price}) must be below "
    |

gal_friday/core/events.py:243:9: D107 Missing docstring in `__init__`
    |
241 |     """Error raised when quantity is not positive for an approved signal."""
242 |
243 |     def __init__(self, quantity: Decimal) -> None:
    |         ^^^^^^^^ D107
244 |         super().__init__(f"Quantity must be positive: {quantity}")
    |

gal_friday/core/events.py:250:9: D107 Missing docstring in `__init__`
    |
248 |     """Error raised when stop loss price is not positive for an approved signal."""
249 |
250 |     def __init__(self, sl_price: Decimal) -> None:
    |         ^^^^^^^^ D107
251 |         super().__init__(f"Stop loss price must be positive: {sl_price}")
    |

gal_friday/core/events.py:257:9: D107 Missing docstring in `__init__`
    |
255 |     """Error raised when take profit price is not positive for an approved signal."""
256 |
257 |     def __init__(self, tp_price: Decimal) -> None:
    |         ^^^^^^^^ D107
258 |         super().__init__(f"Take profit price must be positive: {tp_price}")
    |

gal_friday/core/events.py:264:9: D107 Missing docstring in `__init__`
    |
262 |     """Error for BUY orders when stop loss is not below the approved limit price."""
263 |
264 |     def __init__(self, sl_price: Decimal, limit_price: Decimal) -> None:
    |         ^^^^^^^^ D107
265 |         message = (
266 |             f"For BUY orders, stop loss price ({sl_price}) must be below "
    |

gal_friday/core/events.py:275:9: D107 Missing docstring in `__init__`
    |
273 |     """Error for BUY orders when take profit is not above the approved limit price."""
274 |
275 |     def __init__(self, tp_price: Decimal, limit_price: Decimal) -> None:
    |         ^^^^^^^^ D107
276 |         message = (
277 |             f"For BUY orders, take profit price ({tp_price}) must be above "
    |

gal_friday/core/events.py:313:100: E501 Line too long (104 > 99)
    |
311 |     MARKET_DATA_RAW = auto()  # Raw market data before processing
312 |     FEATURE_CALCULATED = auto()  # Alias for FEATURES_CALCULATED (for backward compatibility)
313 |     MARKET_DATA_TICKER = auto()  # Event carrying ticker/quote data with best bid/ask and 24h statistics
    |                                                                                                    ^^^^^ E501
    |

gal_friday/core/events.py:374:17: SIM105 Use `contextlib.suppress(ValueError)` instead of `try`-`except`-`pass`
    |
372 |           for key, value in data.items():
373 |               if key.endswith("_id") and isinstance(value, str) and value:
374 | /                 try:
375 | |                     data[key] = uuid.UUID(value)
376 | |                 except ValueError:
377 | |                     pass
    | |________________________^ SIM105
378 |               elif "timestamp" in key and isinstance(value, str):
379 |                   try:
    |
    = help: Replace with `contextlib.suppress(ValueError)`

gal_friday/core/events.py:379:17: SIM105 Use `contextlib.suppress(ValueError)` instead of `try`-`except`-`pass`
    |
377 |                       pass
378 |               elif "timestamp" in key and isinstance(value, str):
379 | /                 try:
380 | |                     data[key] = datetime.fromisoformat(value)
381 | |                 except ValueError:
382 | |                     pass
    | |________________________^ SIM105
383 |               elif key in ["price", "volume", "quantity", "sl_price", "tp_price",
384 |                            "limit_price", "bid", "ask", "bid_size", "ask_size",
    |
    = help: Replace with `contextlib.suppress(ValueError)`

gal_friday/core/events.py:383:13: SIM102 Use a single `if` statement instead of nested `if` statements
    |
381 |                   except ValueError:
382 |                       pass
383 | /             elif key in ["price", "volume", "quantity", "sl_price", "tp_price",
384 | |                          "limit_price", "bid", "ask", "bid_size", "ask_size",
385 | |                          "last_price", "last_size", "volume_24h", "vwap_24h",
386 | |                          "high_24h", "low_24h", "quantity_ordered", "quantity_filled",
387 | |                          "average_fill_price", "stop_price", "commission",
388 | |                          "proposed_sl_price", "proposed_tp_price", "proposed_entry_price"]:
389 | |                 if value is not None and value != "None":
    | |_________________________________________________________^ SIM102
390 |                       data[key] = Decimal(str(value))
    |
    = help: Combine `if` statements using `and`

gal_friday/core/events.py:518:100: E501 Line too long (100 > 99)
    |
516 |         for field_name, price in price_fields:
517 |             if price <= Decimal("0"):
518 |                 raise ValueError(self._NON_POSITIVE_PRICE_MSG.format(field=field_name, price=price))
    |                                                                                                    ^ E501
519 |
520 |         # Validate sizes
    |

gal_friday/core/events.py:1141:71: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
     |
1140 |     @classmethod
1141 |     def create(cls, source_module: str, error_message: str, **kwargs: Any) -> "APIErrorEvent":
     |                                                                       ^^^ ANN401
1142 |         """Create a new APIErrorEvent with a generated UUID and current timestamp.
     |

gal_friday/core/halt_coordinator.py:31:9: ANN204 Missing return type annotation for special method `__init__`
   |
29 |     """Central coordinator for all HALT conditions and triggers."""
30 |
31 |     def __init__(self, config_manager: ConfigManager, pubsub_manager: PubSubManager, logger_service: LoggerService):
   |         ^^^^^^^^ ANN204
32 |         self.config = config_manager
33 |         self.pubsub = pubsub_manager
   |
   = help: Add return type annotation: `None`

gal_friday/core/halt_coordinator.py:31:9: D107 Missing docstring in `__init__`
   |
29 |     """Central coordinator for all HALT conditions and triggers."""
30 |
31 |     def __init__(self, config_manager: ConfigManager, pubsub_manager: PubSubManager, logger_service: LoggerService):
   |         ^^^^^^^^ D107
32 |         self.config = config_manager
33 |         self.pubsub = pubsub_manager
   |

gal_friday/core/halt_coordinator.py:31:100: E501 Line too long (116 > 99)
   |
29 |     """Central coordinator for all HALT conditions and triggers."""
30 |
31 |     def __init__(self, config_manager: ConfigManager, pubsub_manager: PubSubManager, logger_service: LoggerService):
   |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
32 |         self.config = config_manager
33 |         self.pubsub = pubsub_manager
   |

gal_friday/core/halt_coordinator.py:89:75: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `threshold`
   |
87 |         )
88 |
89 |     def register_condition(self, condition_id: str, name: str, threshold: Any) -> None:
   |                                                                           ^^^ ANN401
90 |         """Register a new HALT condition."""
91 |         self.conditions[condition_id] = HaltCondition(
   |

gal_friday/core/halt_coordinator.py:100:66: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `current_value`
    |
 98 |         )
 99 |
100 |     def update_condition(self, condition_id: str, current_value: Any) -> bool:
    |                                                                  ^^^ ANN401
101 |         """Update a condition's current value and check if triggered.
    |

gal_friday/core/halt_coordinator.py:102:1: W293 Blank line contains whitespace
    |
100 |     def update_condition(self, condition_id: str, current_value: Any) -> bool:
101 |         """Update a condition's current value and check if triggered.
102 |
    | ^^^^^^^^ W293
103 |         Returns:
104 |             bool: True if condition is triggered
    |
    = help: Remove whitespace from blank line

gal_friday/core/halt_coordinator.py:120:12: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
118 |         was_triggered = condition.is_triggered
119 |
120 |         if isinstance(condition.threshold, (int, float, Decimal)):
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
121 |             # Numeric comparison
122 |             condition.is_triggered = current_value > condition.threshold
    |
    = help: Convert to `X | Y`

gal_friday/core/halt_coordinator.py:133:100: E501 Line too long (112 > 99)
    |
131 |         if condition.is_triggered != was_triggered:
132 |             self.logger.warning(
133 |                 f"HALT condition '{condition.name}' state changed: {was_triggered} -> {condition.is_triggered}",
    |                                                                                                    ^^^^^^^^^^^^^ E501
134 |                 source_module=self._source_module,
135 |                 context={
    |

gal_friday/core/halt_recovery.py:27:9: ANN204 Missing return type annotation for special method `__init__`
   |
25 |     """Manages the recovery process after a HALT."""
26 |
27 |     def __init__(self, config_manager: ConfigManager, logger_service: LoggerService):
   |         ^^^^^^^^ ANN204
28 |         self.config = config_manager
29 |         self.logger = logger_service
   |
   = help: Add return type annotation: `None`

gal_friday/core/halt_recovery.py:27:9: D107 Missing docstring in `__init__`
   |
25 |     """Manages the recovery process after a HALT."""
26 |
27 |     def __init__(self, config_manager: ConfigManager, logger_service: LoggerService):
   |         ^^^^^^^^ D107
28 |         self.config = config_manager
29 |         self.logger = logger_service
   |

gal_friday/core/halt_recovery.py:78:1: W293 Blank line contains whitespace
   |
76 |     def complete_item(self, item_id: str, completed_by: str) -> bool:
77 |         """Mark a checklist item as complete.
78 |
   | ^^^^^^^^ W293
79 |         Args:
80 |             item_id: ID of the checklist item
   |
   = help: Remove whitespace from blank line

gal_friday/core/halt_recovery.py:82:1: W293 Blank line contains whitespace
   |
80 |             item_id: ID of the checklist item
81 |             completed_by: Name of person completing the item
82 |
   | ^^^^^^^^^^^^ W293
83 |         Returns:
84 |             bool: True if item was found and marked complete
   |
   = help: Remove whitespace from blank line

gal_friday/core/halt_recovery.py:126:1: W293 Blank line contains whitespace
    |
124 |     def get_checklist_status(self) -> dict:
125 |         """Get current status of recovery checklist.
126 |
    | ^^^^^^^^ W293
127 |         Returns:
128 |             dict: Status information including completed count and items
    |
    = help: Remove whitespace from blank line

gal_friday/core/types.py:10:22: TC003 Move standard library import `datetime.datetime` into a type-checking block
   |
 8 | from __future__ import annotations
 9 |
10 | from datetime import datetime
   |                      ^^^^^^^^ TC003
11 | from decimal import Decimal
12 | from typing import Any, Protocol, TypeVar, runtime_checkable
   |
   = help: Move into type-checking block

gal_friday/core/types.py:11:21: TC003 Move standard library import `decimal.Decimal` into a type-checking block
   |
10 | from datetime import datetime
11 | from decimal import Decimal
   |                     ^^^^^^^ TC003
12 | from typing import Any, Protocol, TypeVar, runtime_checkable
   |
   = help: Move into type-checking block

gal_friday/core/types.py:14:18: TC002 Move third-party import `pandas` into a type-checking block
   |
12 | from typing import Any, Protocol, TypeVar, runtime_checkable
13 |
14 | import pandas as pd
   |                  ^^ TC002
15 |
16 | # Type variables for generic types
   |
   = help: Move into type-checking block

gal_friday/core/types.py:26:9: D102 Missing docstring in public method
   |
24 |     """Protocol for configuration management."""
25 |
26 |     def get(self, key: str, default: T | None = None) -> T | None:
   |         ^^^ D102
27 |         ...
   |

gal_friday/core/types.py:29:9: D105 Missing docstring in magic method
   |
27 |         ...
28 |
29 |     def __getitem__(self, key: str) -> Any:
   |         ^^^^^^^^^^^ D105
30 |         ...
   |

gal_friday/core/types.py:29:40: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `__getitem__`
   |
27 |         ...
28 |
29 |     def __getitem__(self, key: str) -> Any:
   |                                        ^^^ ANN401
30 |         ...
   |

gal_friday/core/types.py:37:9: D102 Missing docstring in public method
   |
35 |     """Protocol for logging service."""
36 |
37 |     def log(self, message: str, level: str = "info", **kwargs: Any) -> None:
   |         ^^^ D102
38 |         ...
   |

gal_friday/core/types.py:37:64: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   |
35 |     """Protocol for logging service."""
36 |
37 |     def log(self, message: str, level: str = "info", **kwargs: Any) -> None:
   |                                                                ^^^ ANN401
38 |         ...
   |

gal_friday/core/types.py:40:9: D102 Missing docstring in public method
   |
38 |         ...
39 |
40 |     def debug(self, message: str, **kwargs: Any) -> None:
   |         ^^^^^ D102
41 |         ...
   |

gal_friday/core/types.py:40:45: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   |
38 |         ...
39 |
40 |     def debug(self, message: str, **kwargs: Any) -> None:
   |                                             ^^^ ANN401
41 |         ...
   |

gal_friday/core/types.py:43:9: D102 Missing docstring in public method
   |
41 |         ...
42 |
43 |     def info(self, message: str, **kwargs: Any) -> None:
   |         ^^^^ D102
44 |         ...
   |

gal_friday/core/types.py:43:44: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   |
41 |         ...
42 |
43 |     def info(self, message: str, **kwargs: Any) -> None:
   |                                            ^^^ ANN401
44 |         ...
   |

gal_friday/core/types.py:46:9: D102 Missing docstring in public method
   |
44 |         ...
45 |
46 |     def warning(self, message: str, **kwargs: Any) -> None:
   |         ^^^^^^^ D102
47 |         ...
   |

gal_friday/core/types.py:46:47: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   |
44 |         ...
45 |
46 |     def warning(self, message: str, **kwargs: Any) -> None:
   |                                               ^^^ ANN401
47 |         ...
   |

gal_friday/core/types.py:49:9: D102 Missing docstring in public method
   |
47 |         ...
48 |
49 |     def error(self, message: str, **kwargs: Any) -> None:
   |         ^^^^^ D102
50 |         ...
   |

gal_friday/core/types.py:49:45: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   |
47 |         ...
48 |
49 |     def error(self, message: str, **kwargs: Any) -> None:
   |                                             ^^^ ANN401
50 |         ...
   |

gal_friday/core/types.py:52:9: D102 Missing docstring in public method
   |
50 |         ...
51 |
52 |     def exception(self, message: str, **kwargs: Any) -> None:
   |         ^^^^^^^^^ D102
53 |         ...
   |

gal_friday/core/types.py:52:49: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   |
50 |         ...
51 |
52 |     def exception(self, message: str, **kwargs: Any) -> None:
   |                                                 ^^^ ANN401
53 |         ...
   |

gal_friday/core/types.py:55:9: D102 Missing docstring in public method
   |
53 |         ...
54 |
55 |     def critical(self, message: str, **kwargs: Any) -> None:
   |         ^^^^^^^^ D102
56 |         ...
   |

gal_friday/core/types.py:55:48: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   |
53 |         ...
54 |
55 |     def critical(self, message: str, **kwargs: Any) -> None:
   |                                                ^^^ ANN401
56 |         ...
   |

gal_friday/core/types.py:63:9: D102 Missing docstring in public method
   |
61 |     """Protocol for market price service."""
62 |
63 |     def get_price(self, symbol: str) -> Decimal | None:
   |         ^^^^^^^^^ D102
64 |         ...
   |

gal_friday/core/types.py:66:9: D102 Missing docstring in public method
   |
64 |         ...
65 |
66 |     def get_prices(self, symbols: list[str]) -> dict[str, Decimal | None]:
   |         ^^^^^^^^^^ D102
67 |         ...
   |

gal_friday/core/types.py:74:9: D102 Missing docstring in public method
   |
72 |     """Protocol for portfolio management."""
73 |
74 |     def get_balance(self, currency: str = "USD") -> Decimal:
   |         ^^^^^^^^^^^ D102
75 |         ...
   |

gal_friday/core/types.py:77:9: D102 Missing docstring in public method
   |
75 |         ...
76 |
77 |     def get_position(self, symbol: str) -> Decimal:
   |         ^^^^^^^^^^^^ D102
78 |         ...
   |

gal_friday/core/types.py:80:9: D102 Missing docstring in public method
   |
78 |         ...
79 |
80 |     def get_positions(self) -> dict[str, Decimal]:
   |         ^^^^^^^^^^^^^ D102
81 |         ...
   |

gal_friday/core/types.py:88:9: D102 Missing docstring in public method
   |
86 |     """Protocol for feature engineering."""
87 |
88 |     def add_features(self, data: pd.DataFrame) -> pd.DataFrame:
   |         ^^^^^^^^^^^^ D102
89 |         ...
   |

gal_friday/core/types.py:96:9: D102 Missing docstring in public method
   |
94 |     """Protocol for prediction service."""
95 |
96 |     def predict(self, features: pd.DataFrame) -> Any:
   |         ^^^^^^^ D102
97 |         ...
   |

gal_friday/core/types.py:96:50: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `predict`
   |
94 |     """Protocol for prediction service."""
95 |
96 |     def predict(self, features: pd.DataFrame) -> Any:
   |                                                  ^^^ ANN401
97 |         ...
   |

gal_friday/core/types.py:104:9: D102 Missing docstring in public method
    |
102 |     """Protocol for risk management."""
103 |
104 |     def check_risk(self, order: dict[str, Any]) -> bool:
    |         ^^^^^^^^^^ D102
105 |         ...
    |

gal_friday/core/types.py:112:9: D102 Missing docstring in public method
    |
110 |     """Protocol for strategy arbitration."""
111 |
112 |     def decide_action(self, signals: dict[str, Any]) -> dict[str, Any]:
    |         ^^^^^^^^^^^^^ D102
113 |         ...
    |

gal_friday/core/types.py:120:9: D102 Missing docstring in public method
    |
118 |     """Protocol for exchange information service."""
119 |
120 |     def get_symbol_info(self, symbol: str) -> dict[str, Any]:
    |         ^^^^^^^^^^^^^^^ D102
121 |         ...
    |

gal_friday/core/types.py:128:15: D102 Missing docstring in public method
    |
126 |     """Protocol for order execution."""
127 |
128 |     async def execute_order(self, order: dict[str, Any]) -> dict[str, Any]:
    |               ^^^^^^^^^^^^^ D102
129 |         ...
    |

gal_friday/core/types.py:136:9: D102 Missing docstring in public method
    |
134 |     """Protocol for pub/sub management."""
135 |
136 |     def subscribe(self, channel: str, callback: Any) -> None:
    |         ^^^^^^^^^ D102
137 |         ...
    |

gal_friday/core/types.py:136:49: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `callback`
    |
134 |     """Protocol for pub/sub management."""
135 |
136 |     def subscribe(self, channel: str, callback: Any) -> None:
    |                                                 ^^^ ANN401
137 |         ...
    |

gal_friday/core/types.py:139:9: D102 Missing docstring in public method
    |
137 |         ...
138 |
139 |     def publish(self, channel: str, message: Any) -> None:
    |         ^^^^^^^ D102
140 |         ...
    |

gal_friday/core/types.py:139:46: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `message`
    |
137 |         ...
138 |
139 |     def publish(self, channel: str, message: Any) -> None:
    |                                              ^^^ ANN401
140 |         ...
    |

gal_friday/core/types.py:147:9: D102 Missing docstring in public method
    |
145 |     """Protocol for historical data access during backtesting."""
146 |
147 |     def get_historical_ohlcv(
    |         ^^^^^^^^^^^^^^^^^^^^ D102
148 |         self,
149 |         trading_pair: str,
    |

gal_friday/core/types.py:156:9: D102 Missing docstring in public method
    |
154 |         ...
155 |
156 |     def get_historical_trades(
    |         ^^^^^^^^^^^^^^^^^^^^^ D102
157 |         self,
158 |         trading_pair: str,
    |

gal_friday/dal/__init__.py:6:100: E501 Line too long (111 > 99)
  |
4 | from .connection_pool import DatabaseConnectionPool
5 |
6 | # from .influxdb_client import TimeSeriesDB # Commented out to avoid ModuleNotFoundError during alembic autogen
  |                                                                                                    ^^^^^^^^^^^^ E501
7 |
8 | __all__ = [
  |

gal_friday/dal/alembic_env/env.py:1:1: D100 Missing docstring in public module
gal_friday/dal/alembic_env/env.py:10:20: PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
   |
 9 | # Ensure the application's root directory is in the Python path
10 | sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", "..")))
   |                    ^^^^^^^^^^^^^^^ PTH100
11 |
12 | # Imports for Alembic hook type hints
   |

gal_friday/dal/alembic_env/env.py:10:36: PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   |
 9 | # Ensure the application's root directory is in the Python path
10 | sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", "..")))
   |                                    ^^^^^^^^^^^^ PTH118
11 |
12 | # Imports for Alembic hook type hints
   |

gal_friday/dal/alembic_env/env.py:10:49: PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   |
 9 | # Ensure the application's root directory is in the Python path
10 | sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", "..")))
   |                                                 ^^^^^^^^^^^^^^^ PTH120
11 |
12 | # Imports for Alembic hook type hints
   |

gal_friday/dal/alembic_env/env.py:32:1: E402 Module level import not at top of file
   |
31 | # add your model's MetaData object here
32 | from gal_friday.dal.models import Base  # Import Base from your models package
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
33 |
34 | # Import all models to ensure they are registered with Base.metadata
   |

gal_friday/dal/alembic_env/env.py:39:5: D103 Missing docstring in public function
   |
38 | # Typed dummy functions for Alembic hooks
39 | def process_revision_directives(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
40 |     context: MigrationContext, revision: str | tuple[str, ...], directives: list[Any],
41 | ) -> None:
   |

gal_friday/dal/alembic_env/env.py:42:5: T201 `print` found
   |
40 |     context: MigrationContext, revision: str | tuple[str, ...], directives: list[Any],
41 | ) -> None:
42 |     print(f"Processing revision {revision} with directives: {directives}")
   |     ^^^^^ T201
43 |
44 | def render_item(
   |
   = help: Remove `print`

gal_friday/dal/alembic_env/env.py:44:5: D103 Missing docstring in public function
   |
42 |     print(f"Processing revision {revision} with directives: {directives}")
43 |
44 | def render_item(
   |     ^^^^^^^^^^^ D103
45 |     type_: str, obj: Any, autogen_context: AutogenContext,
46 | ) -> str | Literal[False] | None:
   |

gal_friday/dal/alembic_env/env.py:45:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `obj`
   |
44 | def render_item(
45 |     type_: str, obj: Any, autogen_context: AutogenContext,
   |                      ^^^ ANN401
46 | ) -> str | Literal[False] | None:
47 |     print(f"Rendering item type {type_} for object {obj}")
   |

gal_friday/dal/alembic_env/env.py:47:5: T201 `print` found
   |
45 |     type_: str, obj: Any, autogen_context: AutogenContext,
46 | ) -> str | Literal[False] | None:
47 |     print(f"Rendering item type {type_} for object {obj}")
   |     ^^^^^ T201
48 |     return None
   |
   = help: Remove `print`

gal_friday/dal/alembic_env/env.py:50:5: D103 Missing docstring in public function
   |
48 |     return None
49 |
50 | def include_object(
   |     ^^^^^^^^^^^^^^ D103
51 |     object: SchemaItem, name: str | None, type_: str, reflected: bool, compare_to: Any | None,
52 | ) -> bool:
   |

gal_friday/dal/alembic_env/env.py:51:84: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `compare_to`
   |
50 | def include_object(
51 |     object: SchemaItem, name: str | None, type_: str, reflected: bool, compare_to: Any | None,
   |                                                                                    ^^^^^^^^^^ ANN401
52 | ) -> bool:
53 |     print(f"Checking include_object for {type_} {name}")
   |

gal_friday/dal/alembic_env/env.py:53:5: T201 `print` found
   |
51 |     object: SchemaItem, name: str | None, type_: str, reflected: bool, compare_to: Any | None,
52 | ) -> bool:
53 |     print(f"Checking include_object for {type_} {name}")
   |     ^^^^^ T201
54 |     return True
   |
   = help: Remove `print`

gal_friday/dal/alembic_env/env.py:56:5: D103 Missing docstring in public function
   |
54 |     return True
55 |
56 | def include_name(
   |     ^^^^^^^^^^^^ D103
57 |     name: str | None, type_: str, parent_names: dict[str, Any] | None,
58 | ) -> bool:
   |

gal_friday/dal/alembic_env/env.py:59:5: T201 `print` found
   |
57 |     name: str | None, type_: str, parent_names: dict[str, Any] | None,
58 | ) -> bool:
59 |     print(f"Checking include_name for {type_} {name}")
   |     ^^^^^ T201
60 |     return True
   |
   = help: Remove `print`

gal_friday/dal/alembic_env/env.py:62:5: D103 Missing docstring in public function
   |
60 |     return True
61 |
62 | def include_symbol(
   |     ^^^^^^^^^^^^^^ D103
63 |     table_name: str,
64 |     schema_name: str | None,
   |

gal_friday/dal/alembic_env/env.py:69:5: T201 `print` found
   |
67 |     symbol_name: str,
68 | ) -> bool:
69 |     print(f"Checking include_symbol for {symbol_type} {symbol_name} in table {schema_name}.{table_name}")
   |     ^^^^^ T201
70 |     return True
   |
   = help: Remove `print`

gal_friday/dal/alembic_env/env.py:69:100: E501 Line too long (105 > 99)
   |
67 |     symbol_name: str,
68 | ) -> bool:
69 |     print(f"Checking include_symbol for {symbol_type} {symbol_name} in table {schema_name}.{table_name}")
   |                                                                                                    ^^^^^^ E501
70 |     return True
   |

gal_friday/dal/alembic_env/env.py:72:5: D103 Missing docstring in public function
   |
70 |     return True
71 |
72 | def compare_type(
   |     ^^^^^^^^^^^^ D103
73 |     context: CompareTypeContext,
74 |     inspected_column: dict[str, Any],
   |

gal_friday/dal/alembic_env/env.py:76:21: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `inspected_type`
   |
74 |     inspected_column: dict[str, Any],
75 |     metadata_column: SAColumn,
76 |     inspected_type: Any,
   |                     ^^^ ANN401
77 |     metadata_type: Any,
78 | ) -> bool | None:
   |

gal_friday/dal/alembic_env/env.py:77:20: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `metadata_type`
   |
75 |     metadata_column: SAColumn,
76 |     inspected_type: Any,
77 |     metadata_type: Any,
   |                    ^^^ ANN401
78 | ) -> bool | None:
79 |     print(f"Comparing type for column {metadata_column.name}: DB {inspected_type} vs Meta {metadata_type}")
   |

gal_friday/dal/alembic_env/env.py:79:5: T201 `print` found
   |
77 |     metadata_type: Any,
78 | ) -> bool | None:
79 |     print(f"Comparing type for column {metadata_column.name}: DB {inspected_type} vs Meta {metadata_type}")
   |     ^^^^^ T201
80 |     return None
   |
   = help: Remove `print`

gal_friday/dal/alembic_env/env.py:79:100: E501 Line too long (107 > 99)
   |
77 |     metadata_type: Any,
78 | ) -> bool | None:
79 |     print(f"Comparing type for column {metadata_column.name}: DB {inspected_type} vs Meta {metadata_type}")
   |                                                                                                    ^^^^^^^^ E501
80 |     return None
   |

gal_friday/dal/alembic_env/env.py:83:1: E402 Module level import not at top of file
   |
82 | # Import ConfigManager to get database URL
83 | from gal_friday.config_manager import ConfigManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
84 |
85 | # from gal_friday.logger_service import LoggerService # Not strictly used here
   |

gal_friday/dal/alembic_env/env.py:87:5: D103 Missing docstring in public function
   |
85 | # from gal_friday.logger_service import LoggerService # Not strictly used here
86 |
87 | def get_db_url() -> str:
   |     ^^^^^^^^^^ D103
88 |     try:
89 |         config_manager = ConfigManager()
   |

gal_friday/dal/alembic_env/env.py:93:13: T201 `print` found
   |
91 |         if not db_url:
92 |             db_url = config.get_main_option("sqlalchemy.url")
93 |             print(f"Warning: DB URL from ConfigManager empty, falling back to alembic.ini URL: {db_url}")
   |             ^^^^^ T201
94 |         else:
95 |             print(f"Using DB URL from ConfigManager: {db_url}")
   |
   = help: Remove `print`

gal_friday/dal/alembic_env/env.py:93:100: E501 Line too long (105 > 99)
   |
91 |         if not db_url:
92 |             db_url = config.get_main_option("sqlalchemy.url")
93 |             print(f"Warning: DB URL from ConfigManager empty, falling back to alembic.ini URL: {db_url}")
   |                                                                                                    ^^^^^^ E501
94 |         else:
95 |             print(f"Using DB URL from ConfigManager: {db_url}")
   |

gal_friday/dal/alembic_env/env.py:95:13: T201 `print` found
   |
93 |             print(f"Warning: DB URL from ConfigManager empty, falling back to alembic.ini URL: {db_url}")
94 |         else:
95 |             print(f"Using DB URL from ConfigManager: {db_url}")
   |             ^^^^^ T201
96 |         return cast("str", db_url)
97 |     except Exception as e:
   |
   = help: Remove `print`

gal_friday/dal/alembic_env/env.py:98:9: T201 `print` found
   |
96 |         return cast("str", db_url)
97 |     except Exception as e:
98 |         print(f"Error getting DB URL from ConfigManager: {e}. Falling back to alembic.ini.")
   |         ^^^^^ T201
99 |         return cast("str", config.get_main_option("sqlalchemy.url"))
   |
   = help: Remove `print`

gal_friday/dal/alembic_env/env.py:102:5: D103 Missing docstring in public function
    |
102 | def run_migrations_offline() -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^ D103
103 |     url = get_db_url()
104 |     context.configure(
    |

gal_friday/dal/alembic_env/env.py:120:5: D103 Missing docstring in public function
    |
120 | def do_run_migrations(connection: Connection) -> None:
    |     ^^^^^^^^^^^^^^^^^ D103
121 |     context.configure(
122 |         connection=connection,
    |

gal_friday/dal/alembic_env/env.py:137:11: D103 Missing docstring in public function
    |
137 | async def run_async_migrations() -> None:
    |           ^^^^^^^^^^^^^^^^^^^^ D103
138 |     db_url = get_db_url()
139 |     print("Configuring context for metadata-only autogeneration (no actual DB connection attempt).")
    |

gal_friday/dal/alembic_env/env.py:139:5: T201 `print` found
    |
137 | async def run_async_migrations() -> None:
138 |     db_url = get_db_url()
139 |     print("Configuring context for metadata-only autogeneration (no actual DB connection attempt).")
    |     ^^^^^ T201
140 |     context.configure(
141 |         connection=None,
    |
    = help: Remove `print`

gal_friday/dal/alembic_env/env.py:139:100: E501 Line too long (100 > 99)
    |
137 | async def run_async_migrations() -> None:
138 |     db_url = get_db_url()
139 |     print("Configuring context for metadata-only autogeneration (no actual DB connection attempt).")
    |                                                                                                    ^ E501
140 |     context.configure(
141 |         connection=None,
    |

gal_friday/dal/alembic_env/env.py:157:5: D103 Missing docstring in public function
    |
157 | def run_migrations_online() -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^ D103
158 |     asyncio.run(run_async_migrations())
    |

gal_friday/dal/alembic_env/versions/20250528_1d03e90d0571_initial_schema_from_models_manual.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """initial_schema_from_models_manual
2 | |
3 | | Revision ID: 1d03e90d0571
4 | | Revises:
5 | | Create Date: 2025-05-28 21:10:06.655207
6 | |
7 | | """
  | |___^ D415
8 |   from collections.abc import Sequence
  |
  = help: Add closing punctuation

gal_friday/dal/alembic_env/versions/20250528_1d03e90d0571_initial_schema_from_models_manual.py:4:9: W291 Trailing whitespace
  |
3 | Revision ID: 1d03e90d0571
4 | Revises:
  |         ^ W291
5 | Create Date: 2025-05-28 21:10:06.655207
  |
  = help: Remove trailing whitespace

gal_friday/dal/alembic_env/versions/20250528_3d5abeaa9f0e_initial_schema_ddl_manual_v8.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """initial_schema_ddl_manual_v8
2 | |
3 | | Revision ID: 3d5abeaa9f0e
4 | | Revises: 6c1cbd03238e
5 | | Create Date: 2025-05-28 21:19:08.967180
6 | |
7 | | """
  | |___^ D415
8 |   from collections.abc import Sequence
  |
  = help: Add closing punctuation

gal_friday/dal/alembic_env/versions/20250528_465b5ba8a9a2_initial_schema_ddl_manual_v4.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """initial_schema_ddl_manual_v4
2 | |
3 | | Revision ID: 465b5ba8a9a2
4 | | Revises: a31175f3afaa
5 | | Create Date: 2025-05-28 21:14:57.229832
6 | |
7 | | """
  | |___^ D415
8 |   from collections.abc import Sequence
  |
  = help: Add closing punctuation

gal_friday/dal/alembic_env/versions/20250528_5f3f435c87b5_initial_schema_from_models_ddl_final_v2.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """initial_schema_from_models_ddl_final_v2
2 | |
3 | | Revision ID: 5f3f435c87b5
4 | | Revises: dd043229e679
5 | | Create Date: 2025-05-28 21:16:59.578706
6 | |
7 | | """
  | |___^ D415
8 |   from collections.abc import Sequence
  |
  = help: Add closing punctuation

gal_friday/dal/alembic_env/versions/20250528_6bdebe2daca2_initial_schema_from_models_manual_v2.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """initial_schema_from_models_manual_v2
2 | |
3 | | Revision ID: 6bdebe2daca2
4 | | Revises: 1d03e90d0571
5 | | Create Date: 2025-05-28 21:10:50.098744
6 | |
7 | | """
  | |___^ D415
8 |   from collections.abc import Sequence
  |
  = help: Add closing punctuation

gal_friday/dal/alembic_env/versions/20250528_6c1cbd03238e_initial_schema_ddl_manual_v7.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """initial_schema_ddl_manual_v7
2 | |
3 | | Revision ID: 6c1cbd03238e
4 | | Revises: 5f3f435c87b5
5 | | Create Date: 2025-05-28 21:18:22.118325
6 | |
7 | | """
  | |___^ D415
8 |   from collections.abc import Sequence
  |
  = help: Add closing punctuation

gal_friday/dal/alembic_env/versions/20250528_6fe597dcab71_initial_schema_manual_20240904_take2.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """initial_schema_manual_20240904_take2
2 | |
3 | | Revision ID: 6fe597dcab71
4 | | Revises: c84200ac0af7
5 | | Create Date: 2025-05-28 21:13:06.059358
6 | |
7 | | """
  | |___^ D415
8 |   from collections.abc import Sequence
  |
  = help: Add closing punctuation

gal_friday/dal/alembic_env/versions/20250528_a31175f3afaa_initial_schema_from_models_manual_.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """initial_schema_from_models_manual_20240905
2 | |
3 | | Revision ID: a31175f3afaa
4 | | Revises: 6fe597dcab71
5 | | Create Date: 2025-05-28 21:13:51.070520
6 | |
7 | | """
  | |___^ D415
8 |   from collections.abc import Sequence
  |
  = help: Add closing punctuation

gal_friday/dal/alembic_env/versions/20250528_c84200ac0af7_initial_schema_from_models_manual_final.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """initial_schema_from_models_manual_final
2 | |
3 | | Revision ID: c84200ac0af7
4 | | Revises: d1749c89baa0
5 | | Create Date: 2025-05-28 21:12:23.833165
6 | |
7 | | """
  | |___^ D415
8 |   from collections.abc import Sequence
  |
  = help: Add closing punctuation

gal_friday/dal/alembic_env/versions/20250528_ca9c62eed06d_initial_schema_ddl_manual_v9.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """initial_schema_ddl_manual_v9
2 | |
3 | | Revision ID: ca9c62eed06d
4 | | Revises: 3d5abeaa9f0e
5 | | Create Date: 2025-05-28 21:20:36.352566
6 | |
7 | | """
  | |___^ D415
8 |   from collections.abc import Sequence
  |
  = help: Add closing punctuation

gal_friday/dal/alembic_env/versions/20250528_d1749c89baa0_initial_schema_from_models_manual_v3.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """initial_schema_from_models_manual_v3
2 | |
3 | | Revision ID: d1749c89baa0
4 | | Revises: 6bdebe2daca2
5 | | Create Date: 2025-05-28 21:11:37.893894
6 | |
7 | | """
  | |___^ D415
8 |   from collections.abc import Sequence
  |
  = help: Add closing punctuation

gal_friday/dal/alembic_env/versions/20250528_dd043229e679_initial_schema_ddl_manual_v6.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """initial_schema_ddl_manual_v6
2 | |
3 | | Revision ID: dd043229e679
4 | | Revises: 465b5ba8a9a2
5 | | Create Date: 2025-05-28 21:16:14.970591
6 | |
7 | | """
  | |___^ D415
8 |   from collections.abc import Sequence
  |
  = help: Add closing punctuation

gal_friday/dal/base.py:52:17: SIM108 Use ternary operator `instance = self.model_class(**data) if isinstance(data, dict) else data` instead of `if`-`else`-block
   |
50 |           try:
51 |               async with self.session_maker() as session:
52 | /                 if isinstance(data, dict):
53 | |                     instance = self.model_class(**data)
54 | |                 else:
55 | |                     instance = data
   | |___________________________________^ SIM108
56 |
57 |                   session.add(instance)
   |
   = help: Replace `if`-`else`-block with `instance = self.model_class(**data) if isinstance(data, dict) else data`

gal_friday/dal/base.py:59:100: E501 Line too long (105 > 99)
   |
57 |                 session.add(instance)
58 |                 await session.commit()  # Commit flushes and expires objects
59 |                 await session.refresh(instance) # Refresh to get server-side defaults like ID, created_at
   |                                                                                                    ^^^^^^ E501
60 |                 self.logger.debug(
61 |                     f"Created new {self.model_class.__name__} with ID {getattr(instance, 'id', None)}",
   |

gal_friday/dal/base.py:61:100: E501 Line too long (103 > 99)
   |
59 |                 await session.refresh(instance) # Refresh to get server-side defaults like ID, created_at
60 |                 self.logger.debug(
61 |                     f"Created new {self.model_class.__name__} with ID {getattr(instance, 'id', None)}",
   |                                                                                                    ^^^^ E501
62 |                     source_module=self._source_module,
63 |                 )
   |

gal_friday/dal/base.py:72:42: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `entity_id`
   |
70 |             raise
71 |
72 |     async def get_by_id(self, entity_id: Any) -> T | None:
   |                                          ^^^ ANN401
73 |         """Get an entity by its primary key.
   |

gal_friday/dal/base.py:105:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `entity_id`
    |
103 |             raise
104 |
105 |     async def update(self, entity_id: Any, updates: dict[str, Any]) -> T | None:
    |                                       ^^^ ANN401
106 |         """Update an existing entity.
    |

gal_friday/dal/base.py:134:100: E501 Line too long (117 > 99)
    |
132 |                         else:
133 |                             self.logger.warning(
134 |                                 f"Attempted to update non-existent attribute '{key}' on {self.model_class.__name__}",
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
135 |                                 source_module=self._source_module,
136 |                             )
    |

gal_friday/dal/base.py:148:100: E501 Line too long (104 > 99)
    |
146 |                     return entity
147 |                 self.logger.warning(
148 |                     f"Attempted to update non-existent {self.model_class.__name__} with ID {entity_id}",
    |                                                                                                    ^^^^^ E501
149 |                     source_module=self._source_module,
150 |                 )
    |

gal_friday/dal/base.py:191:100: E501 Line too long (109 > 99)
    |
189 |                         else:
190 |                             self.logger.warning(
191 |                                 f"Filter key '{column_name}' not found on model {self.model_class.__name__}",
    |                                                                                                    ^^^^^^^^^^ E501
192 |                                 source_module=self._source_module,
193 |                             )
    |

gal_friday/dal/base.py:198:100: E501 Line too long (111 > 99)
    |
196 |                     col_name = parts[0]
197 |                     if not hasattr(self.model_class, col_name):
198 |                         raise ValueError(f"Invalid order_by column: {col_name} on {self.model_class.__name__}")
    |                                                                                                    ^^^^^^^^^^^^ E501
199 |
200 |                     col = getattr(self.model_class, col_name)
    |

gal_friday/dal/base.py:231:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `entity_id`
    |
229 |             raise
230 |
231 |     async def delete(self, entity_id: Any) -> bool:
    |                                       ^^^ ANN401
232 |         """Delete entity by ID.
    |

gal_friday/dal/base.py:255:100: E501 Line too long (104 > 99)
    |
253 |                     return True
254 |                 self.logger.warning(
255 |                     f"Attempted to delete non-existent {self.model_class.__name__} with ID {entity_id}",
    |                                                                                                    ^^^^^ E501
256 |                     source_module=self._source_module,
257 |                 )
    |

gal_friday/dal/connection_pool.py:55:100: E501 Line too long (111 > 99)
   |
53 | …     self._engine = create_async_engine(
54 | …         db_url,
55 | …         pool_size=self.config.get_int("database.pool.min_size", 5), # SQLAlchemy uses pool_size
   |                                                                                      ^^^^^^^^^^^^ E501
56 | …         max_overflow=self.config.get_int("database.pool.max_size", 10) - self.config.get_int("database.pool.min_size", 5), # max_ove…
57 | …         pool_recycle=300, # Corresponds to max_inactive_connection_lifetime
   |

gal_friday/dal/connection_pool.py:56:100: E501 Line too long (196 > 99)
   |
54 | …
55 | …# SQLAlchemy uses pool_size
56 | …0) - self.config.get_int("database.pool.min_size", 5), # max_overflow is additional connections beyond pool_size
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
57 | …ifetime
58 | …ction acquisition)
   |

gal_friday/dal/connection_pool.py:58:100: E501 Line too long (102 > 99)
   |
56 | …         max_overflow=self.config.get_int("database.pool.max_size", 10) - self.config.get_int("database.pool.min_size", 5), # max_ove…
57 | …         pool_recycle=300, # Corresponds to max_inactive_connection_lifetime
58 | …         pool_timeout=10, # Corresponds to command_timeout (for connection acquisition)
   |                                                                                      ^^^ E501
59 | …         echo=self.config.get_bool("database.echo_sql", False), # Optional: log SQL
60 | …     )
   |

gal_friday/dal/migrations/migration_manager.py:29:61: PTH109 `os.getcwd()` should be replaced by `Path.cwd()`
   |
27 |         # Determine project root. If running inside a container where CWD is /app, this is fine.
28 |         # Otherwise, this needs to be passed or discovered more robustly.
29 |         _root = project_root_path if project_root_path else os.getcwd()
   |                                                             ^^^^^^^^^ PTH109
30 |         self.alembic_cfg_path = os.path.join(_root, "gal_friday", "dal", "alembic.ini")
   |

gal_friday/dal/migrations/migration_manager.py:30:33: PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   |
28 |         # Otherwise, this needs to be passed or discovered more robustly.
29 |         _root = project_root_path if project_root_path else os.getcwd()
30 |         self.alembic_cfg_path = os.path.join(_root, "gal_friday", "dal", "alembic.ini")
   |                                 ^^^^^^^^^^^^ PTH118
31 |
32 |         # Ensure alembic.ini exists
   |

gal_friday/dal/migrations/migration_manager.py:33:16: PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   |
32 |         # Ensure alembic.ini exists
33 |         if not os.path.exists(self.alembic_cfg_path):
   |                ^^^^^^^^^^^^^^ PTH110
34 |             self.logger.error(
35 |                 f"Alembic config file not found at: {self.alembic_cfg_path}",
   |

gal_friday/dal/migrations/migration_manager.py:43:1: W293 Blank line contains whitespace
   |
41 |     def _get_alembic_config(self) -> Config:
42 |         """Loads Alembic configuration from the .ini file.
43 |
   | ^^^^^^^^ W293
44 |         Ensures that the `prepend_sys_path` from `alembic.ini` (set to '..')
45 |         correctly adds the project root to sys.path if Alembic commands are
   |
   = help: Remove whitespace from blank line

gal_friday/dal/migrations/migration_manager.py:57:16: RET504 Unnecessary assignment to `alembic_cfg` before `return` statement
   |
55 |         # For example, if alembic.ini is in gal_friday/dal and script_location is alembic_env,
56 |         # it resolves to gal_friday/dal/alembic_env.
57 |         return alembic_cfg
   |                ^^^^^^^^^^^ RET504
58 |
59 |     def upgrade_to_head(self) -> None:
   |
   = help: Remove unnecessary assignment

gal_friday/dal/migrations/migration_manager.py:61:100: E501 Line too long (104 > 99)
   |
59 |     def upgrade_to_head(self) -> None:
60 |         """Upgrade the database to the latest revision ('head')."""
61 |         self.logger.info("Attempting to upgrade database to head...", source_module=self._source_module)
   |                                                                                                    ^^^^^ E501
62 |         try:
63 |             alembic_cfg = self._get_alembic_config()
   |

gal_friday/dal/migrations/migration_manager.py:65:100: E501 Line too long (115 > 99)
   |
63 |             alembic_cfg = self._get_alembic_config()
64 |             command.upgrade(alembic_cfg, "head")
65 |             self.logger.info("Database upgrade to head completed successfully.", source_module=self._source_module)
   |                                                                                                    ^^^^^^^^^^^^^^^^ E501
66 |         except Exception as e:
67 |             self.logger.exception(
   |

gal_friday/dal/migrations/migration_manager.py:75:100: E501 Line too long (118 > 99)
   |
73 |     def downgrade_to_version(self, version: str) -> None:
74 |         """Downgrade the database to a specific version."""
75 |         self.logger.info(f"Attempting to downgrade database to version: {version}", source_module=self._source_module)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
76 |         try:
77 |             alembic_cfg = self._get_alembic_config()
   |

gal_friday/dal/migrations/migration_manager.py:79:100: E501 Line too long (131 > 99)
   |
77 |             alembic_cfg = self._get_alembic_config()
78 |             command.downgrade(alembic_cfg, version)
79 |             self.logger.info(f"Database downgrade to version {version} completed successfully.", source_module=self._source_module)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
80 |         except Exception as e:
81 |             self.logger.exception(
   |

gal_friday/dal/migrations/migration_manager.py:89:100: E501 Line too long (104 > 99)
   |
87 |     def get_current_revision(self) -> Sequence[str | None]: # Alembic can have multiple heads
88 |         """Get the current revision(s) of the database."""
89 |         self.logger.debug("Fetching current database revision(s)...", source_module=self._source_module)
   |                                                                                                    ^^^^^ E501
90 |         try:
91 |             alembic_cfg = self._get_alembic_config()
   |

gal_friday/dal/migrations/migration_manager.py:93:13: F841 Local variable `script` is assigned to but never used
   |
91 |             alembic_cfg = self._get_alembic_config()
92 |             # script_location should be correctly interpreted by Config relative to alembic.ini
93 |             script = ScriptDirectory.from_config(alembic_cfg)
   |             ^^^^^^ F841
94 |
95 |             # To get current heads, we need an EnvironmentContext.
   |
   = help: Remove assignment to unused variable `script`

gal_friday/dal/migrations/migration_manager.py:97:100: E501 Line too long (107 > 99)
   |
95 |             # To get current heads, we need an EnvironmentContext.
96 |             # This part might require a database connection to check the alembic_version table.
97 |             # If this method is intended to run without a live DB connection, it might not work as expected
   |                                                                                                    ^^^^^^^^ E501
98 |             # or might only return script heads, not DB heads.
99 |             # The subtask is about refactoring MigrationManager, assuming it might be used in an env
   |

gal_friday/dal/migrations/migration_manager.py:99:100: E501 Line too long (100 > 99)
    |
 97 |             # If this method is intended to run without a live DB connection, it might not work as expected
 98 |             # or might only return script heads, not DB heads.
 99 |             # The subtask is about refactoring MigrationManager, assuming it might be used in an env
    |                                                                                                    ^ E501
100 |             # where DB is eventually available.
    |

gal_friday/dal/migrations/migration_manager.py:111:100: E501 Line too long (112 > 99)
    |
109 |             # Alternative: Using EnvironmentContext to get DB heads (requires DB access)
110 |             # This is more accurate if we want the DB's actual state.
111 |             # If the goal is "current revision in the script directory", script.get_revision("head") or similar.
    |                                                                                                    ^^^^^^^^^^^^^ E501
112 |             # For now, sticking to a method that can get DB state if possible.
    |

gal_friday/dal/migrations/migration_manager.py:129:100: E501 Line too long (100 > 99)
    |
128 |             if not output or "no migration detected" in output:
129 |                 self.logger.info("No current revision detected.", source_module=self._source_module)
    |                                                                                                    ^ E501
130 |                 return tuple() # Return empty tuple for no revision
    |

gal_friday/dal/migrations/migration_manager.py:140:100: E501 Line too long (109 > 99)
    |
138 |                     revisions.append(match)
139 |
140 |             self.logger.info(f"Current database revision(s): {revisions}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^ E501
141 |             return tuple(revisions)
    |

gal_friday/dal/migrations/migration_manager.py:153:100: E501 Line too long (107 > 99)
    |
151 |     def stamp_revision(self, revision: str) -> None:
152 |         """Stamp the database with a specific revision without running migrations."""
153 |         self.logger.info(f"Stamping database with revision: {revision}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^ E501
154 |         try:
155 |             alembic_cfg = self._get_alembic_config()
    |

gal_friday/dal/migrations/migration_manager.py:157:100: E501 Line too long (123 > 99)
    |
155 |             alembic_cfg = self._get_alembic_config()
156 |             command.stamp(alembic_cfg, revision)
157 |             self.logger.info(f"Database stamped with revision {revision} successfully.", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
158 |         except Exception as e:
159 |             self.logger.exception(
    |

gal_friday/dal/migrations/migration_manager.py:165:100: E501 Line too long (113 > 99)
    |
163 |             raise
164 |
165 |     def generate_revision(self, message: str, autogenerate: bool = True, revision_id: str | None = None) -> None:
    |                                                                                                    ^^^^^^^^^^^^^^ E501
166 |         """Generate a new revision file."""
167 |         self.logger.info(f"Generating new revision: '{message}' (autogenerate={autogenerate})", source_module=self._source_module)
    |

gal_friday/dal/migrations/migration_manager.py:167:100: E501 Line too long (130 > 99)
    |
165 |     def generate_revision(self, message: str, autogenerate: bool = True, revision_id: str | None = None) -> None:
166 |         """Generate a new revision file."""
167 |         self.logger.info(f"Generating new revision: '{message}' (autogenerate={autogenerate})", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
168 |         try:
169 |             alembic_cfg = self._get_alembic_config()
    |

gal_friday/dal/migrations/migration_manager.py:171:100: E501 Line too long (102 > 99)
    |
169 |             alembic_cfg = self._get_alembic_config()
170 |             # Note: autogenerate=True requires a database connection to compare metadata.
171 |             # If this is run in an environment without DB access, it might fail or produce empty diffs
    |                                                                                                    ^^^ E501
172 |             # unless env.py is specifically set up for "offline autogeneration" (which is complex).
173 |             # The current env.py setup (from previous subtasks) attempts this.
    |

gal_friday/dal/migrations/migration_manager.py:174:100: E501 Line too long (105 > 99)
    |
172 |             # unless env.py is specifically set up for "offline autogeneration" (which is complex).
173 |             # The current env.py setup (from previous subtasks) attempts this.
174 |             command.revision(alembic_cfg, message=message, autogenerate=autogenerate, rev_id=revision_id)
    |                                                                                                    ^^^^^^ E501
175 |             self.logger.info(f"New revision generated successfully: {message}", source_module=self._source_module)
176 |         except Exception as e:
    |

gal_friday/dal/migrations/migration_manager.py:175:100: E501 Line too long (114 > 99)
    |
173 |             # The current env.py setup (from previous subtasks) attempts this.
174 |             command.revision(alembic_cfg, message=message, autogenerate=autogenerate, rev_id=revision_id)
175 |             self.logger.info(f"New revision generated successfully: {message}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^ E501
176 |         except Exception as e:
177 |             self.logger.exception(
    |

gal_friday/dal/models/drift_detection_event.py:31:100: E501 Line too long (104 > 99)
   |
29 |     # Assuming model_versions.model_id is UUID and ModelVersion model exists
30 |     model_id: Mapped[UUID] = mapped_column(
31 |         ForeignKey("model_versions.model_id"), nullable=False, index=True, # Added index based on schema
   |                                                                                                    ^^^^^ E501
32 |     )
33 |     drift_type: Mapped[str] = mapped_column(String(50), nullable=False, index=True) # Added index
   |

gal_friday/dal/models/drift_detection_event.py:36:100: E501 Line too long (114 > 99)
   |
34 |     metric_name: Mapped[str] = mapped_column(String(100), nullable=False)
35 |     drift_score: Mapped[Decimal] = mapped_column(Numeric(10, 6), nullable=False)
36 |     is_significant: Mapped[bool | None] = mapped_column(Boolean, server_default="false", index=True) # Added index
   |                                                                                                    ^^^^^^^^^^^^^^^ E501
37 |     details: Mapped[dict | None] = mapped_column(JSONB, nullable=True)
38 |     detected_at: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True) # Added index
   |

gal_friday/dal/models/drift_detection_event.py:38:100: E501 Line too long (101 > 99)
   |
36 |     is_significant: Mapped[bool | None] = mapped_column(Boolean, server_default="false", index=True) # Added index
37 |     details: Mapped[dict | None] = mapped_column(JSONB, nullable=True)
38 |     detected_at: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True) # Added index
   |                                                                                                    ^^ E501
39 |
40 |     # Relationship to ModelVersion
   |

gal_friday/dal/models/drift_detection_event.py:50:9: D105 Missing docstring in magic method
   |
48 |     )
49 |
50 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
51 |         return (
52 |             f"<DriftDetectionEvent(event_id={self.event_id}, model_id={self.model_id}, "
   |

gal_friday/dal/models/event_log.py:5:44: N811 Constant `UUID` imported as non-constant `PostgresUUID`
  |
4 | from sqlalchemy import JSON, Column, DateTime, Index, String
5 | from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
  |                                            ^^^^^^^^^^^^^^^^^^^^ N811
6 |
7 | from gal_friday.dal.models.models_base import Base
  |

gal_friday/dal/models/experiment.py:73:100: E501 Line too long (112 > 99)
   |
71 |     )
72 |
73 |     # Consider relationships to experiment_assignments and experiment_outcomes if those models are also created.
   |                                                                                                    ^^^^^^^^^^^^^ E501
74 |     # assignments = relationship("ExperimentAssignment", back_populates="experiment")
75 |     # outcomes = relationship("ExperimentOutcome", back_populates="experiment")
   |

gal_friday/dal/models/experiment.py:85:9: D105 Missing docstring in magic method
   |
83 |     )
84 |
85 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
86 |         return f"<Experiment(experiment_id={self.experiment_id}, name='{self.name}', status='{self.status}')>"
   |

gal_friday/dal/models/experiment.py:86:100: E501 Line too long (110 > 99)
   |
85 |     def __repr__(self) -> str:
86 |         return f"<Experiment(experiment_id={self.experiment_id}, name='{self.name}', status='{self.status}')>"
   |                                                                                                    ^^^^^^^^^^^ E501
   |

gal_friday/dal/models/experiment_assignment.py:20:100: E501 Line too long (127 > 99)
   |
18 |         ForeignKey("experiments.experiment_id"), primary_key=True,
19 |     )
20 |     event_id: Mapped[UUID] = mapped_column(UUID(as_uuid=True), primary_key=True) # Assuming this is a generic UUID for an event
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
21 |     variant: Mapped[str] = mapped_column(String(20), nullable=False)
22 |     assigned_at: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True) # Added index
   |

gal_friday/dal/models/experiment_assignment.py:22:100: E501 Line too long (101 > 99)
   |
20 |     event_id: Mapped[UUID] = mapped_column(UUID(as_uuid=True), primary_key=True) # Assuming this is a generic UUID for an event
21 |     variant: Mapped[str] = mapped_column(String(20), nullable=False)
22 |     assigned_at: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True) # Added index
   |                                                                                                    ^^ E501
23 |
24 |     # Relationship to Experiment
   |

gal_friday/dal/models/experiment_assignment.py:25:100: E501 Line too long (102 > 99)
   |
24 |     # Relationship to Experiment
25 |     experiment = relationship("Experiment") # Add back_populates="assignments" to Experiment if needed
   |                                                                                                    ^^^ E501
26 |
27 |     __table_args__ = (
   |

gal_friday/dal/models/experiment_assignment.py:33:9: D105 Missing docstring in magic method
   |
31 |     )
32 |
33 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
34 |         return (
35 |             f"<ExperimentAssignment(experiment_id={self.experiment_id}, "
   |

gal_friday/dal/models/experiment_outcome.py:35:100: E501 Line too long (110 > 99)
   |
33 |     # If it should be, then add ForeignKey("experiment_assignments.event_id")
34 |     event_id: Mapped[UUID] = mapped_column(UUID(as_uuid=True), nullable=False)
35 |     variant: Mapped[str] = mapped_column(String(20), nullable=False, index=True) # Added index based on schema
   |                                                                                                    ^^^^^^^^^^^ E501
36 |     outcome_data: Mapped[dict] = mapped_column(JSONB, nullable=False)
37 |     correct_prediction: Mapped[bool | None] = mapped_column(Boolean, nullable=True)
   |

gal_friday/dal/models/experiment_outcome.py:40:100: E501 Line too long (101 > 99)
   |
38 |     signal_generated: Mapped[bool | None] = mapped_column(Boolean, nullable=True)
39 |     trade_return: Mapped[Decimal | None] = mapped_column(Numeric(10, 4), nullable=True)
40 |     recorded_at: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True) # Added index
   |                                                                                                    ^^ E501
41 |
42 |     # Relationship to Experiment
   |

gal_friday/dal/models/experiment_outcome.py:51:9: D105 Missing docstring in magic method
   |
49 |     )
50 |
51 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
52 |         return (
53 |             f"<ExperimentOutcome(outcome_id={self.outcome_id}, "
   |

gal_friday/dal/models/experiment_outcome.py:54:100: E501 Line too long (103 > 99)
   |
52 |         return (
53 |             f"<ExperimentOutcome(outcome_id={self.outcome_id}, "
54 |             f"experiment_id={self.experiment_id}, event_id={self.event_id}, variant='{self.variant}')>"
   |                                                                                                    ^^^^ E501
55 |         )
   |

gal_friday/dal/models/log.py:30:100: E501 Line too long (107 > 99)
   |
28 |     lineno: Mapped[int | None] = mapped_column(Integer, nullable=True)
29 |     func_name: Mapped[str | None] = mapped_column(String(255), nullable=True)
30 |     context_json: Mapped[dict | None] = mapped_column(JSONB, nullable=True) # Stored as dict, maps to JSONB
   |                                                                                                    ^^^^^^^^ E501
31 |     exception_text: Mapped[str | None] = mapped_column(Text, nullable=True)
   |

gal_friday/dal/models/log.py:33:9: D105 Missing docstring in magic method
   |
31 |     exception_text: Mapped[str | None] = mapped_column(Text, nullable=True)
32 |
33 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
34 |         return (
35 |             f"<Log(id={self.id}, timestamp='{self.timestamp}', "
   |

gal_friday/dal/models/model_deployment.py:23:100: E501 Line too long (107 > 99)
   |
21 |     # model_id is a ForeignKey to model_versions.model_id
22 |     model_id: Mapped[UUID] = mapped_column(
23 |         ForeignKey("model_versions.model_id"), nullable=True, index=True, # Schema allows NULL, added index
   |                                                                                                    ^^^^^^^^ E501
24 |     )
25 |     deployed_at: Mapped[datetime] = mapped_column(DateTime, nullable=False) # No server_default in schema
   |

gal_friday/dal/models/model_deployment.py:25:100: E501 Line too long (105 > 99)
   |
23 |         ForeignKey("model_versions.model_id"), nullable=True, index=True, # Schema allows NULL, added index
24 |     )
25 |     deployed_at: Mapped[datetime] = mapped_column(DateTime, nullable=False) # No server_default in schema
   |                                                                                                    ^^^^^^ E501
26 |     deployed_by: Mapped[str | None] = mapped_column(String(255), nullable=True)
27 |     deployment_config: Mapped[dict | None] = mapped_column(JSONB, nullable=True)
   |

gal_friday/dal/models/model_deployment.py:28:100: E501 Line too long (108 > 99)
   |
26 |     deployed_by: Mapped[str | None] = mapped_column(String(255), nullable=True)
27 |     deployment_config: Mapped[dict | None] = mapped_column(JSONB, nullable=True)
28 |     is_active: Mapped[bool | None] = mapped_column(Boolean, server_default="true", index=True) # Added index
   |                                                                                                    ^^^^^^^^^ E501
29 |
30 |     # Relationship to ModelVersion
   |

gal_friday/dal/models/model_deployment.py:38:9: D105 Missing docstring in magic method
   |
36 |     )
37 |
38 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
39 |         return (
40 |             f"<ModelDeployment(deployment_id={self.deployment_id}, model_id={self.model_id}, "
   |

gal_friday/dal/models/model_version.py:17:100: E501 Line too long (104 > 99)
   |
15 |     __tablename__ = "model_versions"
16 |
17 |     # model_id is PRIMARY KEY but not auto-generated by DB in the schema (no DEFAULT uuid_generate_v4())
   |                                                                                                    ^^^^^ E501
18 |     # It's expected to be provided by the application.
19 |     model_id: Mapped[UUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
   |

gal_friday/dal/models/model_version.py:20:100: E501 Line too long (114 > 99)
   |
18 |     # It's expected to be provided by the application.
19 |     model_id: Mapped[UUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
20 |     model_name: Mapped[str] = mapped_column(String(255), nullable=False, index=True) # Added index based on schema
   |                                                                                                    ^^^^^^^^^^^^^^^ E501
21 |     version: Mapped[str] = mapped_column(String(50), nullable=False)
22 |     created_at: Mapped[datetime] = mapped_column(DateTime, nullable=False) # No server_default in schema
   |

gal_friday/dal/models/model_version.py:22:100: E501 Line too long (104 > 99)
   |
20 |     model_name: Mapped[str] = mapped_column(String(255), nullable=False, index=True) # Added index based on schema
21 |     version: Mapped[str] = mapped_column(String(50), nullable=False)
22 |     created_at: Mapped[datetime] = mapped_column(DateTime, nullable=False) # No server_default in schema
   |                                                                                                    ^^^^^ E501
23 |     training_completed_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)
24 |     stage: Mapped[str | None] = mapped_column(String(50), server_default="development", index=True) # Added index based on schema
   |

gal_friday/dal/models/model_version.py:24:100: E501 Line too long (129 > 99)
   |
22 |     created_at: Mapped[datetime] = mapped_column(DateTime, nullable=False) # No server_default in schema
23 |     training_completed_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)
24 |     stage: Mapped[str | None] = mapped_column(String(50), server_default="development", index=True) # Added index based on schema
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
25 |     metrics: Mapped[dict | None] = mapped_column(JSONB, nullable=True)
26 |     hyperparameters: Mapped[dict | None] = mapped_column(JSONB, nullable=True)
   |

gal_friday/dal/models/model_version.py:39:9: D105 Missing docstring in magic method
   |
37 |     )
38 |
39 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
40 |         return (
41 |             f"<ModelVersion(model_id={self.model_id}, model_name='{self.model_name}', "
   |

gal_friday/dal/models/order.py:57:9: D105 Missing docstring in magic method
   |
55 |     )
56 |
57 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
58 |         return (
59 |             f"<Order(id={self.id}, trading_pair='{self.trading_pair}', "
   |

gal_friday/dal/models/position.py:22:100: E501 Line too long (115 > 99)
   |
20 |         UUID(as_uuid=True), primary_key=True, server_default=func.uuid_generate_v4(),
21 |     )
22 |     trading_pair: Mapped[str] = mapped_column(String(20), nullable=False, index=True) # Added index based on schema
   |                                                                                                    ^^^^^^^^^^^^^^^^ E501
23 |     side: Mapped[str] = mapped_column(String(10), nullable=False)
24 |     quantity: Mapped[Decimal] = mapped_column(Numeric(20, 8), nullable=False)
   |

gal_friday/dal/models/position.py:34:100: E501 Line too long (116 > 99)
   |
32 |     )
33 |     opened_at: Mapped[datetime] = mapped_column(
34 |         DateTime, nullable=False, server_default=func.current_timestamp(), index=True, # Added index based on schema
   |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
35 |     )
36 |     closed_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)
   |

gal_friday/dal/models/position.py:42:100: E501 Line too long (101 > 99)
   |
41 |     # If positions are related to orders (e.g., a position consists of multiple orders),
42 |     # a relationship could be defined here. For now, no direct FK from orders to positions in schema.
   |                                                                                                    ^^ E501
43 |     # orders = relationship("Order", back_populates="position") # Example
   |

gal_friday/dal/models/position.py:51:9: D105 Missing docstring in magic method
   |
49 |     )
50 |
51 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
52 |         return (
53 |             f"<Position(id={self.id}, trading_pair='{self.trading_pair}', "
   |

gal_friday/dal/models/position_adjustment.py:23:100: E501 Line too long (174 > 99)
   |
21 | …
22 | …iation_id
23 | …01 allows NULL, 003 implies NOT NULL via REFERENCES. Assuming 001 version for FK nullability for now.
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
24 | …rue, index=True, # Added index
25 | …
   |

gal_friday/dal/models/position_adjustment.py:24:100: E501 Line too long (103 > 99)
   |
22 |     # reconciliation_id is a ForeignKey to reconciliation_events.reconciliation_id
23 |     reconciliation_id: Mapped[UUID | None] = mapped_column( # Schema in 001 allows NULL, 003 implies NOT NULL via REFERENCES. Assuming…
24 |         ForeignKey("reconciliation_events.reconciliation_id"), nullable=True, index=True, # Added index
   |                                                                                                    ^^^^ E501
25 |     )
26 |     trading_pair: Mapped[str] = mapped_column(String(20), nullable=False) # From 003, added index
   |

gal_friday/dal/models/position_adjustment.py:44:9: D105 Missing docstring in magic method
   |
42 |     )
43 |
44 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
45 |         return (
46 |             f"<PositionAdjustment(adjustment_id={self.adjustment_id}, "
   |

gal_friday/dal/models/reconciliation_event.py:19:100: E501 Line too long (113 > 99)
   |
17 |     __tablename__ = "reconciliation_events"
18 |
19 |     # reconciliation_id is PRIMARY KEY but not auto-generated by DB in the schema (no DEFAULT uuid_generate_v4())
   |                                                                                                    ^^^^^^^^^^^^^^ E501
20 |     # It's expected to be provided by the application.
21 |     reconciliation_id: Mapped[UUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
   |

gal_friday/dal/models/reconciliation_event.py:22:100: E501 Line too long (115 > 99)
   |
20 |     # It's expected to be provided by the application.
21 |     reconciliation_id: Mapped[UUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
22 |     timestamp: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True) # Added index based on schema
   |                                                                                                    ^^^^^^^^^^^^^^^^ E501
23 |     reconciliation_type: Mapped[str] = mapped_column(String(50), nullable=False) # From 003
24 |     status: Mapped[str] = mapped_column(String(50), nullable=False, index=True) # From 003, added index
   |

gal_friday/dal/models/reconciliation_event.py:24:100: E501 Line too long (103 > 99)
   |
22 |     timestamp: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True) # Added index based on schema
23 |     reconciliation_type: Mapped[str] = mapped_column(String(50), nullable=False) # From 003
24 |     status: Mapped[str] = mapped_column(String(50), nullable=False, index=True) # From 003, added index
   |                                                                                                    ^^^^ E501
25 |     discrepancies_found: Mapped[int | None] = mapped_column(Integer, server_default="0")
26 |     auto_corrected: Mapped[int | None] = mapped_column(Integer, server_default="0")
   |

gal_friday/dal/models/reconciliation_event.py:29:100: E501 Line too long (112 > 99)
   |
27 |     manual_review_required: Mapped[int | None] = mapped_column(Integer, server_default="0")
28 |     report: Mapped[dict] = mapped_column(JSONB, nullable=False) # From 003
29 |     duration_seconds: Mapped[Decimal | None] = mapped_column(Numeric(10, 3), nullable=True) # Precision from 003
   |                                                                                                    ^^^^^^^^^^^^^ E501
30 |     created_at: Mapped[datetime | None] = mapped_column(
31 |         DateTime, server_default=func.current_timestamp(),
   |

gal_friday/dal/models/reconciliation_event.py:42:9: D105 Missing docstring in magic method
   |
40 |     )
41 |
42 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
43 |         return (
44 |             f"<ReconciliationEvent(reconciliation_id={self.reconciliation_id}, "
   |

gal_friday/dal/models/retraining_job.py:59:100: E501 Line too long (101 > 99)
   |
58 |     __table_args__ = (
59 |         Index("idx_retraining_model", "model_id"), # Already covered by ForeignKey index for model_id
   |                                                                                                    ^^ E501
60 |         Index("idx_retraining_status", "status"),
61 |         Index("idx_retraining_created", "created_at"),
   |

gal_friday/dal/models/retraining_job.py:64:9: D105 Missing docstring in magic method
   |
62 |     )
63 |
64 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
65 |         return f"<RetrainingJob(job_id={self.job_id}, model_name='{self.model_name}', status='{self.status}')>"
   |

gal_friday/dal/models/retraining_job.py:65:100: E501 Line too long (111 > 99)
   |
64 |     def __repr__(self) -> str:
65 |         return f"<RetrainingJob(job_id={self.job_id}, model_name='{self.model_name}', status='{self.status}')>"
   |                                                                                                    ^^^^^^^^^^^^ E501
   |

gal_friday/dal/models/trade_signal.py:29:100: E501 Line too long (109 > 99)
   |
27 |     take_profit: Mapped[Decimal | None] = mapped_column(Numeric(20, 8), nullable=True)
28 |     confidence: Mapped[Decimal | None] = mapped_column(Numeric(5, 4), nullable=True)
29 |     status: Mapped[str] = mapped_column(String(20), nullable=False, index=True) # Added index based on schema
   |                                                                                                    ^^^^^^^^^^ E501
30 |     created_at: Mapped[datetime] = mapped_column(
31 |         DateTime, nullable=False, server_default=func.current_timestamp(), index=True, # Added index based on schema
   |

gal_friday/dal/models/trade_signal.py:31:100: E501 Line too long (116 > 99)
   |
29 |     status: Mapped[str] = mapped_column(String(20), nullable=False, index=True) # Added index based on schema
30 |     created_at: Mapped[datetime] = mapped_column(
31 |         DateTime, nullable=False, server_default=func.current_timestamp(), index=True, # Added index based on schema
   |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
32 |     )
33 |     executed_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)
   |

gal_friday/dal/models/trade_signal.py:43:9: D105 Missing docstring in magic method
   |
41 |     )
42 |
43 |     def __repr__(self) -> str:
   |         ^^^^^^^^ D105
44 |         return (
45 |             f"<TradeSignal(id={self.id}, trading_pair='{self.trading_pair}', "
   |

gal_friday/dal/repositories/experiment_repository.py:54:100: E501 Line too long (127 > 99)
   |
52 |                     dt_obj = dt_obj.replace(tzinfo=UTC)
53 |                 experiment_data[key] = dt_obj
54 |             elif key in experiment_data and isinstance(experiment_data[key], datetime) and experiment_data[key].tzinfo is None:
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
55 |                  experiment_data[key] = experiment_data[key].replace(tzinfo=UTC)
   |

gal_friday/dal/repositories/experiment_repository.py:60:100: E501 Line too long (105 > 99)
   |
58 |         # Prepare values for insert/update
59 |         # SQLAlchemy's pg_insert handles type conversions for basic types
60 |         # For complex types like enums previously, ensure they are passed as their DB value (e.g. string)
   |                                                                                                    ^^^^^^ E501
61 |         # allocation_strategy.value -> allocation_strategy (if it's a string in DB)
62 |         # traffic_split, confidence_level, min_detectable_effect, max_loss_threshold to Decimal if not already
   |

gal_friday/dal/repositories/experiment_repository.py:62:100: E501 Line too long (110 > 99)
   |
60 |         # For complex types like enums previously, ensure they are passed as their DB value (e.g. string)
61 |         # allocation_strategy.value -> allocation_strategy (if it's a string in DB)
62 |         # traffic_split, confidence_level, min_detectable_effect, max_loss_threshold to Decimal if not already
   |                                                                                                    ^^^^^^^^^^^ E501
63 |
64 |         async with self.session_maker() as session:
   |

gal_friday/dal/repositories/experiment_repository.py:70:100: E501 Line too long (103 > 99)
   |
68 |             # if the PK is set. Or using pg_insert for full ON CONFLICT control.
69 |
70 |             # For simplicity, let's use get then update/create. A true upsert is more complex with ORM.
   |                                                                                                    ^^^^ E501
71 |             existing_exp = await session.get(Experiment, experiment_data["experiment_id"])
72 |             if existing_exp:
   |

gal_friday/dal/repositories/experiment_repository.py:77:100: E501 Line too long (127 > 99)
   |
75 |                     if hasattr(existing_exp, key):
76 |                         setattr(existing_exp, key, value)
77 |                 if hasattr(existing_exp, "updated_at") and "updated_at" not in experiment_data : # Assuming an updated_at field
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
78 |                     existing_exp.updated_at = datetime.now(UTC)
79 |                 session.add(existing_exp)
   |

gal_friday/dal/repositories/experiment_repository.py:103:45: E711 Comparison to `None` should be `cond is None`
    |
101 |                 .where(
102 |                     Experiment.status.in_(["created", "running"]),
103 |                     (Experiment.end_time == None) | (Experiment.end_time > datetime.now(UTC)),
    |                                             ^^^^ E711
104 |                 )
105 |                 .order_by(Experiment.start_time.desc())
    |
    = help: Replace with `cond is None`

gal_friday/dal/repositories/experiment_repository.py:121:100: E501 Line too long (108 > 99)
    |
119 |         if isinstance(assignment_data.get("assigned_at"), str):
120 |             dt_obj = datetime.fromisoformat(assignment_data["assigned_at"])
121 |             assignment_data["assigned_at"] = dt_obj.replace(tzinfo=UTC) if dt_obj.tzinfo is None else dt_obj
    |                                                                                                    ^^^^^^^^^ E501
122 |         elif isinstance(assignment_data.get("assigned_at"), datetime) and assignment_data["assigned_at"].tzinfo is None:
123 |             assignment_data["assigned_at"] = assignment_data["assigned_at"].replace(tzinfo=UTC)
    |

gal_friday/dal/repositories/experiment_repository.py:122:100: E501 Line too long (120 > 99)
    |
120 |             dt_obj = datetime.fromisoformat(assignment_data["assigned_at"])
121 |             assignment_data["assigned_at"] = dt_obj.replace(tzinfo=UTC) if dt_obj.tzinfo is None else dt_obj
122 |         elif isinstance(assignment_data.get("assigned_at"), datetime) and assignment_data["assigned_at"].tzinfo is None:
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^ E501
123 |             assignment_data["assigned_at"] = assignment_data["assigned_at"].replace(tzinfo=UTC)
    |

gal_friday/dal/repositories/experiment_repository.py:133:100: E501 Line too long (110 > 99)
    |
131 |             await session.execute(stmt)
132 |             await session.commit()
133 |             # To return the assignment (even if it already existed and did nothing), we'd need a select after.
    |                                                                                                    ^^^^^^^^^^^ E501
134 |             # For now, let's just return the input or fetch it.
135 |             # A simple way if insert happened is to return the object, but ON CONFLICT DO NOTHING makes it tricky.
    |

gal_friday/dal/repositories/experiment_repository.py:135:100: E501 Line too long (114 > 99)
    |
133 |             # To return the assignment (even if it already existed and did nothing), we'd need a select after.
134 |             # For now, let's just return the input or fetch it.
135 |             # A simple way if insert happened is to return the object, but ON CONFLICT DO NOTHING makes it tricky.
    |                                                                                                    ^^^^^^^^^^^^^^^ E501
136 |             # Let's try to fetch it:
137 |             return await session.get(ExperimentAssignment, (assignment_data["experiment_id"], assignment_data["event_id"]))
    |

gal_friday/dal/repositories/experiment_repository.py:137:100: E501 Line too long (123 > 99)
    |
135 |             # A simple way if insert happened is to return the object, but ON CONFLICT DO NOTHING makes it tricky.
136 |             # Let's try to fetch it:
137 |             return await session.get(ExperimentAssignment, (assignment_data["experiment_id"], assignment_data["event_id"]))
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
    |

gal_friday/dal/repositories/experiment_repository.py:155:100: E501 Line too long (106 > 99)
    |
153 |         if isinstance(outcome_data.get("recorded_at"), str):
154 |              dt_obj = datetime.fromisoformat(outcome_data["recorded_at"])
155 |              outcome_data["recorded_at"] = dt_obj.replace(tzinfo=UTC) if dt_obj.tzinfo is None else dt_obj
    |                                                                                                    ^^^^^^^ E501
156 |         elif isinstance(outcome_data.get("recorded_at"), datetime) and outcome_data["recorded_at"].tzinfo is None:
157 |             outcome_data["recorded_at"] = outcome_data["recorded_at"].replace(tzinfo=UTC)
    |

gal_friday/dal/repositories/experiment_repository.py:156:100: E501 Line too long (114 > 99)
    |
154 |              dt_obj = datetime.fromisoformat(outcome_data["recorded_at"])
155 |              outcome_data["recorded_at"] = dt_obj.replace(tzinfo=UTC) if dt_obj.tzinfo is None else dt_obj
156 |         elif isinstance(outcome_data.get("recorded_at"), datetime) and outcome_data["recorded_at"].tzinfo is None:
    |                                                                                                    ^^^^^^^^^^^^^^^ E501
157 |             outcome_data["recorded_at"] = outcome_data["recorded_at"].replace(tzinfo=UTC)
    |

gal_friday/dal/repositories/experiment_repository.py:161:100: E501 Line too long (100 > 99)
    |
160 |         # trade_return should be Decimal
161 |         if "trade_return" in outcome_data and not isinstance(outcome_data["trade_return"], Decimal):
    |                                                                                                    ^ E501
162 |             outcome_data["trade_return"] = Decimal(str(outcome_data["trade_return"]))
    |

gal_friday/dal/repositories/experiment_repository.py:179:100: E501 Line too long (107 > 99)
    |
177 |                 ExperimentOutcome.variant,
178 |                 func.count().label("sample_count"),
179 |                 func.sum(cast(ExperimentOutcome.correct_prediction, Integer)).label("correct_predictions"),
    |                                                                                                    ^^^^^^^^ E501
180 |                 func.sum(cast(ExperimentOutcome.signal_generated, Integer)).label("signals_generated"),
181 |                 func.sum(ExperimentOutcome.trade_return).label("total_return"),
    |

gal_friday/dal/repositories/experiment_repository.py:180:100: E501 Line too long (103 > 99)
    |
178 |                 func.count().label("sample_count"),
179 |                 func.sum(cast(ExperimentOutcome.correct_prediction, Integer)).label("correct_predictions"),
180 |                 func.sum(cast(ExperimentOutcome.signal_generated, Integer)).label("signals_generated"),
    |                                                                                                    ^^^^ E501
181 |                 func.sum(ExperimentOutcome.trade_return).label("total_return"),
182 |                 func.avg(cast(ExperimentOutcome.correct_prediction, Numeric)).label("accuracy"),
    |

gal_friday/dal/repositories/experiment_repository.py:200:100: E501 Line too long (110 > 99)
    |
198 |         return performance_summary
199 |
200 |     async def save_results(self, experiment_id: uuid.UUID, results_data: dict[str, Any]) -> Experiment | None:
    |                                                                                                    ^^^^^^^^^^^ E501
201 |         """Save final experiment results by updating the Experiment model."""
202 |         # Ensure 'completed_at' is a datetime object if provided, otherwise set to now
    |

gal_friday/dal/repositories/experiment_repository.py:207:100: E501 Line too long (107 > 99)
    |
205 |         elif isinstance(results_data["completed_at"], str):
206 |              dt_obj = datetime.fromisoformat(results_data["completed_at"])
207 |              results_data["completed_at"] = dt_obj.replace(tzinfo=UTC) if dt_obj.tzinfo is None else dt_obj
    |                                                                                                    ^^^^^^^^ E501
208 |         elif isinstance(results_data["completed_at"], datetime) and results_data["completed_at"].tzinfo is None:
209 |             results_data["completed_at"] = results_data["completed_at"].replace(tzinfo=UTC)
    |

gal_friday/dal/repositories/experiment_repository.py:208:100: E501 Line too long (112 > 99)
    |
206 |              dt_obj = datetime.fromisoformat(results_data["completed_at"])
207 |              results_data["completed_at"] = dt_obj.replace(tzinfo=UTC) if dt_obj.tzinfo is None else dt_obj
208 |         elif isinstance(results_data["completed_at"], datetime) and results_data["completed_at"].tzinfo is None:
    |                                                                                                    ^^^^^^^^^^^^^ E501
209 |             results_data["completed_at"] = results_data["completed_at"].replace(tzinfo=UTC)
    |

gal_friday/dal/repositories/experiment_repository.py:242:100: E501 Line too long (103 > 99)
    |
240 |                 exp = row[0] # The Experiment object
241 |                 total_assignments = row[1] or 0 # Value from subquery
242 |                 exp_dict = {column.name: getattr(exp, column.name) for column in exp.__table__.columns}
    |                                                                                                    ^^^^ E501
243 |                 exp_dict["total_assignments"] = total_assignments
244 |                 history.append(exp_dict)
    |

gal_friday/dal/repositories/model_repository.py:39:9: D205 1 blank line required between summary line and description
   |
38 |       async def add_model_version(self, model_version_data: dict[str, Any]) -> ModelVersion:
39 | /         """Adds a new model version.
40 | |         Expects model_version_data to have all necessary fields for ModelVersion.
41 | |         'model_id' should be a UUID object if provided, or will be generated if not present and model expects it.
42 | |         """
   | |___________^ D205
43 |           if "model_id" not in model_version_data: # Ensure model_id is present if not auto-generated by DB
44 |                model_version_data["model_id"] = model_version_data.get("model_id", uuid.uuid4())
   |
   = help: Insert single blank line

gal_friday/dal/repositories/model_repository.py:41:100: E501 Line too long (113 > 99)
   |
39 |         """Adds a new model version.
40 |         Expects model_version_data to have all necessary fields for ModelVersion.
41 |         'model_id' should be a UUID object if provided, or will be generated if not present and model expects it.
   |                                                                                                    ^^^^^^^^^^^^^^ E501
42 |         """
43 |         if "model_id" not in model_version_data: # Ensure model_id is present if not auto-generated by DB
   |

gal_friday/dal/repositories/model_repository.py:43:100: E501 Line too long (105 > 99)
   |
41 |         'model_id' should be a UUID object if provided, or will be generated if not present and model expects it.
42 |         """
43 |         if "model_id" not in model_version_data: # Ensure model_id is present if not auto-generated by DB
   |                                                                                                    ^^^^^^ E501
44 |              model_version_data["model_id"] = model_version_data.get("model_id", uuid.uuid4())
45 |         # Ensure datetime objects are timezone-aware if needed by DB schema or comparisons
   |

gal_friday/dal/repositories/model_repository.py:46:9: SIM102 Use a single `if` statement instead of nested `if` statements
   |
44 |                model_version_data["model_id"] = model_version_data.get("model_id", uuid.uuid4())
45 |           # Ensure datetime objects are timezone-aware if needed by DB schema or comparisons
46 | /         if "created_at" in model_version_data and isinstance(model_version_data["created_at"], datetime):
47 | |             if model_version_data["created_at"].tzinfo is None:
   | |_______________________________________________________________^ SIM102
48 |                    model_version_data["created_at"] = model_version_data["created_at"].replace(tzinfo=UTC)
49 |           if "training_completed_at" in model_version_data and isinstance(model_version_data["training_completed_at"], datetime):
   |
   = help: Combine `if` statements using `and`

gal_friday/dal/repositories/model_repository.py:46:100: E501 Line too long (105 > 99)
   |
44 |              model_version_data["model_id"] = model_version_data.get("model_id", uuid.uuid4())
45 |         # Ensure datetime objects are timezone-aware if needed by DB schema or comparisons
46 |         if "created_at" in model_version_data and isinstance(model_version_data["created_at"], datetime):
   |                                                                                                    ^^^^^^ E501
47 |             if model_version_data["created_at"].tzinfo is None:
48 |                  model_version_data["created_at"] = model_version_data["created_at"].replace(tzinfo=UTC)
   |

gal_friday/dal/repositories/model_repository.py:48:100: E501 Line too long (104 > 99)
   |
46 |         if "created_at" in model_version_data and isinstance(model_version_data["created_at"], datetime):
47 |             if model_version_data["created_at"].tzinfo is None:
48 |                  model_version_data["created_at"] = model_version_data["created_at"].replace(tzinfo=UTC)
   |                                                                                                    ^^^^^ E501
49 |         if "training_completed_at" in model_version_data and isinstance(model_version_data["training_completed_at"], datetime):
50 |             if model_version_data["training_completed_at"].tzinfo is None:
   |

gal_friday/dal/repositories/model_repository.py:49:9: SIM102 Use a single `if` statement instead of nested `if` statements
   |
47 |               if model_version_data["created_at"].tzinfo is None:
48 |                    model_version_data["created_at"] = model_version_data["created_at"].replace(tzinfo=UTC)
49 | /         if "training_completed_at" in model_version_data and isinstance(model_version_data["training_completed_at"], datetime):
50 | |             if model_version_data["training_completed_at"].tzinfo is None:
   | |__________________________________________________________________________^ SIM102
51 |                    model_version_data["training_completed_at"] = model_version_data["training_completed_at"].replace(tzinfo=UTC)
   |
   = help: Combine `if` statements using `and`

gal_friday/dal/repositories/model_repository.py:49:100: E501 Line too long (127 > 99)
   |
47 |             if model_version_data["created_at"].tzinfo is None:
48 |                  model_version_data["created_at"] = model_version_data["created_at"].replace(tzinfo=UTC)
49 |         if "training_completed_at" in model_version_data and isinstance(model_version_data["training_completed_at"], datetime):
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
50 |             if model_version_data["training_completed_at"].tzinfo is None:
51 |                  model_version_data["training_completed_at"] = model_version_data["training_completed_at"].replace(tzinfo=UTC)
   |

gal_friday/dal/repositories/model_repository.py:51:100: E501 Line too long (126 > 99)
   |
49 |         if "training_completed_at" in model_version_data and isinstance(model_version_data["training_completed_at"], datetime):
50 |             if model_version_data["training_completed_at"].tzinfo is None:
51 |                  model_version_data["training_completed_at"] = model_version_data["training_completed_at"].replace(tzinfo=UTC)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
52 |
53 |         return await self.create(model_version_data)
   |

gal_friday/dal/repositories/model_repository.py:93:100: E501 Line too long (100 > 99)
   |
91 |         if stage:
92 |             filters["stage"] = stage
93 |         return await self.find_all(filters=filters if filters else None, order_by="created_at DESC")
   |                                                                                                    ^ E501
   |

gal_friday/dal/repositories/model_repository.py:97:100: E501 Line too long (109 > 99)
   |
96 |     async def update_model_version_stage(
97 |         self, model_id: uuid.UUID, new_stage: str, deployed_by: str | None = None, # Assuming stage is string
   |                                                                                                    ^^^^^^^^^^ E501
98 |     ) -> ModelVersion | None:
99 |         """Update model version's stage. If promoting to 'production', creates a deployment record."""
   |

gal_friday/dal/repositories/model_repository.py:99:100: E501 Line too long (102 > 99)
    |
 97 |         self, model_id: uuid.UUID, new_stage: str, deployed_by: str | None = None, # Assuming stage is string
 98 |     ) -> ModelVersion | None:
 99 |         """Update model version's stage. If promoting to 'production', creates a deployment record."""
    |                                                                                                    ^^^ E501
100 |         # deployed_by is optional, only used if new_stage is production-like
101 |         updated_model = await self.update(model_id, {"stage": new_stage})
    |

gal_friday/dal/repositories/model_repository.py:115:100: E501 Line too long (108 > 99)
    |
113 |         self, model_version: ModelVersion, deployed_by: str, deployment_config: dict | None = None,
114 |     ) -> ModelDeployment:
115 |         """Internal helper to create a deployment record and deactivate old ones for the same model name."""
    |                                                                                                    ^^^^^^^^^ E501
116 |         async with self.session_maker() as session:
117 |             # Deactivate previous active deployments for this model_name
    |

gal_friday/dal/repositories/model_repository.py:124:100: E501 Line too long (113 > 99)
    |
122 |                 .where(
123 |                     ModelDeployment.model_id.in_(
124 |                         select(ModelVersion.model_id).where(ModelVersion.model_name == model_version.model_name),
    |                                                                                                    ^^^^^^^^^^^^^^ E501
125 |                     ),
126 |                     ModelDeployment.is_active == True,
    |

gal_friday/dal/repositories/model_repository.py:126:21: E712 Avoid equality comparisons to `True`; use `if ModelDeployment.is_active:` for truth checks
    |
124 |                         select(ModelVersion.model_id).where(ModelVersion.model_name == model_version.model_name),
125 |                     ),
126 |                     ModelDeployment.is_active == True,
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E712
127 |                     ModelDeployment.model_id != model_version.model_id, # Don't deactivate if re-deploying same version
128 |                 )
    |
    = help: Replace with `ModelDeployment.is_active`

gal_friday/dal/repositories/model_repository.py:127:100: E501 Line too long (119 > 99)
    |
125 |                     ),
126 |                     ModelDeployment.is_active == True,
127 |                     ModelDeployment.model_id != model_version.model_id, # Don't deactivate if re-deploying same version
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
128 |                 )
129 |                 .values(is_active=False)
    |

gal_friday/dal/repositories/model_repository.py:157:63: E712 Avoid equality comparisons to `True`; use `if ModelDeployment.is_active:` for truth checks
    |
155 |                 select(ModelDeployment)
156 |                 .join(ModelVersion, ModelDeployment.model_id == ModelVersion.model_id)
157 |                 .where(ModelVersion.model_name == model_name, ModelDeployment.is_active == True)
    |                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E712
158 |                 .order_by(ModelDeployment.deployed_at.desc())
159 |                 .limit(1)
    |
    = help: Replace with `ModelDeployment.is_active`

gal_friday/dal/repositories/model_repository.py:164:100: E501 Line too long (120 > 99)
    |
162 |             deployment = result.scalar_one_or_none()
163 |             if deployment:
164 |                  self.logger.debug(f"Found active deployment for model {model_name}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^ E501
165 |             else:
166 |                  self.logger.debug(f"No active deployment found for model {model_name}", source_module=self._source_module)
    |

gal_friday/dal/repositories/model_repository.py:166:100: E501 Line too long (123 > 99)
    |
164 |                  self.logger.debug(f"Found active deployment for model {model_name}", source_module=self._source_module)
165 |             else:
166 |                  self.logger.debug(f"No active deployment found for model {model_name}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
167 |             return deployment
    |

gal_friday/dal/repositories/model_repository.py:169:100: E501 Line too long (104 > 99)
    |
167 |             return deployment
168 |
169 |     async def get_deployments_for_model_version(self, model_id: uuid.UUID) -> Sequence[ModelDeployment]:
    |                                                                                                    ^^^^^ E501
170 |         """Get all deployment records for a specific model version ID."""
171 |         # This uses a direct query on ModelDeployment, could also be BaseRepository[ModelDeployment].find_all
    |

gal_friday/dal/repositories/model_repository.py:171:100: E501 Line too long (109 > 99)
    |
169 |     async def get_deployments_for_model_version(self, model_id: uuid.UUID) -> Sequence[ModelDeployment]:
170 |         """Get all deployment records for a specific model version ID."""
171 |         # This uses a direct query on ModelDeployment, could also be BaseRepository[ModelDeployment].find_all
    |                                                                                                    ^^^^^^^^^^ E501
172 |         async with self.session_maker() as session:
173 |             stmt = select(ModelDeployment).where(ModelDeployment.model_id == model_id).order_by(ModelDeployment.deployed_at.desc())
    |

gal_friday/dal/repositories/model_repository.py:173:100: E501 Line too long (131 > 99)
    |
171 |         # This uses a direct query on ModelDeployment, could also be BaseRepository[ModelDeployment].find_all
172 |         async with self.session_maker() as session:
173 |             stmt = select(ModelDeployment).where(ModelDeployment.model_id == model_id).order_by(ModelDeployment.deployed_at.desc())
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
174 |             result = await session.execute(stmt)
175 |             deployments = result.scalars().all()
    |

gal_friday/dal/repositories/model_repository.py:176:100: E501 Line too long (129 > 99)
    |
174 |             result = await session.execute(stmt)
175 |             deployments = result.scalars().all()
176 |             self.logger.debug(f"Found {len(deployments)} deployments for model_id {model_id}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
177 |             return deployments
    |

gal_friday/dal/repositories/position_repository.py:76:52: E712 Avoid equality comparisons to `True`; use `if Position.is_active:` for truth checks
   |
74 |             async with self.session_maker() as session:
75 |                 stmt = select(
76 |                     func.count(Position.id).filter(Position.is_active == True).label("active_positions"),
   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ E712
77 |                     func.count(Position.id).filter(Position.is_active == False).label("closed_positions"),
78 |                     func.sum(cast(Position.realized_pnl, Numeric)).label("total_realized_pnl"),
   |
   = help: Replace with `Position.is_active`

gal_friday/dal/repositories/position_repository.py:76:100: E501 Line too long (105 > 99)
   |
74 |             async with self.session_maker() as session:
75 |                 stmt = select(
76 |                     func.count(Position.id).filter(Position.is_active == True).label("active_positions"),
   |                                                                                                    ^^^^^^ E501
77 |                     func.count(Position.id).filter(Position.is_active == False).label("closed_positions"),
78 |                     func.sum(cast(Position.realized_pnl, Numeric)).label("total_realized_pnl"),
   |

gal_friday/dal/repositories/position_repository.py:77:52: E712 Avoid equality comparisons to `False`; use `if not Position.is_active:` for false checks
   |
75 |                 stmt = select(
76 |                     func.count(Position.id).filter(Position.is_active == True).label("active_positions"),
77 |                     func.count(Position.id).filter(Position.is_active == False).label("closed_positions"),
   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E712
78 |                     func.sum(cast(Position.realized_pnl, Numeric)).label("total_realized_pnl"),
79 |                     func.sum(cast(Position.unrealized_pnl, Numeric)).filter(Position.is_active == True).label("total_unrealized_pnl"),
   |
   = help: Replace with `not Position.is_active`

gal_friday/dal/repositories/position_repository.py:77:100: E501 Line too long (106 > 99)
   |
75 |                 stmt = select(
76 |                     func.count(Position.id).filter(Position.is_active == True).label("active_positions"),
77 |                     func.count(Position.id).filter(Position.is_active == False).label("closed_positions"),
   |                                                                                                    ^^^^^^^ E501
78 |                     func.sum(cast(Position.realized_pnl, Numeric)).label("total_realized_pnl"),
79 |                     func.sum(cast(Position.unrealized_pnl, Numeric)).filter(Position.is_active == True).label("total_unrealized_pnl"),
   |

gal_friday/dal/repositories/position_repository.py:79:77: E712 Avoid equality comparisons to `True`; use `if Position.is_active:` for truth checks
   |
77 |                     func.count(Position.id).filter(Position.is_active == False).label("closed_positions"),
78 |                     func.sum(cast(Position.realized_pnl, Numeric)).label("total_realized_pnl"),
79 |                     func.sum(cast(Position.unrealized_pnl, Numeric)).filter(Position.is_active == True).label("total_unrealized_pnl"),
   |                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ E712
80 |                 )
81 |                 result = await session.execute(stmt)
   |
   = help: Replace with `Position.is_active`

gal_friday/dal/repositories/position_repository.py:79:100: E501 Line too long (134 > 99)
   |
77 |                     func.count(Position.id).filter(Position.is_active == False).label("closed_positions"),
78 |                     func.sum(cast(Position.realized_pnl, Numeric)).label("total_realized_pnl"),
79 |                     func.sum(cast(Position.unrealized_pnl, Numeric)).filter(Position.is_active == True).label("total_unrealized_pnl"),
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
80 |                 )
81 |                 result = await session.execute(stmt)
   |

gal_friday/dal/repositories/position_repository.py:82:100: E501 Line too long (102 > 99)
   |
80 |                 )
81 |                 result = await session.execute(stmt)
82 |                 summary = result.one_or_none() # Using one_or_none() as SUM can return None if no rows
   |                                                                                                    ^^^ E501
83 |
84 |                 if summary:
   |

gal_friday/dal/repositories/position_repository.py:85:100: E501 Line too long (103 > 99)
   |
84 |                 if summary:
85 |                     self.logger.debug("Retrieved position summary.", source_module=self._source_module)
   |                                                                                                    ^^^^ E501
86 |                     # Convert Row to dict, handling None for sums if necessary
87 |                     return {
   |

gal_friday/dal/repositories/position_repository.py:93:100: E501 Line too long (102 > 99)
   |
91 |                         "total_unrealized_pnl": summary.total_unrealized_pnl or Decimal("0"),
92 |                     }
93 |                 # Should not happen with COUNT/SUM over a table unless it's empty and SUM returns NULL
   |                                                                                                    ^^^ E501
94 |                 self.logger.warning("Position summary query returned no rows.", source_module=self._source_module)
95 |                 return {
   |

gal_friday/dal/repositories/position_repository.py:94:100: E501 Line too long (114 > 99)
   |
92 |                     }
93 |                 # Should not happen with COUNT/SUM over a table unless it's empty and SUM returns NULL
94 |                 self.logger.warning("Position summary query returned no rows.", source_module=self._source_module)
   |                                                                                                    ^^^^^^^^^^^^^^^ E501
95 |                 return {
96 |                     "active_positions": 0,
   |

gal_friday/dal/repositories/reconciliation_repository.py:15:100: E501 Line too long (129 > 99)
   |
13 | from gal_friday.dal.models.reconciliation_event import ReconciliationEvent
14 |
15 | # ReconciliationReport and ReconciliationStatus would now likely be service-layer or domain models, not directly handled by repo.
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
   |

gal_friday/dal/repositories/reconciliation_repository.py:39:9: D205 1 blank line required between summary line and description
   |
37 |           self, event_data: dict[str, Any],
38 |       ) -> ReconciliationEvent:
39 | /         """Saves a reconciliation event.
40 | |         `event_data` should contain fields for ReconciliationEvent model.
41 | |         Example: reconciliation_id (UUID), timestamp (datetime), reconciliation_type (str),
42 | |                  status (str), discrepancies_found (int), auto_corrected (int),
43 | |                  manual_review_required (int), report (dict), duration_seconds (Decimal).
44 | |         """
   | |___________^ D205
45 |           if "reconciliation_id" not in event_data: # Ensure ID is present if not auto-gen by DB
46 |               event_data["reconciliation_id"] = event_data.get("reconciliation_id", uuid.uuid4())
   |
   = help: Insert single blank line

gal_friday/dal/repositories/reconciliation_repository.py:47:9: SIM102 Use a single `if` statement instead of nested `if` statements
   |
45 |           if "reconciliation_id" not in event_data: # Ensure ID is present if not auto-gen by DB
46 |               event_data["reconciliation_id"] = event_data.get("reconciliation_id", uuid.uuid4())
47 | /         if "timestamp" in event_data and isinstance(event_data["timestamp"], datetime):
48 | |             if event_data["timestamp"].tzinfo is None:
   | |______________________________________________________^ SIM102
49 |                    event_data["timestamp"] = event_data["timestamp"].replace(tzinfo=UTC)
   |
   = help: Combine `if` statements using `and`

gal_friday/dal/repositories/reconciliation_repository.py:65:9: F841 Local variable `filters` is assigned to but never used
   |
63 |         cutoff_date = datetime.now(UTC) - timedelta(days=days)
64 |
65 |         filters: dict[str, Any] = {} # Added type hint
   |         ^^^^^^^ F841
66 |         # Assuming ReconciliationEvent model has a 'timestamp' field
67 |         # This requires a custom query as BaseRepository.find_all doesn't support date range directly.
   |
   = help: Remove assignment to unused variable `filters`

gal_friday/dal/repositories/reconciliation_repository.py:67:100: E501 Line too long (102 > 99)
   |
65 |         filters: dict[str, Any] = {} # Added type hint
66 |         # Assuming ReconciliationEvent model has a 'timestamp' field
67 |         # This requires a custom query as BaseRepository.find_all doesn't support date range directly.
   |                                                                                                    ^^^ E501
68 |         # However, if we only filter by status, find_all could be used. For now, custom:
   |

gal_friday/dal/repositories/reconciliation_repository.py:78:100: E501 Line too long (133 > 99)
   |
76 |             result = await session.execute(stmt)
77 |             events = result.scalars().all()
78 |             self.logger.debug(f"Found {len(events)} reconciliation events from last {days} days.", source_module=self._source_module)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
79 |             return events
   |

gal_friday/dal/repositories/reconciliation_repository.py:84:9: D205 1 blank line required between summary line and description
   |
82 |           self, adjustment_data: dict[str, Any],
83 |       ) -> PositionAdjustment:
84 | /         """Saves a position adjustment.
85 | |         `adjustment_data` should contain fields for PositionAdjustment model.
86 | |         Example: reconciliation_id (UUID), trading_pair (str), adjustment_type (str),
87 | |                  old_value (Decimal), new_value (Decimal), reason (str).
88 | |         """
   | |___________^ D205
89 |           # PositionAdjustment has an auto-generating adjustment_id by default in its model
90 |           # Ensure reconciliation_id (FK) is provided
   |
   = help: Insert single blank line

gal_friday/dal/repositories/reconciliation_repository.py:92:100: E501 Line too long (125 > 99)
   |
90 |         # Ensure reconciliation_id (FK) is provided
91 |         if "reconciliation_id" not in adjustment_data:
92 |             self.logger.error("Cannot save PositionAdjustment without reconciliation_id.", source_module=self._source_module)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
93 |             raise ValueError("reconciliation_id is required to save a PositionAdjustment.")
   |

gal_friday/dal/repositories/reconciliation_repository.py:95:100: E501 Line too long (102 > 99)
   |
93 |             raise ValueError("reconciliation_id is required to save a PositionAdjustment.")
94 |
95 |         # Create PositionAdjustment instance (assuming session is managed by caller or another method)
   |                                                                                                    ^^^ E501
96 |         # For direct save, we'd need a session here. Let's assume it's created and committed like self.create
97 |         async with self.session_maker() as session:
   |

gal_friday/dal/repositories/reconciliation_repository.py:96:100: E501 Line too long (109 > 99)
   |
95 |         # Create PositionAdjustment instance (assuming session is managed by caller or another method)
96 |         # For direct save, we'd need a session here. Let's assume it's created and committed like self.create
   |                                                                                                    ^^^^^^^^^^ E501
97 |         async with self.session_maker() as session:
98 |             instance = PositionAdjustment(**adjustment_data)
   |

gal_friday/dal/repositories/reconciliation_repository.py:102:100: E501 Line too long (130 > 99)
    |
100 |             await session.commit()
101 |             await session.refresh(instance)
102 |             self.logger.debug(f"Saved new PositionAdjustment with ID {instance.adjustment_id}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
103 |             return instance
    |

gal_friday/dal/repositories/reconciliation_repository.py:116:100: E501 Line too long (102 > 99)
    |
114 |                 select(PositionAdjustment)
115 |                 .where(PositionAdjustment.reconciliation_id == reconciliation_id)
116 |                 .order_by(PositionAdjustment.adjusted_at.desc()) # Assuming 'adjusted_at' field exists
    |                                                                                                    ^^^ E501
117 |             )
118 |             result = await session.execute(stmt)
    |

gal_friday/dal/repositories/reconciliation_repository.py:120:100: E501 Line too long (135 > 99)
    |
118 | …
119 | …
120 | …)} adjustments for event {reconciliation_id}", source_module=self._source_module)
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
121 | …
    |

gal_friday/dal/repositories/reconciliation_repository.py:136:100: E501 Line too long (119 > 99)
    |
134 |             result = await session.execute(stmt)
135 |             adjustments = result.scalars().all()
136 |             self.logger.debug(f"Retrieved adjustment history for last {days} days.", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
137 |             return adjustments
    |

gal_friday/dal/repositories/reconciliation_repository.py:140:100: E501 Line too long (109 > 99)
    |
139 | # _parse_report is removed as the repository now deals with SQLAlchemy models directly.
140 | # Transformation to domain/service layer objects (like ReconciliationReport) would happen in a service layer.
    |                                                                                                    ^^^^^^^^^^ E501
    |

gal_friday/dal/repositories/retraining_repository.py:37:9: D205 1 blank line required between summary line and description
   |
36 |       async def save_job(self, job_data: dict[str, Any]) -> RetrainingJob:
37 | /         """Saves a retraining job.
38 | |         `job_data` should contain fields for RetrainingJob model.
39 | |         job_id should be a UUID. model_id and new_model_id (if present) should be UUIDs.
40 | |         """
   | |___________^ D205
41 |           for key in ["job_id", "model_id", "new_model_id"]:
42 |               if key in job_data and isinstance(job_data[key], str):
   |
   = help: Insert single blank line

gal_friday/dal/repositories/retraining_repository.py:49:100: E501 Line too long (106 > 99)
   |
47 |                  dt_obj = datetime.fromisoformat(job_data[key])
48 |                  job_data[key] = dt_obj.replace(tzinfo=UTC) if dt_obj.tzinfo is None else dt_obj
49 |             elif key in job_data and isinstance(job_data[key], datetime) and job_data[key].tzinfo is None:
   |                                                                                                    ^^^^^^^ E501
50 |                  job_data[key] = job_data[key].replace(tzinfo=UTC)
   |

gal_friday/dal/repositories/retraining_repository.py:59:100: E501 Line too long (106 > 99)
   |
57 |         return await self.create(job_data)
58 |
59 |     async def update_job_status(self, job_id: uuid.UUID, updates: dict[str, Any]) -> RetrainingJob | None:
   |                                                                                                    ^^^^^^^ E501
60 |         """Update job status and results."""
61 |         if "updated_at" not in updates: # Ensure updated_at is set
   |

gal_friday/dal/repositories/retraining_repository.py:68:100: E501 Line too long (103 > 99)
   |
66 |                  dt_obj = datetime.fromisoformat(updates[key])
67 |                  updates[key] = dt_obj.replace(tzinfo=UTC) if dt_obj.tzinfo is None else dt_obj
68 |             elif key in updates and isinstance(updates[key], datetime) and updates[key].tzinfo is None:
   |                                                                                                    ^^^^ E501
69 |                  updates[key] = updates[key].replace(tzinfo=UTC)
   |

gal_friday/dal/repositories/retraining_repository.py:107:100: E501 Line too long (103 > 99)
    |
105 | …     if "detected_at" in event_data and isinstance(event_data["detected_at"], str):
106 | …         dt_obj = datetime.fromisoformat(event_data["detected_at"])
107 | …         event_data["detected_at"] = dt_obj.replace(tzinfo=UTC) if dt_obj.tzinfo is None else dt_obj
    |                                                                                                  ^^^^ E501
108 | …     elif "detected_at" in event_data and isinstance(event_data["detected_at"], datetime) and event_data["detected_at"].tzinfo is No…
109 | …         event_data["detected_at"] = event_data["detected_at"].replace(tzinfo=UTC)
    |

gal_friday/dal/repositories/retraining_repository.py:108:100: E501 Line too long (138 > 99)
    |
106 | …"detected_at"])
107 | …tzinfo=UTC) if dt_obj.tzinfo is None else dt_obj
108 | …(event_data["detected_at"], datetime) and event_data["detected_at"].tzinfo is None:
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
109 | …ected_at"].replace(tzinfo=UTC)
    |

gal_friday/dal/repositories/retraining_repository.py:141:100: E501 Line too long (105 > 99)
    |
139 |     async def get_retraining_metrics(self) -> dict[str, Any]:
140 |         """Get aggregated retraining metrics using raw SQL for complex aggregation."""
141 |         # This query is complex and uses CTEs with specific PostgreSQL functions (row_to_json, json_agg).
    |                                                                                                    ^^^^^^ E501
142 |         # It's often easier to execute such queries directly with SQLAlchemy's text() construct
143 |         # and then process the results, rather than trying to build it entirely with the ORM/Query builder.
    |

gal_friday/dal/repositories/retraining_repository.py:143:100: E501 Line too long (107 > 99)
    |
141 |         # This query is complex and uses CTEs with specific PostgreSQL functions (row_to_json, json_agg).
142 |         # It's often easier to execute such queries directly with SQLAlchemy's text() construct
143 |         # and then process the results, rather than trying to build it entirely with the ORM/Query builder.
    |                                                                                                    ^^^^^^^^ E501
144 |
145 |         thirty_days_ago = (datetime.now(UTC) - timedelta(days=30)).isoformat()
    |

gal_friday/dal/repositories/retraining_repository.py:147:22: S608 Possible SQL injection vector through string-based query construction
    |
145 |           thirty_days_ago = (datetime.now(UTC) - timedelta(days=30)).isoformat()
146 |
147 |           query = text(f"""
    |  ______________________^
148 | |             WITH job_stats AS (
149 | |                 SELECT
150 | |                     COUNT(*) as total_jobs,
151 | |                     COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_jobs,
152 | |                     COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_jobs,
153 | |                     COUNT(CASE WHEN status = 'running' THEN 1 END) as running_jobs,
154 | |                     AVG(EXTRACT(EPOCH FROM (end_time - start_time))) as avg_duration_seconds
155 | |                 FROM retraining_jobs
156 | |                 WHERE created_at > '{thirty_days_ago}'
157 | |             ),
158 | |             trigger_stats AS (
159 | |                 SELECT
160 | |                     trigger,
161 | |                     COUNT(*) as count
162 | |                 FROM retraining_jobs
163 | |                 WHERE created_at > '{thirty_days_ago}'
164 | |                 GROUP BY trigger
165 | |             ),
166 | |             drift_stats AS (
167 | |                 SELECT
168 | |                     drift_type,
169 | |                     COUNT(*) as detections,
170 | |                     COUNT(CASE WHEN is_significant THEN 1 END) as significant_detections
171 | |                 FROM drift_detection_events
172 | |                 WHERE detected_at > '{thirty_days_ago}'
173 | |                 GROUP BY drift_type
174 | |             )
175 | |             SELECT
176 | |                 (SELECT row_to_json(js) FROM job_stats js) as job_statistics,
177 | |                 (SELECT json_agg(ts) FROM trigger_stats ts) as trigger_distribution,
178 | |                 (SELECT json_agg(ds) FROM drift_stats ds) as drift_statistics
179 | |         """)
    | |___________^ S608
180 |
181 |           async with self.session_maker() as session:
    |

gal_friday/dal/repositories/retraining_repository.py:186:100: E501 Line too long (109 > 99)
    |
185 |             if row:
186 |                 # Access columns by name or index. For text() queries with labels, name is usually preferred.
    |                                                                                                    ^^^^^^^^^^ E501
187 |                 # If using mappings(), keys will be strings.
188 |                 row_mapping = row._mapping # Access the underlying mapping
    |

gal_friday/data_ingestion/gap_detector.py:25:1: W293 Blank line contains whitespace
   |
23 | class GapDetector:
24 |     """Detects and analyzes gaps in time series data.
25 |
   | ^^^^ W293
26 |     Features:
27 |     - Configurable gap thresholds
   |
   = help: Remove whitespace from blank line

gal_friday/data_ingestion/gap_detector.py:35:1: W293 Blank line contains whitespace
   |
33 |     def __init__(self, logger: LoggerService) -> None:
34 |         """Initialize gap detector.
35 |
   | ^^^^^^^^ W293
36 |         Args:
37 |             logger: Logger service
   |
   = help: Remove whitespace from blank line

gal_friday/data_ingestion/gap_detector.py:54:1: W293 Blank line contains whitespace
   |
52 |     ) -> list[DataGap]:
53 |         """Detect gaps in time series data.
54 |
   | ^^^^^^^^ W293
55 |         Args:
56 |             data: DataFrame with time series data
   |
   = help: Remove whitespace from blank line

gal_friday/data_ingestion/gap_detector.py:59:1: W293 Blank line contains whitespace
   |
57 |             timestamp_col: Name of timestamp column
58 |             expected_interval: Expected time between data points
59 |
   | ^^^^^^^^^^^^ W293
60 |         Returns:
61 |             List of detected gaps
   |
   = help: Remove whitespace from blank line

gal_friday/data_ingestion/gap_detector.py:123:1: W293 Blank line contains whitespace
    |
121 |     ) -> dict[str, Any]:
122 |         """Analyze patterns in detected gaps.
123 |
    | ^^^^^^^^ W293
124 |         Args:
125 |             gaps: List of detected gaps
    |
    = help: Remove whitespace from blank line

gal_friday/data_ingestion/gap_detector.py:126:1: W293 Blank line contains whitespace
    |
124 |         Args:
125 |             gaps: List of detected gaps
126 |
    | ^^^^^^^^^^^^ W293
127 |         Returns:
128 |             Gap analysis statistics
    |
    = help: Remove whitespace from blank line

gal_friday/data_ingestion/gap_detector.py:139:9: F841 Local variable `durations` is assigned to but never used
    |
137 |         # Basic statistics
138 |         total_duration = sum((g.duration for g in gaps), timedelta())
139 |         durations = [g.duration.total_seconds() for g in gaps]
    |         ^^^^^^^^^ F841
140 |
141 |         durations_seconds = [g.duration.total_seconds() for g in gaps] # ensure list is not empty before np.mean
    |
    = help: Remove assignment to unused variable `durations`

gal_friday/data_ingestion/gap_detector.py:141:100: E501 Line too long (112 > 99)
    |
139 |         durations = [g.duration.total_seconds() for g in gaps]
140 |
141 |         durations_seconds = [g.duration.total_seconds() for g in gaps] # ensure list is not empty before np.mean
    |                                                                                                    ^^^^^^^^^^^^^ E501
142 |         avg_duration_seconds = np.mean(durations_seconds) if durations_seconds else 0.0
    |

gal_friday/data_ingestion/gap_detector.py:147:100: E501 Line too long (101 > 99)
    |
145 |             "total_gaps": len(gaps),
146 |             "total_duration": total_duration,
147 |             "average_duration": timedelta(seconds=float(avg_duration_seconds)), # Explicit float cast
    |                                                                                                    ^^ E501
148 |             "max_duration": max(g.duration for g in gaps),
149 |             "min_duration": min(g.duration for g in gaps),
    |

gal_friday/data_ingestion/gap_detector.py:171:1: W293 Blank line contains whitespace
    |
169 |     ) -> pd.DataFrame:
170 |         """Fill detected gaps in data.
171 |
    | ^^^^^^^^ W293
172 |         Args:
173 |             data: Original DataFrame
    |
    = help: Remove whitespace from blank line

gal_friday/data_ingestion/gap_detector.py:177:1: W293 Blank line contains whitespace
    |
175 |             timestamp_col: Name of timestamp column
176 |             method: Gap filling method ('interpolate', 'forward', 'zero')
177 |
    | ^^^^^^^^^^^^ W293
178 |         Returns:
179 |             DataFrame with filled gaps
    |
    = help: Remove whitespace from blank line

gal_friday/data_ingestion/gap_detector.py:251:30: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
249 |     def _detect_interval(self, timestamps: pd.Series) -> timedelta:
250 |         """Auto-detect the expected interval between timestamps."""
251 |         if len(timestamps) < 2:
    |                              ^ PLR2004
252 |             return timedelta(minutes=1)  # Default for insufficient data
    |

gal_friday/data_ingestion/gap_detector.py:258:100: E501 Line too long (114 > 99)
    |
256 |         if intervals.empty:
257 |             self.logger.warning(
258 |                 "Could not determine interval from timestamps (empty after diff/dropna), defaulting to 1 minute.",
    |                                                                                                    ^^^^^^^^^^^^^^^ E501
259 |                 source_module=self._source_module,
260 |             )
    |

gal_friday/data_ingestion/gap_detector.py:272:100: E501 Line too long (116 > 99)
    |
270 |         # Fallback to median if mode is empty (e.g., all intervals are unique)
271 |         median_val = intervals.median()
272 |         if pd.isna(median_val): # Check if median itself is NaT (e.g., if intervals was empty, though covered above)
    |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
273 |             self.logger.warning(
274 |                 "Median interval calculation resulted in NaT, defaulting to 1 minute.",
    |

gal_friday/data_ingestion/gap_detector.py:288:29: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
    |
287 |         # Map to pandas frequency
288 |         if median_seconds < 60:
    |                             ^^ PLR2004
289 |             return f"{int(median_seconds)}S"
290 |         if median_seconds < 3600:
    |

gal_friday/data_ingestion/gap_detector.py:290:29: PLR2004 Magic value used in comparison, consider replacing `3600` with a constant variable
    |
288 |         if median_seconds < 60:
289 |             return f"{int(median_seconds)}S"
290 |         if median_seconds < 3600:
    |                             ^^^^ PLR2004
291 |             return f"{int(median_seconds/60)}T"
292 |         if median_seconds < 86400:
    |

gal_friday/data_ingestion/gap_detector.py:292:29: PLR2004 Magic value used in comparison, consider replacing `86400` with a constant variable
    |
290 |         if median_seconds < 3600:
291 |             return f"{int(median_seconds/60)}T"
292 |         if median_seconds < 86400:
    |                             ^^^^^ PLR2004
293 |             return f"{int(median_seconds/3600)}H"
294 |         return f"{int(median_seconds/86400)}D"
    |

gal_friday/data_ingestion/gap_detector.py:320:25: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
318 |         # If certain hours have multiple gaps
319 |         for hour, count in hour_counts.items():
320 |             if count >= 3:  # At least 3 occurrences
    |                         ^ PLR2004
321 |                 patterns.append({
322 |                     "type": "time_of_day",
    |

gal_friday/data_ingestion/gap_detector.py:336:25: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
335 |         for day, count in day_counts.items():
336 |             if count >= 2:  # At least 2 occurrences
    |                         ^ PLR2004
337 |                 patterns.append({
338 |                     "type": "day_of_week",
    |

gal_friday/data_ingestor.py:818:100: E501 Line too long (128 > 99)
    |
816 |             # Map Kraken status to internal state if needed
817 |             new_state=str(status) if status is not None else "unknown", # Ensure str
818 |             reason=f"Kraken WS Status Update: {str(status) if status is not None else 'unknown'}", # Ensure str in f-string part
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
819 |         )
820 |         try:
    |

gal_friday/data_ingestor.py:1501:100: E501 Line too long (113 > 99)
     |
1499 |         should_halt = (
1500 |             isinstance(error, ConnectionError | TimeoutError | OSError) and
1501 |             self._consecutive_errors >= self._critical_error_threshold # Changed from self.MAX_CONSECUTIVE_ERRORS
     |                                                                                                    ^^^^^^^^^^^^^^ E501
1502 |         )
     |

gal_friday/data_ingestor.py:1696:9: D417 Missing argument description in the docstring for `_log`: `exc_info`
     |
1694 |         self._logger.log(level, message, *args, exc_info=exc_info, extra=extra)
1695 |
1696 |     def _log(
     |         ^^^^ D417
1697 |         self,
1698 |         level: int,
     |

gal_friday/data_ingestor.py:1766:100: E501 Line too long (113 > 99)
     |
1764 |     ) -> None:
1765 |         """Log an error message."""
1766 |         self._log(logging.ERROR, message, *args, source_module=source_module, context=context, exc_info=exc_info)
     |                                                                                                    ^^^^^^^^^^^^^^ E501
1767 |
1768 |     def critical(
     |

gal_friday/data_ingestor.py:1777:100: E501 Line too long (116 > 99)
     |
1775 |     ) -> None:
1776 |         """Log a critical message."""
1777 |         self._log(logging.CRITICAL, message, *args, source_module=source_module, context=context, exc_info=exc_info)
     |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
1778 |
1779 |     def exception(
     |

gal_friday/database.py:1:1: D100 Missing docstring in public module
gal_friday/database.py:7:5: D103 Missing docstring in public function
  |
6 | # Placeholder function for getting the database connection string
7 | def get_database_connection_string() -> str:
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
8 |     # In a real application, this would fetch from config/config.yaml
9 |     # For now, using a placeholder value.
  |

gal_friday/database.py:21:11: D103 Missing docstring in public function
   |
19 | )
20 |
21 | async def get_db_session() -> AsyncGenerator[AsyncSession, None]:
   |           ^^^^^^^^^^^^^^ D103
22 |     async with AsyncSessionFactory() as session:
23 |         yield session
   |

gal_friday/exceptions.py:67:9: D107 Missing docstring in `__init__`
   |
65 |     """Exception raised when a trading position is not found."""
66 |
67 |     def __init__(self, trading_pair: str | None = None, position_id: str | None = None, message: str | None = None) -> None:
   |         ^^^^^^^^ D107
68 |         if message is None:
69 |             if trading_pair:
   |

gal_friday/exceptions.py:67:100: E501 Line too long (124 > 99)
   |
65 |     """Exception raised when a trading position is not found."""
66 |
67 |     def __init__(self, trading_pair: str | None = None, position_id: str | None = None, message: str | None = None) -> None:
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
68 |         if message is None:
69 |             if trading_pair:
   |

gal_friday/execution/websocket_client.py:255:1: W293 Blank line contains whitespace
    |
253 |     async def _get_ws_token(self) -> str:
254 |         """Get WebSocket authentication token from Kraken API.
255 |
    | ^^^^^^^^ W293
256 |         Implements caching to avoid unnecessary API calls.
257 |         Tokens are valid for 900 seconds (15 minutes).
    |
    = help: Remove whitespace from blank line

gal_friday/execution/websocket_client.py:258:1: W293 Blank line contains whitespace
    |
256 |         Implements caching to avoid unnecessary API calls.
257 |         Tokens are valid for 900 seconds (15 minutes).
258 |
    | ^^^^^^^^ W293
259 |         Returns:
260 |             Valid WebSocket authentication token
    |
    = help: Remove whitespace from blank line

gal_friday/execution/websocket_client.py:261:1: W293 Blank line contains whitespace
    |
259 |         Returns:
260 |             Valid WebSocket authentication token
261 |
    | ^^^^^^^^^^^^ W293
262 |         Raises:
263 |             ExecutionHandlerAuthenticationError: If token retrieval fails
    |
    = help: Remove whitespace from blank line

gal_friday/execution/websocket_client.py:275:100: E501 Line too long (108 > 99)
    |
273 |                 context={"expires_in": self._ws_token_cache["expires_at"] - current_time},
274 |             )
275 |             return self._ws_token_cache["token"]  # This is definitely a string based on our TokenCache type
    |                                                                                                    ^^^^^^^^^ E501
276 |
277 |         # Generate new token
    |

gal_friday/execution/websocket_client.py:301:13: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
    |
299 |               }
300 |
301 | /             async with aiohttp.ClientSession() as session:
302 | |                 async with session.post(
303 | |                     f"{self.api_base_url}{endpoint}",
304 | |                     headers=headers,
305 | |                     data=post_data,
306 | |                 ) as response:
    | |______________________________^ SIM117
307 |                       result = await response.json()
    |
    = help: Combine `with` statements

gal_friday/execution/websocket_client.py:516:9: D415 First line should end with a period, question mark, or exclamation point
    |
515 |     async def _handle_orderbook(self, message: list) -> None:
516 |         """Handle order book updates. (Placeholder)"""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D415
517 |         # Placeholder for actual order book handling logic
518 |         # For now, just log that the message was received
    |
    = help: Add closing punctuation

gal_friday/execution/websocket_client.py:519:50: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
517 |         # Placeholder for actual order book handling logic
518 |         # For now, just log that the message was received
519 |         pair_info = message[3] if len(message) > 3 else "UnknownPair"
    |                                                  ^ PLR2004
520 |         self.logger.info(
521 |             f"Order book update received for {pair_info}. Processing not yet implemented.",
    |

gal_friday/execution/websocket_client.py:550:31: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
548 |         """Handle ticker updates."""
549 |         try:
550 |             if len(message) < 4:
    |                               ^ PLR2004
551 |                 self.logger.warning(
552 |                     "Invalid ticker message format",
    |

gal_friday/execution/websocket_client.py:604:31: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
602 |         """Handle public trades."""
603 |         try:
604 |             if len(message) < 4:
    |                               ^ PLR2004
605 |                 self.logger.warning(
606 |                     "Invalid trade message format",
    |

gal_friday/execution/websocket_client.py:612:100: E501 Line too long (109 > 99)
    |
610 |                 return
611 |
612 |             # Kraken trade format: [channelID, [[price, volume, time, side, orderType, misc]], "trade", pair]
    |                                                                                                    ^^^^^^^^^^ E501
613 |             trades_data = message[1]
614 |             pair = message[3]
    |

gal_friday/execution/websocket_client.py:617:33: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
616 |             for trade in trades_data:
617 |                 if len(trade) < 4:
    |                                 ^ PLR2004
618 |                     continue
    |

gal_friday/execution/websocket_client.py:649:31: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
647 |         """Handle OHLC candle updates."""
648 |         try:
649 |             if len(message) < 4:
    |                               ^ PLR2004
650 |                 self.logger.warning(
651 |                     "Invalid OHLC message format",
    |

gal_friday/execution/websocket_client.py:657:100: E501 Line too long (128 > 99)
    |
655 |                 return
656 |
657 |             # Kraken OHLC format: [channelID, [time, etime, open, high, low, close, vwap, volume, count], "ohlc-interval", pair]
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
658 |             ohlc_data = message[1]
659 |             pair = message[3]
    |

gal_friday/execution/websocket_client.py:662:57: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
661 |             # Extract interval from channel name (e.g., "ohlc-5" for 5 minutes)
662 |             channel_name = message[2] if len(message) > 2 else ""
    |                                                         ^ PLR2004
663 |             interval = "1m"  # Default
664 |             if "-" in channel_name:
    |

gal_friday/execution/websocket_client.py:703:1: W293 Blank line contains whitespace
    |
701 |     def _map_kraken_pair(self, kraken_pair: str) -> str:
702 |         """Map Kraken pair format to internal format.
703 |
    | ^^^^^^^^ W293
704 |         Args:
705 |             kraken_pair: Kraken pair (e.g., "XBT/USD" or "XXBTZUSD")
    |
    = help: Remove whitespace from blank line

gal_friday/execution/websocket_client.py:706:1: W293 Blank line contains whitespace
    |
704 |         Args:
705 |             kraken_pair: Kraken pair (e.g., "XBT/USD" or "XXBTZUSD")
706 |
    | ^^^^^^^^^^^^ W293
707 |         Returns:
708 |             Internal pair format (e.g., "BTC/USD")
    |
    = help: Remove whitespace from blank line

gal_friday/execution/websocket_client.py:731:32: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
    |
730 |         # Try to split (assumes 3-letter currencies)
731 |         if len(kraken_pair) >= 6:
    |                                ^ PLR2004
732 |             return f"{kraken_pair[:3]}/{kraken_pair[3:6]}"
    |

gal_friday/execution_handler.py:8:29: TC003 Move standard library import `collections.abc.Callable` into a type-checking block
   |
 6 | import secrets
 7 | import time
 8 | from collections.abc import Callable, Coroutine
   |                             ^^^^^^^^ TC003
 9 | from dataclasses import dataclass
10 | from datetime import UTC, datetime
   |
   = help: Move into type-checking block

gal_friday/execution_handler.py:8:39: TC003 Move standard library import `collections.abc.Coroutine` into a type-checking block
   |
 6 | import secrets
 7 | import time
 8 | from collections.abc import Callable, Coroutine
   |                                       ^^^^^^^^^ TC003
 9 | from dataclasses import dataclass
10 | from datetime import UTC, datetime
   |
   = help: Move into type-checking block

gal_friday/execution_handler.py:17:39: TC001 Move application import `gal_friday.config_manager.ConfigManager` into a type-checking block
   |
15 | import aiohttp
16 |
17 | from gal_friday.config_manager import ConfigManager
   |                                       ^^^^^^^^^^^^^ TC001
18 |
19 | # Removed incorrect import: from gal_friday.core.errors import ExecutionHandlerAuthenticationError
   |
   = help: Move into type-checking block

gal_friday/execution_handler.py:26:36: TC001 Move application import `gal_friday.core.pubsub.PubSubManager` into a type-checking block
   |
24 |     TradeSignalApprovedEvent,
25 | )
26 | from gal_friday.core.pubsub import PubSubManager
   |                                    ^^^^^^^^^^^^^ TC001
27 | from gal_friday.logger_service import LoggerService
28 | from gal_friday.monitoring_service import MonitoringService
   |
   = help: Move into type-checking block

gal_friday/execution_handler.py:27:39: TC001 Move application import `gal_friday.logger_service.LoggerService` into a type-checking block
   |
25 | )
26 | from gal_friday.core.pubsub import PubSubManager
27 | from gal_friday.logger_service import LoggerService
   |                                       ^^^^^^^^^^^^^ TC001
28 | from gal_friday.monitoring_service import MonitoringService
29 | from gal_friday.utils.kraken_api import generate_kraken_signature
   |
   = help: Move into type-checking block

gal_friday/execution_handler.py:28:43: TC001 Move application import `gal_friday.monitoring_service.MonitoringService` into a type-checking block
   |
26 | from gal_friday.core.pubsub import PubSubManager
27 | from gal_friday.logger_service import LoggerService
28 | from gal_friday.monitoring_service import MonitoringService
   |                                           ^^^^^^^^^^^^^^^^^ TC001
29 | from gal_friday.utils.kraken_api import generate_kraken_signature
   |
   = help: Move into type-checking block

gal_friday/execution_handler.py:1618:1: W293 Blank line contains whitespace
     |
1616 |     ) -> TradeSignalApprovedEvent | None:
1617 |         """Retrieve the original signal event that led to an order.
1618 |
     | ^^^^^^^^ W293
1619 |         Uses the event store to fetch historical events.
1620 |         """
     |
     = help: Remove whitespace from blank line

gal_friday/interfaces/execution_handler_interface.py:144:7: D101 Missing docstring in public class
    |
144 | class ExecutionHandlerKwargs(TypedDict, total=False):
    |       ^^^^^^^^^^^^^^^^^^^^^^ D101
145 |     # This TypedDict is initially empty or can include common keys
146 |     # if they are known. `total=False` makes all keys optional.
    |

gal_friday/interfaces/strategy_interface.py:263:100: E501 Line too long (126 > 99)
    |
261 |         # Portfolio-specific validation
262 |         if action.action_type in [ActionType.SELL, ActionType.CLOSE_LONG]:
263 |             asset_spec_or_default_dict: AssetSpecification | dict[str, Any] = self.asset_specifications.get(action.symbol, {})
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
264 |             if isinstance(asset_spec_or_default_dict, dict):
265 |                 current_position = asset_spec_or_default_dict.get("position", 0)
    |

gal_friday/kraken_historical_data_service.py:885:1: W293 Blank line contains whitespace
    |
883 |     ) -> list[dict[str, Any]] | None:
884 |         """Fetch historical trade data from Kraken.
885 |
    | ^^^^^^^^ W293
886 |         Args:
887 |             trading_pair: Trading pair (e.g., "XRP/USD")
    |
    = help: Remove whitespace from blank line

gal_friday/kraken_historical_data_service.py:891:1: W293 Blank line contains whitespace
    |
889 |             until: End time (exclusive)
890 |             limit: Maximum number of trades to fetch
891 |
    | ^^^^^^^^^^^^ W293
892 |         Returns:
893 |             List of trade dictionaries or None on error
    |
    = help: Remove whitespace from blank line

gal_friday/kraken_historical_data_service.py:926:100: E501 Line too long (101 > 99)
    |
924 |                 if not result or result.get("error"):
925 |                     self.logger.error(
926 |                         f"Error fetching trades: {result.get('error') if result else 'No response'}",
    |                                                                                                    ^^ E501
927 |                         source_module=self._source_module,
928 |                     )
    |

gal_friday/kraken_historical_data_service.py:949:58: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
947 |                         "side": "buy" if trade[3] == "b" else "sell",
948 |                         "order_type": "market" if trade[4] == "m" else "limit",
949 |                         "misc": trade[5] if len(trade) > 5 else "",
    |                                                          ^ PLR2004
950 |                     }
    |

gal_friday/kraken_historical_data_service.py:992:1: W293 Blank line contains whitespace
    |
990 |     ) -> dict[str, Any] | None:
991 |         """Make a public API request to Kraken.
992 |
    | ^^^^^^^^ W293
993 |         Args:
994 |             endpoint: API endpoint
    |
    = help: Remove whitespace from blank line

gal_friday/kraken_historical_data_service.py:996:1: W293 Blank line contains whitespace
    |
994 |             endpoint: API endpoint
995 |             params: Request parameters
996 |
    | ^^^^^^^^^^^^ W293
997 |         Returns:
998 |             API response or None on error
    |
    = help: Remove whitespace from blank line

gal_friday/kraken_historical_data_service.py:1003:13: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
     |
1001 |               url = f"{self.api_base_url}{endpoint}"
1002 |
1003 | /             async with aiohttp.ClientSession() as session:
1004 | |                 async with session.get(url, params=params) as response:
     | |_______________________________________________________________________^ SIM117
1005 |                       if response.status != 200:
1006 |                           self.logger.error(
     |
     = help: Combine `with` statements

gal_friday/kraken_historical_data_service.py:1005:43: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
     |
1003 |             async with aiohttp.ClientSession() as session:
1004 |                 async with session.get(url, params=params) as response:
1005 |                     if response.status != 200:
     |                                           ^^^ PLR2004
1006 |                         self.logger.error(
1007 |                             f"API request failed with status {response.status}",
     |

gal_friday/kraken_historical_data_service.py:1024:1: W293 Blank line contains whitespace
     |
1022 |     def _get_kraken_pair_name(self, trading_pair: str) -> str | None:
1023 |         """Convert internal pair format to Kraken format.
1024 |
     | ^^^^^^^^ W293
1025 |         Args:
1026 |             trading_pair: Internal format (e.g., "XRP/USD")
     |
     = help: Remove whitespace from blank line

gal_friday/kraken_historical_data_service.py:1027:1: W293 Blank line contains whitespace
     |
1025 |         Args:
1026 |             trading_pair: Internal format (e.g., "XRP/USD")
1027 |
     | ^^^^^^^^^^^^ W293
1028 |         Returns:
1029 |             Kraken format (e.g., "XXRPZUSD") or None if not found
     |
     = help: Remove whitespace from blank line

gal_friday/logger_service.py:91:100: E501 Line too long (123 > 99)
   |
89 | # Define a type alias for exc_info to improve readability and manage line length
90 | # Moved to module level and updated to use Union, Tuple
91 | ExcInfoType: TypingTypeAlias = bool | tuple[type[BaseException], BaseException, types.TracebackType] | BaseException | None
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
92 |
93 | # Define a Protocol for ConfigManager to properly type hint its interface
   |

gal_friday/logger_service.py:220:100: E501 Line too long (102 > 99)
    |
218 |     """Asynchronous handler for logging to PostgreSQL database using SQLAlchemy."""
219 |
220 |     # ALLOWED_TABLE_NAMES might not be strictly necessary if we always log to the 'Log' model's table.
    |                                                                                                    ^^^ E501
221 |     # However, if the table name for the Log model can vary, this could be used for validation.
222 |     # For now, assuming Log model maps to 'logs' table.
    |

gal_friday/logger_service.py:225:100: E501 Line too long (113 > 99)
    |
223 |     # ALLOWED_TABLE_NAMES: ClassVar[set[str]] = {"logs"}
224 |
225 |     def __init__(self, session_maker: async_sessionmaker[AsyncSession], loop: asyncio.AbstractEventLoop) -> None:
    |                                                                                                    ^^^^^^^^^^^^^^ E501
226 |         """Initialize the handler with SQLAlchemy session maker and event loop.
    |

gal_friday/logger_service.py:272:16: SIM101 Multiple `isinstance` calls for expression, merge into a single call
    |
270 |         context_data = None # Changed from context_json
271 |         if hasattr(record, "context") and record.context:
272 |             if isinstance(record.context, dict) or isinstance(record.context, list):
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SIM101
273 |                 context_data = record.context # Keep as Python dict/list for SQLAlchemy
274 |             else:
    |
    = help: Merge `isinstance` calls

gal_friday/logger_service.py:319:13: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
    |
317 |               log_entry = Log(**record_data)
318 |
319 | /             async with self._session_maker() as session:
320 | |                 async with session.begin(): # Start a transaction
    | |___________________________________________^ SIM117
321 |                       session.add(log_entry)
322 |                   # Commit happens automatically with session.begin() context manager,
    |
    = help: Combine `with` statements

gal_friday/logger_service.py:387:100: E501 Line too long (101 > 99)
    |
385 |                     )
386 |                     await asyncio.sleep(wait_time)
387 |             except (RuntimeError, ValueError, TypeError, DatabaseError) as e: # General non-DB errors
    |                                                                                                    ^^ E501
388 |                 logging.getLogger(__name__).error(
389 |                     "AsyncPostgresHandler: Non-retryable error caught in _process_queue_with_retry for record: %s. Error: %s",
    |

gal_friday/logger_service.py:389:100: E501 Line too long (126 > 99)
    |
387 |             except (RuntimeError, ValueError, TypeError, DatabaseError) as e: # General non-DB errors
388 |                 logging.getLogger(__name__).error(
389 |                     "AsyncPostgresHandler: Non-retryable error caught in _process_queue_with_retry for record: %s. Error: %s",
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
390 |                     record_data.get("message", "N/A"), e, exc_info=True,
391 |                 )
    |

gal_friday/logger_service.py:434:100: E501 Line too long (108 > 99)
    |
432 |                  self.start_processing() # Try to start it if it never did
433 |
434 |             if self._loop and self._loop.is_running(): # Check if loop is available for call_soon_threadsafe
    |                                                                                                    ^^^^^^^^^ E501
435 |                  self._loop.call_soon_threadsafe(lambda: self._queue.put_nowait(None))
436 |             else: # Fallback if loop is closed, try to put directly (might fail if full)
    |

gal_friday/logger_service.py:440:100: E501 Line too long (130 > 99)
    |
438 |                     self._queue.put_nowait(None)
439 |                 except QueueFull:
440 |                     logging.getLogger(__name__).error("AsyncPostgresHandler: Queue full while trying to add sentinel in close().")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
441 |
442 |         super().close() # Calls Handler.close()
    |

gal_friday/logger_service.py:507:100: E501 Line too long (116 > 99)
    |
506 |         # Queue and thread for handling synchronous logging calls from async context
507 |         self._queue: queue.Queue[tuple[Callable[..., None], tuple, dict]] = queue.Queue() # Keep this for sync calls
    |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
508 |         self._thread = threading.Thread(target=self._process_log_queue, daemon=True)
509 |         self._stop_event = threading.Event()
    |

gal_friday/logger_service.py:603:100: E501 Line too long (103 > 99)
    |
601 |                         handler.close()
602 |                 # Re-run the DB handler part of _setup_logging logic
603 |                 db_table = str(self._config_manager.get("logging.database.table_name", default="logs"))
    |                                                                                                    ^^^^ E501
604 |                 if db_table != "logs": db_table = "logs" # Enforce
605 |                 db_level_str = str(self._config_manager.get("logging.database.level", default="INFO")).upper()
    |

gal_friday/logger_service.py:604:38: E701 Multiple statements on one line (colon)
    |
602 |                 # Re-run the DB handler part of _setup_logging logic
603 |                 db_table = str(self._config_manager.get("logging.database.table_name", default="logs"))
604 |                 if db_table != "logs": db_table = "logs" # Enforce
    |                                      ^ E701
605 |                 db_level_str = str(self._config_manager.get("logging.database.level", default="INFO")).upper()
606 |                 db_level = getattr(logging, db_level_str, logging.INFO)
    |

gal_friday/logger_service.py:605:100: E501 Line too long (110 > 99)
    |
603 |                 db_table = str(self._config_manager.get("logging.database.table_name", default="logs"))
604 |                 if db_table != "logs": db_table = "logs" # Enforce
605 |                 db_level_str = str(self._config_manager.get("logging.database.level", default="INFO")).upper()
    |                                                                                                    ^^^^^^^^^^^ E501
606 |                 db_level = getattr(logging, db_level_str, logging.INFO)
607 |                 try:
    |

gal_friday/logger_service.py:608:100: E501 Line too long (112 > 99)
    |
606 |                 db_level = getattr(logging, db_level_str, logging.INFO)
607 |                 try:
608 |                     self._async_handler = AsyncPostgresHandler(self._db_session_maker, asyncio.get_event_loop())
    |                                                                                                    ^^^^^^^^^^^^^ E501
609 |                     self._async_handler.setLevel(db_level)
610 |                     self._root_logger.addHandler(self._async_handler)
    |

gal_friday/logger_service.py:876:9: S101 Use of `assert` detected
    |
874 |             return False
875 |
876 |         assert url is not None, "URL should be a string after 'all' check"
    |         ^^^^^^ S101
877 |
878 |         try:
    |

gal_friday/logger_service.py:880:57: F401 `influxdb_client.Point` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
878 |         try:
879 |             # Import influxdb_client specifics here, only when actually trying to initialize
880 |             from influxdb_client import InfluxDBClient, Point
    |                                                         ^^^^^ F401
881 |             from influxdb_client.client.exceptions import InfluxDBError
882 |             from influxdb_client.client.write_api import SYNCHRONOUS
    |
    = help: Remove unused import: `influxdb_client.Point`

gal_friday/logger_service.py:881:59: F401 `influxdb_client.client.exceptions.InfluxDBError` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
879 |             # Import influxdb_client specifics here, only when actually trying to initialize
880 |             from influxdb_client import InfluxDBClient, Point
881 |             from influxdb_client.client.exceptions import InfluxDBError
    |                                                           ^^^^^^^^^^^^^ F401
882 |             from influxdb_client.client.write_api import SYNCHRONOUS
883 |         except ImportError:
    |
    = help: Remove unused import: `influxdb_client.client.exceptions.InfluxDBError`

gal_friday/logger_service.py:927:10: TC010 Invalid string member in `X | Y`-style union type
    |
925 |         fields: dict[str, Any],
926 |         timestamp: datetime,
927 |     ) -> "InfluxDBPoint" | None:  # Returns InfluxDB Point or None
    |          ^^^^^^^^^^^^^^^ TC010
928 |         """Prepare a data point for InfluxDB.
    |

gal_friday/logger_service.py:1078:100: E501 Line too long (103 > 99)
     |
1076 |                         handler.close()
1077 |                 # Re-run the DB handler part of _setup_logging logic
1078 |                 db_table = str(self._config_manager.get("logging.database.table_name", default="logs"))
     |                                                                                                    ^^^^ E501
1079 |                 if db_table != "logs": db_table = "logs" # Enforce
1080 |                 db_level_str = str(self._config_manager.get("logging.database.level", default="INFO")).upper()
     |

gal_friday/logger_service.py:1079:38: E701 Multiple statements on one line (colon)
     |
1077 |                 # Re-run the DB handler part of _setup_logging logic
1078 |                 db_table = str(self._config_manager.get("logging.database.table_name", default="logs"))
1079 |                 if db_table != "logs": db_table = "logs" # Enforce
     |                                      ^ E701
1080 |                 db_level_str = str(self._config_manager.get("logging.database.level", default="INFO")).upper()
1081 |                 db_level = getattr(logging, db_level_str, logging.INFO)
     |

gal_friday/logger_service.py:1080:100: E501 Line too long (110 > 99)
     |
1078 |                 db_table = str(self._config_manager.get("logging.database.table_name", default="logs"))
1079 |                 if db_table != "logs": db_table = "logs" # Enforce
1080 |                 db_level_str = str(self._config_manager.get("logging.database.level", default="INFO")).upper()
     |                                                                                                    ^^^^^^^^^^^ E501
1081 |                 db_level = getattr(logging, db_level_str, logging.INFO)
1082 |                 try:
     |

gal_friday/logger_service.py:1083:100: E501 Line too long (112 > 99)
     |
1081 |                 db_level = getattr(logging, db_level_str, logging.INFO)
1082 |                 try:
1083 |                     self._async_handler = AsyncPostgresHandler(self._db_session_maker, asyncio.get_event_loop())
     |                                                                                                    ^^^^^^^^^^^^^ E501
1084 |                     self._async_handler.setLevel(db_level)
1085 |                     self._root_logger.addHandler(self._async_handler)
     |

gal_friday/logger_service.py:1111:100: E501 Line too long (129 > 99)
     |
1109 |             self.info("AsyncPostgresHandler processing started.", source_module="LoggerService")
1110 |         elif self._db_enabled:
1111 |             self.error("DB logging enabled, but AsyncPostgresHandler not initialized in start().", source_module="LoggerService")
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
     |

gal_friday/logger_service.py:1139:100: E501 Line too long (111 > 99)
     |
1137 |             try:
1138 |                 if hasattr(self._async_handler, "wait_closed"):
1139 |                     await asyncio.wait_for(self._async_handler.wait_closed(), timeout=10.0) # Increased timeout
     |                                                                                                    ^^^^^^^^^^^^ E501
1140 |                     self.info(
1141 |                         "SQLAlchemy database log handler closed gracefully.",
     |

gal_friday/logger_service.py:1157:100: E501 Line too long (105 > 99)
     |
1155 |                 )
1156 |
1157 |         # Signal the log processing thread to stop (This thread is for the python logging queue, keep it)
     |                                                                                                    ^^^^^^ E501
1158 |         self._stop_event.set()
1159 |         self._thread.join(timeout=2.0)
     |

gal_friday/logger_service.py:1169:100: E501 Line too long (111 > 99)
     |
1167 |         """Initialize the SQLAlchemy engine and session factory for database logging."""
1168 |         if not self._db_enabled:
1169 |             self.info("Database logging is disabled. SQLAlchemy setup skipped.", source_module="LoggerService")
     |                                                                                                    ^^^^^^^^^^^^ E501
1170 |             return
     |

gal_friday/logger_service.py:1175:100: E501 Line too long (102 > 99)
     |
1173 |         if not db_url:
1174 |             self.error(
1175 |                 "Database logging enabled but connection_string is missing. SQLAlchemy setup failed.",
     |                                                                                                    ^^^ E501
1176 |                 source_module="LoggerService",
1177 |             )
     |

gal_friday/logger_service.py:1185:100: E501 Line too long (150 > 99)
     |
1183 | …ing...",
1184 | …
1185 | …rl).find("@")] + "@********" if "@" in str(db_url) else str(db_url)}, # Mask credentials
     |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1186 | …
1187 | …database.pool_size", 5)
     |

gal_friday/logger_service.py:1199:100: E501 Line too long (107 > 99)
     |
1197 |             # Use async_sessionmaker for AsyncEngine and AsyncSession
1198 |             self._sqlalchemy_session_factory = async_sessionmaker(
1199 |                 bind=self._sqlalchemy_engine, class_=AsyncSession, expire_on_commit=False, autoflush=False,
     |                                                                                                    ^^^^^^^^ E501
1200 |             )
1201 |             self.info(
     |

gal_friday/logger_service.py:1217:100: E501 Line too long (114 > 99)
     |
1215 |         except Exception as e: # Catch any other unexpected errors
1216 |             self.critical(
1217 |                 "An unexpected error occurred during SQLAlchemy engine initialization: %s. Disabling DB logging.",
     |                                                                                                    ^^^^^^^^^^^^^^^ E501
1218 |                 e,
1219 |                 source_module="LoggerService",
     |

gal_friday/main.py:842:100: E501 Line too long (112 > 99)
    |
840 |         # --- 5. Database Connection Pool and Session Maker ---
841 |         if DatabaseConnectionPool is not None and self.config is not None:
842 |             # Create a basic logger instance for DatabaseConnectionPool if self.logger_service isn't fully ready
    |                                                                                                    ^^^^^^^^^^^^^ E501
843 |             # Or ensure LoggerService is instantiated in a basic mode first.
844 |             # For this step, assuming a basic logger from python's logging can be passed or self.logger_service is basic.
    |

gal_friday/main.py:844:100: E501 Line too long (121 > 99)
    |
842 |             # Create a basic logger instance for DatabaseConnectionPool if self.logger_service isn't fully ready
843 |             # Or ensure LoggerService is instantiated in a basic mode first.
844 |             # For this step, assuming a basic logger from python's logging can be passed or self.logger_service is basic.
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
845 |             # If LoggerService needs full setup for other services to use its get_logger, this order is tricky.
846 |             # Let's assume self.logger_service is not yet the full DB-logging instance.
    |

gal_friday/main.py:845:100: E501 Line too long (111 > 99)
    |
843 |             # Or ensure LoggerService is instantiated in a basic mode first.
844 |             # For this step, assuming a basic logger from python's logging can be passed or self.logger_service is basic.
845 |             # If LoggerService needs full setup for other services to use its get_logger, this order is tricky.
    |                                                                                                    ^^^^^^^^^^^^ E501
846 |             # Let's assume self.logger_service is not yet the full DB-logging instance.
847 |             # We will use a temporary logger for db_pool.
    |

gal_friday/main.py:857:100: E501 Line too long (121 > 99)
    |
855 |             self.session_maker = self.db_connection_pool.get_session_maker()
856 |             if not self.session_maker:
857 |                 log.critical("Failed to get session_maker from DatabaseConnectionPool. DB-dependent services will fail.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
858 |                 raise DependencyMissingError("Application", "session_maker from DatabaseConnectionPool")
859 |             log.info("DatabaseConnectionPool initialized and session_maker created.")
    |

gal_friday/main.py:858:100: E501 Line too long (104 > 99)
    |
856 |             if not self.session_maker:
857 |                 log.critical("Failed to get session_maker from DatabaseConnectionPool. DB-dependent services will fail.")
858 |                 raise DependencyMissingError("Application", "session_maker from DatabaseConnectionPool")
    |                                                                                                    ^^^^^ E501
859 |             log.info("DatabaseConnectionPool initialized and session_maker created.")
860 |         else:
    |

gal_friday/model_lifecycle/cloud_storage.py:40:1: W293 Blank line contains whitespace
   |
38 |     def __init__(self, config: ConfigManager, logger: LoggerService) -> None:
39 |         """Initialize GCS backend.
40 |
   | ^^^^^^^^ W293
41 |         Args:
42 |             config: Configuration manager
   |
   = help: Remove whitespace from blank line

gal_friday/model_lifecycle/cloud_storage.py:68:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
66 |             )
67 |         except ImportError:
68 |             raise ImportError("google-cloud-storage not installed")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
69 |         except Exception as e:
70 |             raise RuntimeError(f"Failed to initialize GCS client: {e}")
   |

gal_friday/model_lifecycle/cloud_storage.py:70:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
68 |             raise ImportError("google-cloud-storage not installed")
69 |         except Exception as e:
70 |             raise RuntimeError(f"Failed to initialize GCS client: {e}")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
71 |
72 |     async def upload(self, local_path: Path, remote_path: str) -> bool:
   |

gal_friday/model_lifecycle/cloud_storage.py:203:17: SIM108 Use ternary operator `file_path = local_path if not relative_path else local_path / relative_path` instead of `if`-`else`-block
    |
201 |                   # Calculate local file path
202 |                   relative_path = blob.name[len(remote_path):].lstrip("/")
203 | /                 if not relative_path:  # Single file
204 | |                     file_path = local_path
205 | |                 else:
206 | |                     file_path = local_path / relative_path
    | |__________________________________________________________^ SIM108
207 |
208 |                   task = self._download_file(blob, file_path)
    |
    = help: Replace `if`-`else`-block with `file_path = local_path if not relative_path else local_path / relative_path`

gal_friday/model_lifecycle/cloud_storage.py:231:42: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `blob`
    |
229 |             return False
230 |
231 |     async def _download_file(self, blob: Any, local_path: Path) -> bool:
    |                                          ^^^ ANN401
232 |         """Download single file from GCS."""
233 |         try:
    |

gal_friday/model_lifecycle/cloud_storage.py:287:17: S608 Possible SQL injection vector through string-based query construction
    |
285 |         except Exception:
286 |             self.logger.exception(
287 |                 f"Failed to delete from GCS: {remote_path}",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S608
288 |                 source_module=self._source_module,
289 |             )
    |

gal_friday/model_lifecycle/cloud_storage.py:339:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
337 |             )
338 |         except ImportError:
339 |             raise ImportError("aioboto3 not installed")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
340 |
341 |     async def upload(self, local_path: Path, remote_path: str) -> bool:
    |

gal_friday/model_lifecycle/cloud_storage.py:355:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `s3`
    |
353 |             return False
354 |
355 |     async def _upload_file_s3(self, s3: Any, local_path: Path, remote_path: str) -> bool:
    |                                         ^^^ ANN401
356 |         """Upload single file to S3."""
357 |         try:
    |

gal_friday/model_lifecycle/cloud_storage.py:403:46: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `s3`
    |
401 |             return False
402 |
403 |     async def _upload_directory_s3(self, s3: Any, local_path: Path, remote_path: str) -> bool:
    |                                              ^^^ ANN401
404 |         """Upload directory recursively to S3."""
405 |         try:
    |

gal_friday/model_lifecycle/cloud_storage.py:454:25: SIM108 Use ternary operator `file_path = local_path if not relative_path else local_path / relative_path` instead of `if`-`else`-block
    |
452 |                           # Calculate local file path
453 |                           relative_path = obj["Key"][len(remote_path):].lstrip("/")
454 | /                         if not relative_path:  # Single file
455 | |                             file_path = local_path
456 | |                         else:
457 | |                             file_path = local_path / relative_path
    | |__________________________________________________________________^ SIM108
458 |
459 |                           task = self._download_file_s3(s3, obj["Key"], file_path)
    |
    = help: Replace `if`-`else`-block with `file_path = local_path if not relative_path else local_path / relative_path`

gal_friday/model_lifecycle/cloud_storage.py:489:43: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `s3`
    |
487 |             return False
488 |
489 |     async def _download_file_s3(self, s3: Any, key: str, local_path: Path) -> bool:
    |                                           ^^^ ANN401
490 |         """Download single file from S3."""
491 |         try:
    |

gal_friday/model_lifecycle/cloud_storage.py:553:17: S608 Possible SQL injection vector through string-based query construction
    |
551 |         except Exception:
552 |             self.logger.exception(
553 |                 f"Failed to delete from S3: {remote_path}",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S608
554 |                 source_module=self._source_module,
555 |             )
    |

gal_friday/model_lifecycle/experiment_manager.py:27:60: TC001 Move application import `gal_friday.dal.models.experiment.Experiment` into a type-checking block
   |
26 | # Import SQLAlchemy models that this manager might deal with if it transforms data
27 | from gal_friday.dal.models.experiment import Experiment as ExperimentModel
   |                                                            ^^^^^^^^^^^^^^^ TC001
28 | from gal_friday.dal.repositories.experiment_repository import ExperimentRepository
29 | from gal_friday.logger_service import LoggerService
   |
   = help: Move into type-checking block

gal_friday/model_lifecycle/experiment_manager.py:180:100: E501 Line too long (101 > 99)
    |
178 |         self.model_registry = model_registry
179 |         self.session_maker = session_maker # Store session_maker
180 |         self.experiment_repo = ExperimentRepository(session_maker, logger_service) # Instantiate repo
    |                                                                                                    ^^ E501
181 |         self.pubsub = pubsub_manager
182 |         self.logger = logger_service
    |

gal_friday/model_lifecycle/experiment_manager.py:190:100: E501 Line too long (102 > 99)
    |
189 |         # Configuration
190 |         self.max_concurrent_experiments = self.config_manager.get_int("experiments.max_concurrent", 3)
    |                                                                                                    ^^^ E501
191 |         self.auto_stop_on_significance = self.config_manager.get_bool(
192 |             "experiments.auto_stop_on_significance", True,
    |

gal_friday/model_lifecycle/experiment_manager.py:194:100: E501 Line too long (107 > 99)
    |
192 |             "experiments.auto_stop_on_significance", True,
193 |         )
194 |         self.check_interval_minutes = self.config_manager.get_int("experiments.check_interval_minutes", 60)
    |                                                                                                    ^^^^^^^^ E501
195 |
196 |         # State
    |

gal_friday/model_lifecycle/experiment_manager.py:266:100: E501 Line too long (112 > 99)
    |
265 |             # Convert specific Decimal fields back to Decimal if to_dict stringified them
266 |             for key in ["traffic_split", "confidence_level", "minimum_detectable_effect", "max_loss_threshold"]:
    |                                                                                                    ^^^^^^^^^^^^^ E501
267 |                 if key in experiment_data_dict and experiment_data_dict[key] is not None:
268 |                     experiment_data_dict[key] = Decimal(str(experiment_data_dict[key]))
    |

gal_friday/model_lifecycle/experiment_manager.py:276:100: E501 Line too long (103 > 99)
    |
276 |             created_experiment_model = await self.experiment_repo.save_experiment(experiment_data_dict)
    |                                                                                                    ^^^^ E501
277 |
278 |             # Helper to safely get .hex
    |

gal_friday/model_lifecycle/experiment_manager.py:279:31: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `val`
    |
278 |             # Helper to safely get .hex
279 |             def safe_hex(val: Any, name: str) -> str:
    |                               ^^^ ANN401
280 |                 if isinstance(val, uuid.UUID):
281 |                     return val.hex
    |

gal_friday/model_lifecycle/experiment_manager.py:298:100: E501 Line too long (115 > 99)
    |
296 |                     raise TypeError(err_msg) from e
297 |
298 |             exp_id_hex = safe_hex(created_experiment_model.experiment_id, "created_experiment_model.experiment_id")
    |                                                                                                    ^^^^^^^^^^^^^^^^ E501
299 |             control_id_hex = safe_hex(created_experiment_model.control_model_id, "created_experiment_model.control_model_id")
300 |             treatment_id_hex = safe_hex(created_experiment_model.treatment_model_id, "created_experiment_model.treatment_model_id")
    |

gal_friday/model_lifecycle/experiment_manager.py:299:100: E501 Line too long (125 > 99)
    |
298 |             exp_id_hex = safe_hex(created_experiment_model.experiment_id, "created_experiment_model.experiment_id")
299 |             control_id_hex = safe_hex(created_experiment_model.control_model_id, "created_experiment_model.control_model_id")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
300 |             treatment_id_hex = safe_hex(created_experiment_model.treatment_model_id, "created_experiment_model.treatment_model_id")
    |

gal_friday/model_lifecycle/experiment_manager.py:300:100: E501 Line too long (131 > 99)
    |
298 |             exp_id_hex = safe_hex(created_experiment_model.experiment_id, "created_experiment_model.experiment_id")
299 |             control_id_hex = safe_hex(created_experiment_model.control_model_id, "created_experiment_model.control_model_id")
300 |             treatment_id_hex = safe_hex(created_experiment_model.treatment_model_id, "created_experiment_model.treatment_model_id")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
301 |
302 |             # Add to active experiments (still using ExperimentConfig dataclass for now)
    |

gal_friday/model_lifecycle/experiment_manager.py:471:100: E501 Line too long (167 > 99)
    |
469 | …
470 | …
471 | …nt {experiment_id}, event {event_id}. Cannot record outcome.", source_module=self._source_module)
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
472 | …
    |

gal_friday/model_lifecycle/experiment_manager.py:483:100: E501 Line too long (164 > 99)
    |
481 | …
482 | …
483 | …und in performance tracking for experiment {experiment_id}.", source_module=self._source_module)
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
484 | …
485 | …
    |

gal_friday/model_lifecycle/experiment_manager.py:645:100: E501 Line too long (108 > 99)
    |
643 |             }
644 |
645 |             await self.experiment_repo.save_results(uuid.UUID(experiment_id), results) # Convert str to UUID
    |                                                                                                    ^^^^^^^^^ E501
646 |
647 |             # Remove from active experiments
    |

gal_friday/model_lifecycle/experiment_manager.py:680:100: E501 Line too long (117 > 99)
    |
678 |         try:
679 |             # experiment_repo.get_active_experiments() returns Sequence[ExperimentModel]
680 |             active_experiment_models: Sequence[ExperimentModel] = await self.experiment_repo.get_active_experiments()
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
681 |
682 |             for exp_model in active_experiment_models:
    |

gal_friday/model_lifecycle/experiment_manager.py:685:17: F841 Local variable `config_data` is assigned to but never used
    |
683 |                 # Convert ExperimentModel to ExperimentConfig if internal logic still uses it.
684 |                 # This is a simplification; direct use of exp_model attributes is preferred.
685 |                 config_data = exp_model.config_data or {} # Use stored config_data if available
    |                 ^^^^^^^^^^^ F841
686 |                 # Map model fields to ExperimentConfig fields
687 |                 # This mapping might be complex if structures differ significantly.
    |
    = help: Remove assignment to unused variable `config_data`

gal_friday/model_lifecycle/experiment_manager.py:691:35: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `val`
    |
690 |                 # Helper to safely get .hex
691 |                 def safe_hex(val: Any, name: str) -> str:
    |                                   ^^^ ANN401
692 |                     if not isinstance(val, uuid.UUID):
693 |                         err_msg = f"{name} is not a UUID instance: {type(val)}"
    |

gal_friday/model_lifecycle/experiment_manager.py:698:100: E501 Line too long (111 > 99)
    |
696 |                     return val.hex
697 |
698 |                 exp_id_hex = safe_hex(exp_model.experiment_id, f"exp_model.experiment_id for {exp_model.name}")
    |                                                                                                    ^^^^^^^^^^^^ E501
699 |                 control_id_hex = safe_hex(exp_model.control_model_id, f"exp_model.control_model_id for {exp_model.name}")
700 |                 treatment_id_hex = safe_hex(exp_model.treatment_model_id, f"exp_model.treatment_model_id for {exp_model.name}")
    |

gal_friday/model_lifecycle/experiment_manager.py:699:100: E501 Line too long (121 > 99)
    |
698 |                 exp_id_hex = safe_hex(exp_model.experiment_id, f"exp_model.experiment_id for {exp_model.name}")
699 |                 control_id_hex = safe_hex(exp_model.control_model_id, f"exp_model.control_model_id for {exp_model.name}")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
700 |                 treatment_id_hex = safe_hex(exp_model.treatment_model_id, f"exp_model.treatment_model_id for {exp_model.name}")
    |

gal_friday/model_lifecycle/experiment_manager.py:700:100: E501 Line too long (127 > 99)
    |
698 |                 exp_id_hex = safe_hex(exp_model.experiment_id, f"exp_model.experiment_id for {exp_model.name}")
699 |                 control_id_hex = safe_hex(exp_model.control_model_id, f"exp_model.control_model_id for {exp_model.name}")
700 |                 treatment_id_hex = safe_hex(exp_model.treatment_model_id, f"exp_model.treatment_model_id for {exp_model.name}")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
701 |
702 |                 exp_config = ExperimentConfig(
    |

gal_friday/model_lifecycle/experiment_manager.py:710:100: E501 Line too long (139 > 99)
    |
708 | …gy(exp_model.allocation_strategy),
709 | …t, # Already Decimal
710 | …ace(tzinfo=UTC if exp_model.start_time.tzinfo is None else None), # Ensure tz-aware
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
711 | …tzinfo=UTC if exp_model.end_time and exp_model.end_time.tzinfo is None else None) if exp_model.end_time else None,
712 | …n_samples_per_variant or 1000,
    |

gal_friday/model_lifecycle/experiment_manager.py:711:100: E501 Line too long (170 > 99)
    |
709 | …cimal
710 | …if exp_model.start_time.tzinfo is None else None), # Ensure tz-aware
711 | …xp_model.end_time and exp_model.end_time.tzinfo is None else None) if exp_model.end_time else None,
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
712 | …ariant or 1000,
713 | …
    |

gal_friday/model_lifecycle/experiment_manager.py:714:100: E501 Line too long (175 > 99)
    |
712 | …ant or 1000,
713 | …
714 | …rics", []) if isinstance(exp_model.secondary_metrics, dict) else (exp_model.secondary_metrics or []),
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
715 | …_CONFIDENCE_LEVEL,
716 | …_effect or DEFAULT_MIN_DETECTABLE_EFFECT,
    |

gal_friday/model_lifecycle/experiment_manager.py:716:100: E501 Line too long (115 > 99)
    |
714 | …         secondary_metrics=exp_model.secondary_metrics.get("metrics", []) if isinstance(exp_model.secondary_metrics, dict) else (exp…
715 | …         confidence_level=exp_model.confidence_level or DEFAULT_CONFIDENCE_LEVEL,
716 | …         minimum_detectable_effect=exp_model.minimum_detectable_effect or DEFAULT_MIN_DETECTABLE_EFFECT,
    |                                                                                          ^^^^^^^^^^^^^^^^ E501
717 | …         max_loss_threshold=exp_model.max_loss_threshold,
718 | …     )
    |

gal_friday/model_lifecycle/experiment_manager.py:722:100: E501 Line too long (112 > 99)
    |
721 | …     # Load performance data (repo returns dict)
722 | …     # This part might need adjustment if VariantPerformance objects are stored/retrieved differently
    |                                                                                          ^^^^^^^^^^^^^ E501
723 | …     perf_data = await self.experiment_repo.get_experiment_performance(uuid.UUID(str(exp_model.experiment_id))) # Convert SQLAlchemy…
    |

gal_friday/model_lifecycle/experiment_manager.py:723:100: E501 Line too long (148 > 99)
    |
721 | …
722 | …Performance objects are stored/retrieved differently
723 | …xperiment_performance(uuid.UUID(str(exp_model.experiment_id))) # Convert SQLAlchemy UUID
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
724 | …
725 | …using VariantPerformance in memory)
    |

gal_friday/model_lifecycle/experiment_manager.py:731:100: E501 Line too long (108 > 99)
    |
729 |                 for variant_name, metrics in perf_data.items():
730 |                     # Use previously hexed IDs
731 |                     model_id_for_variant = control_id_hex if variant_name == "control" else treatment_id_hex
    |                                                                                                    ^^^^^^^^^ E501
732 |                     vp = VariantPerformance(model_id=model_id_for_variant, variant_name=variant_name)
733 |                     vp.sample_count = metrics.get("sample_count", 0)
    |

gal_friday/model_lifecycle/experiment_manager.py:732:100: E501 Line too long (101 > 99)
    |
730 |                     # Use previously hexed IDs
731 |                     model_id_for_variant = control_id_hex if variant_name == "control" else treatment_id_hex
732 |                     vp = VariantPerformance(model_id=model_id_for_variant, variant_name=variant_name)
    |                                                                                                    ^^ E501
733 |                     vp.sample_count = metrics.get("sample_count", 0)
734 |                     vp.correct_predictions = metrics.get("correct_predictions", 0)
    |

gal_friday/model_lifecycle/experiment_manager.py:735:100: E501 Line too long (110 > 99)
    |
733 |                     vp.sample_count = metrics.get("sample_count", 0)
734 |                     vp.correct_predictions = metrics.get("correct_predictions", 0)
735 |                     vp.predictions_made = vp.sample_count # Assuming one prediction per sample for this metric
    |                                                                                                    ^^^^^^^^^^^ E501
736 |                     vp.signals_generated = metrics.get("signals_generated", 0)
737 |                     vp.total_return = metrics.get("total_return", Decimal(0))
    |

gal_friday/model_lifecycle/experiment_manager.py:758:100: E501 Line too long (112 > 99)
    |
756 |         if experiment_id not in self.active_experiments:
757 |             # Try to load from database
758 |             exp_data = await self.experiment_repo.get_experiment(uuid.UUID(experiment_id)) # Convert str to UUID
    |                                                                                                    ^^^^^^^^^^^^^ E501
759 |             if not exp_data:
760 |                 return {"error": "Experiment not found"}
    |

gal_friday/model_lifecycle/registry.py:20:36: TC002 Move third-party import `sqlalchemy.ext.asyncio.AsyncSession` into a type-checking block
   |
18 | import numpy.typing as npt
19 | from sklearn.base import BaseEstimator
20 | from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker  # Added
   |                                    ^^^^^^^^^^^^ TC002
21 |
22 | # from gal_friday.dal.base import BaseEntity # BaseEntity is removed
   |
   = help: Move into type-checking block

gal_friday/model_lifecycle/registry.py:20:50: TC002 Move third-party import `sqlalchemy.ext.asyncio.async_sessionmaker` into a type-checking block
   |
18 | import numpy.typing as npt
19 | from sklearn.base import BaseEstimator
20 | from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker  # Added
   |                                                  ^^^^^^^^^^^^^^^^^^ TC002
21 |
22 | # from gal_friday.dal.base import BaseEntity # BaseEntity is removed
   |
   = help: Move into type-checking block

gal_friday/model_lifecycle/registry.py:23:65: TC001 Move application import `gal_friday.dal.models.model_version.ModelVersion` into a type-checking block
   |
22 | # from gal_friday.dal.base import BaseEntity # BaseEntity is removed
23 | from gal_friday.dal.models.model_version import ModelVersion as ModelVersionModel
   |                                                                 ^^^^^^^^^^^^^^^^^ TC001
24 | from gal_friday.dal.repositories.model_repository import ModelRepository  # Keep for instantiation
   |
   = help: Move into type-checking block

gal_friday/model_lifecycle/registry.py:29:100: E501 Line too long (103 > 99)
   |
27 |     from gal_friday.config_manager import ConfigManager
28 |
29 |     # from gal_friday.dal.repositories.model_repository import ModelRepository # Already imported above
   |                                                                                                    ^^^^ E501
30 |     from gal_friday.logger_service import LoggerService
31 |     from gal_friday.utils.secrets_manager import SecretsManager
   |

gal_friday/model_lifecycle/registry.py:354:100: E501 Line too long (100 > 99)
    |
352 |                     "training_data_start", "training_data_end",
353 |                 ]:
354 |                     if metadata_dict.get(date_field) and isinstance(metadata_dict[date_field], str):
    |                                                                                                    ^ E501
355 |                         dt_obj = datetime.fromisoformat(str(metadata_dict[date_field]))
356 |                         if dt_obj.tzinfo is None: # Make timezone aware
    |

gal_friday/model_lifecycle/registry.py:403:100: E501 Line too long (100 > 99)
    |
402 |         # Storage configuration
403 |         self.storage_path = Path(self.config_manager.get("model_registry.storage_path", "./models"))
    |                                                                                                    ^ E501
404 |         self.storage_path.mkdir(parents=True, exist_ok=True)
    |

gal_friday/model_lifecycle/registry.py:407:100: E501 Line too long (104 > 99)
    |
406 |         # Cloud storage backend (optional)
407 |         self.use_cloud_storage = self.config_manager.get_bool("model_registry.use_cloud_storage", False)
    |                                                                                                    ^^^^^ E501
408 |         self.cloud_storage = None
409 |         if self.use_cloud_storage:
    |

gal_friday/model_lifecycle/registry.py:520:15: D102 Missing docstring in public method
    |
518 |             raise
519 |
520 |     async def get_model(
    |               ^^^^^^^^^ D102
521 |         self,
522 |         model_name: str,
    |

gal_friday/model_lifecycle/registry.py:530:28: E701 Multiple statements on one line (colon)
    |
528 |             if version:
529 |                 versions = await self.model_repo.get_model_versions_by_name(model_name, version)
530 |                 if versions: model_version_model = versions[0]
    |                            ^ E701
531 |             elif stage:
532 |                 stages = await self.model_repo.get_model_versions_by_stage(model_name, stage.value)
    |

gal_friday/model_lifecycle/registry.py:533:26: E701 Multiple statements on one line (colon)
    |
531 |             elif stage:
532 |                 stages = await self.model_repo.get_model_versions_by_stage(model_name, stage.value)
533 |                 if stages: model_version_model = stages[0]
    |                          ^ E701
534 |             else:
535 |                 model_version_model = await self.model_repo.get_latest_model_version_by_name(model_name)
    |

gal_friday/model_lifecycle/registry.py:535:100: E501 Line too long (104 > 99)
    |
533 |                 if stages: model_version_model = stages[0]
534 |             else:
535 |                 model_version_model = await self.model_repo.get_latest_model_version_by_name(model_name)
    |                                                                                                    ^^^^^ E501
536 |
537 |             if not model_version_model:
    |

gal_friday/model_lifecycle/registry.py:538:100: E501 Line too long (101 > 99)
    |
537 |             if not model_version_model:
538 |                 raise ValueError(f"Model not found: {model_name} (version={version}, stage={stage})")
    |                                                                                                    ^^ E501
539 |
540 |             metadata_dto = self._model_version_to_metadata_dto(model_version_model)
    |

gal_friday/model_lifecycle/registry.py:542:100: E501 Line too long (127 > 99)
    |
540 |             metadata_dto = self._model_version_to_metadata_dto(model_version_model)
541 |
542 |             deployments = await self.model_repo.get_deployments_for_model_version(uuid.UUID(str(model_version_model.model_id)))
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
543 |             metadata_dto.deployment_history = [
544 |                 {
    |

gal_friday/model_lifecycle/registry.py:574:15: D102 Missing docstring in public method
    |
572 |             raise
573 |
574 |     async def list_models(
    |               ^^^^^^^^^^^ D102
575 |         self,
576 |         model_name: str | None = None,
    |

gal_friday/model_lifecycle/registry.py:585:15: D102 Missing docstring in public method
    |
583 |         return [self._model_version_to_metadata_dto(mvm) for mvm in model_version_models]
584 |
585 |     async def get_all_models(self) -> list[ModelMetadata]:
    |               ^^^^^^^^^^^^^^ D102
586 |         model_version_models = await self.model_repo.list_all_model_versions()
587 |         return [self._model_version_to_metadata_dto(mvm) for mvm in model_version_models]
    |

gal_friday/model_lifecycle/registry.py:589:15: D102 Missing docstring in public method
    |
587 |         return [self._model_version_to_metadata_dto(mvm) for mvm in model_version_models]
588 |
589 |     async def get_model_count(
    |               ^^^^^^^^^^^^^^^ D102
590 |         self,
591 |         stage: ModelStage | None = None,
    |

gal_friday/model_lifecycle/registry.py:593:100: E501 Line too long (105 > 99)
    |
591 |         stage: ModelStage | None = None,
592 |     ) -> int:
593 |         models_list = await self.model_repo.list_all_model_versions(stage=stage.value if stage else None)
    |                                                                                                    ^^^^^^ E501
594 |         return len(models_list)
    |

gal_friday/model_lifecycle/registry.py:596:15: D102 Missing docstring in public method
    |
594 |         return len(models_list)
595 |
596 |     async def promote_model(
    |               ^^^^^^^^^^^^^ D102
597 |         self,
598 |         model_id_str: str,
    |

gal_friday/model_lifecycle/registry.py:608:100: E501 Line too long (107 > 99)
    |
606 |                 raise ValueError(f"Model not found: {model_id_str}")
607 |
608 |             from_stage = ModelStage(model_version.stage) if model_version.stage else ModelStage.DEVELOPMENT
    |                                                                                                    ^^^^^^^^ E501
609 |
610 |             if not self._is_valid_promotion(from_stage, to_stage):
    |

gal_friday/model_lifecycle/registry.py:616:100: E501 Line too long (111 > 99)
    |
615 |             if to_stage == ModelStage.PRODUCTION:
616 |                 active_prod_deployments = await self.model_repo.get_active_deployment(model_version.model_name)
    |                                                                                                    ^^^^^^^^^^^^ E501
617 |                 if active_prod_deployments and active_prod_deployments.model_id != model_uuid:
618 |                     await self.model_repo.update_model_version_stage(
    |

gal_friday/model_lifecycle/registry.py:644:15: D102 Missing docstring in public method
    |
642 |             raise
643 |
644 |     async def delete_model(
    |               ^^^^^^^^^^^^ D102
645 |         self,
646 |         model_id: str,
    |

gal_friday/model_lifecycle/registry.py:653:100: E501 Line too long (115 > 99)
    |
651 |             model_version = await self.model_repo.get_model_version(model_uuid)
652 |             if not model_version:
653 |                 self.logger.warning(f"Model not found for deletion: {model_id}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^ E501
654 |                 return False
    |

gal_friday/model_lifecycle/registry.py:656:100: E501 Line too long (110 > 99)
    |
654 |                 return False
655 |
656 |             current_stage = ModelStage(model_version.stage) if model_version.stage else ModelStage.DEVELOPMENT
    |                                                                                                    ^^^^^^^^^^^ E501
657 |
658 |             if current_stage == ModelStage.PRODUCTION and not force:
    |

gal_friday/model_lifecycle/registry.py:659:100: E501 Line too long (115 > 99)
    |
658 |             if current_stage == ModelStage.PRODUCTION and not force:
659 |                 raise ValueError("Cannot delete/archive active production model without force=True. Demote first.")
    |                                                                                                    ^^^^^^^^^^^^^^^^ E501
660 |
661 |             updated_model = await self.model_repo.update_model_version_stage(
    |

gal_friday/model_lifecycle/registry.py:666:100: E501 Line too long (108 > 99)
    |
665 |             if not updated_model:
666 |                  self.logger.error(f"Failed to archive model {model_id}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^ E501
667 |                  return False
    |

gal_friday/model_lifecycle/registry.py:669:100: E501 Line too long (127 > 99)
    |
667 |                  return False
668 |
669 |             if self.config_manager.get_bool("model_registry.delete_archived_artifacts", False) and model_version.artifact_path:
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
670 |                 artifact_path = Path(model_version.artifact_path)
671 |                 if artifact_path.exists() and artifact_path.is_dir():
    |

gal_friday/model_lifecycle/registry.py:674:100: E501 Line too long (152 > 99)
    |
672 | …
673 | …
674 | …acts for archived model {model_id} at {artifact_path}", source_module=self._source_module)
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
675 | …
676 | …ifacts for model {model_id} at {artifact_path}: {e}", source_module=self._source_module)
    |

gal_friday/model_lifecycle/registry.py:676:100: E501 Line too long (150 > 99)
    |
674 | …facts for archived model {model_id} at {artifact_path}", source_module=self._source_module)
675 | …
676 | …tifacts for model {model_id} at {artifact_path}: {e}", source_module=self._source_module)
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
677 | …
678 | …
    |

gal_friday/model_lifecycle/registry.py:692:30: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
690 |         try:
691 |             parts = list(map(int, current_version_str.split(".")))
692 |             if len(parts) == 3:
    |                              ^ PLR2004
693 |                 parts[2] += 1
694 |                 return ".".join(map(str, parts))
    |

gal_friday/model_lifecycle/registry.py:742:100: E501 Line too long (141 > 99)
    |
740 | …
741 | …
742 | …ot a UUID instance: {type(model_id_uuid)} for model_name {model_version.model_name}"
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
743 | …lf._source_module)
744 | …
    |

gal_friday/model_lifecycle/registry.py:747:100: E501 Line too long (122 > 99)
    |
746 |         # Ensure created_at and training_completed_at are timezone-aware (UTC)
747 |         created_at_utc = model_version.created_at.replace(tzinfo=UTC if model_version.created_at.tzinfo is None else None)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^ E501
748 |         training_completed_at_utc = None
749 |         if model_version.training_completed_at:
    |

gal_friday/model_lifecycle/registry.py:763:100: E501 Line too long (101 > 99)
    |
761 |             created_at=created_at_utc,
762 |             training_completed_at=training_completed_at_utc,
763 |             stage=ModelStage(model_version.stage) if model_version.stage else ModelStage.DEVELOPMENT,
    |                                                                                                    ^^ E501
764 |             status=ModelStatus.READY,
765 |             metrics=model_version.metrics or {},
    |

gal_friday/model_lifecycle/retraining_pipeline.py:587:100: E501 Line too long (100 > 99)
    |
585 |         # Check repository
586 |         if self.retraining_repository:
587 |             return await self.retraining_repository.get_job(uuid.UUID(job_id)) # Convert str to UUID
    |                                                                                                    ^ E501
588 |
589 |         return None
    |

gal_friday/models/__init__.py:1:1: D104 Missing docstring in public package
gal_friday/models/base.py:1:1: D100 Missing docstring in public module
gal_friday/models/configuration.py:1:1: D100 Missing docstring in public module
gal_friday/models/configuration.py:12:7: D101 Missing docstring in public class
   |
12 | class Configuration(Base):
   |       ^^^^^^^^^^^^^ D101
13 |     __tablename__ = "configurations"
   |

gal_friday/models/configuration.py:18:100: E501 Line too long (102 > 99)
   |
16 |     config_hash = Column(String(64), unique=True, nullable=False, index=True)
17 |     config_content = Column(JSON, nullable=False)
18 |     loaded_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), index=True)
   |                                                                                                    ^^^ E501
19 |     is_active = Column(Boolean, nullable=False, default=True)
   |

gal_friday/models/configuration.py:21:9: D105 Missing docstring in magic method
   |
19 |     is_active = Column(Boolean, nullable=False, default=True)
20 |
21 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
22 |         return (
23 |             f"<Configuration(config_pk={self.config_pk}, config_hash='{self.config_hash}', "
   |

gal_friday/models/configuration.py:34:9: F841 Local variable `event_data` is assigned to but never used
   |
32 |         # from gal_friday.core.events import LogEvent
33 |
34 |         event_data = {
   |         ^^^^^^^^^^ F841
35 |             "source_module": self.__class__.__name__,
36 |             "event_id": uuid.uuid4(),
   |
   = help: Remove assignment to unused variable `event_data`

gal_friday/models/configuration.py:39:100: E501 Line too long (105 > 99)
   |
37 |             "timestamp": datetime.utcnow(),
38 |             "level": "INFO", # Or some other appropriate level
39 |             "message": f"Configuration accessed/processed: PK={self.config_pk}, Hash={self.config_hash}",
   |                                                                                                    ^^^^^^ E501
40 |             "context": {
41 |                 "config_pk": self.config_pk,
   |

gal_friday/models/configuration.py:63:100: E501 Line too long (102 > 99)
   |
61 |             timestamp=datetime.utcnow(),
62 |             level="INFO",  # Or some other appropriate level
63 |             message=f"Configuration accessed/processed: PK={self.config_pk}, Hash={self.config_hash}",
   |                                                                                                    ^^^ E501
64 |             context={
65 |                 "config_pk": self.config_pk,
   |

gal_friday/models/fill.py:1:1: D100 Missing docstring in public module
gal_friday/models/fill.py:20:7: D101 Missing docstring in public class
   |
20 | class Fill(Base):
   |       ^^^^ D101
21 |     __tablename__ = "fills"
   |

gal_friday/models/fill.py:25:100: E501 Line too long (109 > 99)
   |
23 |     fill_pk: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
24 |     fill_id: Mapped[str | None] = mapped_column(String(64), nullable=True)  # Exchange fill ID
25 |     order_pk: Mapped[int] = mapped_column(Integer, ForeignKey("orders.order_pk"), nullable=False, index=True)
   |                                                                                                    ^^^^^^^^^^ E501
26 |     exchange_order_id: Mapped[str | None] = mapped_column(String(64), index=True, nullable=True) # From Order, denormalized for easier…
   |

gal_friday/models/fill.py:26:100: E501 Line too long (140 > 99)
   |
24 | …4), nullable=True)  # Exchange fill ID
25 | …gnKey("orders.order_pk"), nullable=False, index=True)
26 | …n(String(64), index=True, nullable=True) # From Order, denormalized for easier query
   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
27 | …
28 | …, nullable=False)
   |

gal_friday/models/fill.py:35:100: E501 Line too long (103 > 99)
   |
33 |     commission: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False)
34 |     commission_asset: Mapped[str] = mapped_column(String(16), nullable=False)
35 |     liquidity_type: Mapped[str | None] = mapped_column(String(10), nullable=True)  # 'MAKER' or 'TAKER'
   |                                                                                                    ^^^^ E501
36 |     filled_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True) # Changed to Mapped[datetime]
   |

gal_friday/models/fill.py:36:100: E501 Line too long (130 > 99)
   |
34 |     commission_asset: Mapped[str] = mapped_column(String(16), nullable=False)
35 |     liquidity_type: Mapped[str | None] = mapped_column(String(10), nullable=True)  # 'MAKER' or 'TAKER'
36 |     filled_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True) # Changed to Mapped[datetime]
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
37 |
38 |     # Relationships
   |

gal_friday/models/fill.py:46:9: D105 Missing docstring in magic method
   |
44 |     )
45 |
46 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
47 |         return (
48 |             f"<Fill(fill_pk={self.fill_pk}, fill_id='{self.fill_id}', order_pk={self.order_pk}, "
   |

gal_friday/models/fill.py:54:100: E501 Line too long (104 > 99)
   |
52 |     def to_event(self) -> "ExecutionReportEvent": # Added to_event with type hints
53 |         """Converts the Fill object to an ExecutionReportEvent."""
54 |         # Imports needed for ExecutionReportEvent. Assuming they are or will be available in the module.
   |                                                                                                    ^^^^^ E501
55 |         # from decimal import Decimal # Already imported via sqlalchemy Numeric
56 |         # import uuid # For event_id and signal_id
   |

gal_friday/models/fill.py:71:100: E501 Line too long (114 > 99)
   |
70 |         # Simulating access to related order for some fields:
71 |         order_exchange_order_id = self.exchange_order_id or (self.order.exchange_order_id if self.order else None)
   |                                                                                                    ^^^^^^^^^^^^^^^ E501
72 |         order_trading_pair = self.trading_pair or (self.order.trading_pair if self.order else "UNKNOWN/UNKNOWN")
73 |         order_exchange = self.exchange or (self.order.exchange if self.order else "UNKNOWN_EXCHANGE")
   |

gal_friday/models/fill.py:72:100: E501 Line too long (112 > 99)
   |
70 |         # Simulating access to related order for some fields:
71 |         order_exchange_order_id = self.exchange_order_id or (self.order.exchange_order_id if self.order else None)
72 |         order_trading_pair = self.trading_pair or (self.order.trading_pair if self.order else "UNKNOWN/UNKNOWN")
   |                                                                                                    ^^^^^^^^^^^^^ E501
73 |         order_exchange = self.exchange or (self.order.exchange if self.order else "UNKNOWN_EXCHANGE")
74 |         order_side = self.side or (self.order.side if self.order else "UNKNOWN_SIDE")
   |

gal_friday/models/fill.py:73:100: E501 Line too long (101 > 99)
   |
71 |         order_exchange_order_id = self.exchange_order_id or (self.order.exchange_order_id if self.order else None)
72 |         order_trading_pair = self.trading_pair or (self.order.trading_pair if self.order else "UNKNOWN/UNKNOWN")
73 |         order_exchange = self.exchange or (self.order.exchange if self.order else "UNKNOWN_EXCHANGE")
   |                                                                                                    ^^ E501
74 |         order_side = self.side or (self.order.side if self.order else "UNKNOWN_SIDE")
75 |         order_type = self.order.order_type if self.order else "MARKET" # Default if no order
   |

gal_friday/models/fill.py:77:100: E501 Line too long (127 > 99)
   |
75 |         order_type = self.order.order_type if self.order else "MARKET" # Default if no order
76 |         quantity_ordered = self.order.quantity if self.order else self.quantity_filled # Default
77 |         signal_id_val = self.order.signal_id if self.order and hasattr(self.order, "signal_id") else uuid.uuid4() # Placeholder
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
78 |
79 |         _client_order_id_from_order = self.order.client_order_id if self.order and hasattr(self.order, "client_order_id") else None
   |

gal_friday/models/fill.py:79:100: E501 Line too long (131 > 99)
   |
77 |         signal_id_val = self.order.signal_id if self.order and hasattr(self.order, "signal_id") else uuid.uuid4() # Placeholder
78 |
79 |         _client_order_id_from_order = self.order.client_order_id if self.order and hasattr(self.order, "client_order_id") else None
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
80 |         client_order_id_val = str(_client_order_id_from_order) if _client_order_id_from_order is not None else None
   |

gal_friday/models/fill.py:80:100: E501 Line too long (115 > 99)
   |
79 |         _client_order_id_from_order = self.order.client_order_id if self.order and hasattr(self.order, "client_order_id") else None
80 |         client_order_id_val = str(_client_order_id_from_order) if _client_order_id_from_order is not None else None
   |                                                                                                    ^^^^^^^^^^^^^^^^ E501
   |

gal_friday/models/fill.py:102:100: E501 Line too long (109 > 99)
    |
100 |         # Since I cannot import it here directly within this tool call easily,
101 |         # I will construct a dictionary that matches its likely structure.
102 |         # In a real scenario, I'd ensure the import `from gal_friday.core.events import ExecutionReportEvent`
    |                                                                                                    ^^^^^^^^^^ E501
103 |         # is at the top of the file.
    |

gal_friday/models/fill.py:116:100: E501 Line too long (179 > 99)
    |
114 | …
115 | …
116 | … "exchange_order_id" to "ExecutionReportEvent" has incompatible type "str | Any | None"; expected "str"
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
117 | …
118 | …rity should be adjusted.
    |

gal_friday/models/fill.py:118:100: E501 Line too long (100 > 99)
    |
116 | …     # This addresses: gal_friday/models/fill.py:144: error: Argument "exchange_order_id" to "ExecutionReportEvent" has incompatible…
117 | …     # We need to provide a string if the event strictly expects one.
118 | …     # Alternatively, the event definition or this model's data integrity should be adjusted.
    |                                                                                              ^ E501
119 | …     # For now, using a placeholder:
120 | …     final_exchange_order_id = "UNKNOWN_FILL_EXCH_ORD_ID" # Placeholder
    |

gal_friday/models/fill.py:122:9: F841 Local variable `event_data` is assigned to but never used
    |
120 |             final_exchange_order_id = "UNKNOWN_FILL_EXCH_ORD_ID" # Placeholder
121 |
122 |         event_data = {
    |         ^^^^^^^^^^ F841
123 |             "source_module": self.__class__.__name__,
124 |             "event_id": uuid.uuid4(),
    |
    = help: Remove assignment to unused variable `event_data`

gal_friday/models/fill.py:137:100: E501 Line too long (111 > 99)
    |
135 |             "quantity_filled": self.quantity_filled,
136 |             "average_fill_price": self.fill_price, # Fill price is the average for this fill
137 |             "limit_price": self.order.limit_price if self.order and self.order.order_type == "LIMIT" else None,
    |                                                                                                    ^^^^^^^^^^^^ E501
138 |             "stop_price": self.order.stop_price if self.order and "STOP" in self.order.order_type else None,
139 |             "commission": self.commission,
    |

gal_friday/models/fill.py:138:100: E501 Line too long (108 > 99)
    |
136 |             "average_fill_price": self.fill_price, # Fill price is the average for this fill
137 |             "limit_price": self.order.limit_price if self.order and self.order.order_type == "LIMIT" else None,
138 |             "stop_price": self.order.stop_price if self.order and "STOP" in self.order.order_type else None,
    |                                                                                                    ^^^^^^^^^ E501
139 |             "commission": self.commission,
140 |             "commission_asset": self.commission_asset,
    |

gal_friday/models/fill.py:168:100: E501 Line too long (131 > 99)
    |
166 |             side=cast("str", order_side),
167 |             quantity_ordered=quantity_ordered, # Ensure this is Decimal
168 |             signal_id=cast("uuid.UUID", signal_id_val), # Was Column[UUID] | UUID, event expects UUID | None. Value is always UUID.
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
169 |             client_order_id=client_order_id_val,
170 |             quantity_filled=self.quantity_filled, # Ensure this is Decimal
    |

gal_friday/models/fill.py:172:100: E501 Line too long (134 > 99)
    |
170 |             quantity_filled=self.quantity_filled, # Ensure this is Decimal
171 |             average_fill_price=self.fill_price, # Ensure this is Decimal
172 |             limit_price=cast("Decimal | None", (self.order.limit_price if self.order and self.order.order_type == "LIMIT" else None)),
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
173 |             stop_price=cast("Decimal | None", (self.order.stop_price if self.order and "STOP" in self.order.order_type else None)),
174 |             commission=self.commission, # Ensure Decimal or None
    |

gal_friday/models/fill.py:173:100: E501 Line too long (131 > 99)
    |
171 |             average_fill_price=self.fill_price, # Ensure this is Decimal
172 |             limit_price=cast("Decimal | None", (self.order.limit_price if self.order and self.order.order_type == "LIMIT" else None)),
173 |             stop_price=cast("Decimal | None", (self.order.stop_price if self.order and "STOP" in self.order.order_type else None)),
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
174 |             commission=self.commission, # Ensure Decimal or None
175 |             commission_asset=self.commission_asset,
    |

gal_friday/models/log.py:1:1: D100 Missing docstring in public module
gal_friday/models/log.py:20:7: D101 Missing docstring in public class
   |
20 | class Log(Base):
   |       ^^^ D101
21 |     __tablename__ = "logs"
   |

gal_friday/models/log.py:23:100: E501 Line too long (111 > 99)
   |
21 |     __tablename__ = "logs"
22 |
23 |     id: Mapped[int] = mapped_column(BigInteger, primary_key=True, index=True) # Assuming BigInteger maps to int
   |                                                                                                    ^^^^^^^^^^^^ E501
24 |     timestamp: Mapped[datetime.datetime] = mapped_column(TIMESTAMP(timezone=True), nullable=False, default=datetime.datetime.utcnow)
25 |     logger_name: Mapped[str] = mapped_column(String(255), nullable=False)
   |

gal_friday/models/log.py:24:100: E501 Line too long (132 > 99)
   |
23 |     id: Mapped[int] = mapped_column(BigInteger, primary_key=True, index=True) # Assuming BigInteger maps to int
24 |     timestamp: Mapped[datetime.datetime] = mapped_column(TIMESTAMP(timezone=True), nullable=False, default=datetime.datetime.utcnow)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
25 |     logger_name: Mapped[str] = mapped_column(String(255), nullable=False)
26 |     level_name: Mapped[str] = mapped_column(String(50), nullable=False)
   |

gal_friday/models/log.py:29:100: E501 Line too long (100 > 99)
   |
27 |     level_no: Mapped[int] = mapped_column(Integer, nullable=False) # Added Mapped for consistency
28 |     message: Mapped[str] = mapped_column(Text, nullable=False) # Changed to Mapped[str]
29 |     pathname: Mapped[str | None] = mapped_column(Text, nullable=True) # Added Mapped for consistency
   |                                                                                                    ^ E501
30 |     filename: Mapped[str | None] = mapped_column(String(255), nullable=True) # Added Mapped for consistency
31 |     lineno: Mapped[int | None] = mapped_column(Integer, nullable=True)
   |

gal_friday/models/log.py:30:100: E501 Line too long (107 > 99)
   |
28 |     message: Mapped[str] = mapped_column(Text, nullable=False) # Changed to Mapped[str]
29 |     pathname: Mapped[str | None] = mapped_column(Text, nullable=True) # Added Mapped for consistency
30 |     filename: Mapped[str | None] = mapped_column(String(255), nullable=True) # Added Mapped for consistency
   |                                                                                                    ^^^^^^^^ E501
31 |     lineno: Mapped[int | None] = mapped_column(Integer, nullable=True)
32 |     func_name: Mapped[str | None] = mapped_column(String(255), nullable=True)
   |

gal_friday/models/log.py:33:100: E501 Line too long (113 > 99)
   |
31 |     lineno: Mapped[int | None] = mapped_column(Integer, nullable=True)
32 |     func_name: Mapped[str | None] = mapped_column(String(255), nullable=True)
33 |     context_json: Mapped[dict[str, Any] | None] = mapped_column(JSON, nullable=True) # Assuming JSON maps to dict
   |                                                                                                    ^^^^^^^^^^^^^^ E501
34 |     exception_text: Mapped[str | None] = mapped_column(Text, nullable=True)
   |

gal_friday/models/log.py:36:9: D105 Missing docstring in magic method
   |
34 |     exception_text: Mapped[str | None] = mapped_column(Text, nullable=True)
35 |
36 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
37 |         return f"<Log(id={self.id}, name='{self.logger_name}', level='{self.level_name}')>"
   |

gal_friday/models/order.py:1:1: D100 Missing docstring in public module
gal_friday/models/order.py:15:7: D101 Missing docstring in public class
   |
15 | class Order(Base):
   |       ^^^^^ D101
16 |     __tablename__ = "orders"
   |

gal_friday/models/order.py:19:100: E501 Line too long (112 > 99)
   |
18 |     order_pk = Column(Integer, primary_key=True, autoincrement=True)
19 |     client_order_id = Column(PG_UUID(as_uuid=True), unique=True, nullable=False, default=uuid.uuid4, index=True)
   |                                                                                                    ^^^^^^^^^^^^^ E501
20 |     exchange_order_id = Column(String(64), unique=True, nullable=True, index=True)
21 |     signal_id = Column(PG_UUID(as_uuid=True), ForeignKey("signals.signal_id"), index=True)
   |

gal_friday/models/order.py:33:100: E501 Line too long (103 > 99)
   |
31 |     error_message = Column(Text, nullable=True)
32 |
33 |     created_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), index=True)
   |                                                                                                    ^^^^ E501
34 |     submitted_at = Column(DateTime(timezone=True), nullable=True)
35 |     last_updated_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), onupdate=func.now())
   |

gal_friday/models/order.py:35:100: E501 Line too long (117 > 99)
   |
33 |     created_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), index=True)
34 |     submitted_at = Column(DateTime(timezone=True), nullable=True)
35 |     last_updated_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), onupdate=func.now())
   |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
36 |
37 |     # Relationships
   |

gal_friday/models/order.py:42:100: E501 Line too long (126 > 99)
   |
41 |     # Relationships to Trade table (will be fully defined in Trade model via back_populates)
42 |     # trade_entry: Mapped[Optional["Trade"]] = relationship(foreign_keys="Trade.entry_order_pk", back_populates="entry_order")
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
43 |     # trade_exit: Mapped[Optional["Trade"]] = relationship(foreign_keys="Trade.exit_order_pk", back_populates="exit_order")
44 |     # The above lines are commented out as they are defined by the 'Trade' model's back_populates
   |

gal_friday/models/order.py:43:100: E501 Line too long (123 > 99)
   |
41 |     # Relationships to Trade table (will be fully defined in Trade model via back_populates)
42 |     # trade_entry: Mapped[Optional["Trade"]] = relationship(foreign_keys="Trade.entry_order_pk", back_populates="entry_order")
43 |     # trade_exit: Mapped[Optional["Trade"]] = relationship(foreign_keys="Trade.exit_order_pk", back_populates="exit_order")
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
44 |     # The above lines are commented out as they are defined by the 'Trade' model's back_populates
   |

gal_friday/models/order.py:46:9: D105 Missing docstring in magic method
   |
44 |     # The above lines are commented out as they are defined by the 'Trade' model's back_populates
45 |
46 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
47 |         return (
48 |             f"<Order(order_pk={self.order_pk}, client_order_id={self.client_order_id}, "
   |

gal_friday/models/order.py:71:100: E501 Line too long (104 > 99)
   |
69 |                 total_fill_value += fill.quantity_filled * fill.fill_price
70 |                 commission_val += fill.commission
71 |                 if commission_asset_val is None and fill.commission_asset: # Take first commission asset
   |                                                                                                    ^^^^^ E501
72 |                     commission_asset_val = fill.commission_asset
   |

gal_friday/models/order.py:74:100: E501 Line too long (108 > 99)
   |
72 |                     commission_asset_val = fill.commission_asset
73 |
74 |         average_fill_price_val = total_fill_value / quantity_filled_val if quantity_filled_val > 0 else None
   |                                                                                                    ^^^^^^^^^ E501
75 |
76 |         event_data = {
   |

gal_friday/models/order.py:95:100: E501 Line too long (139 > 99)
   |
93 | …
94 | …
95 | …or self.submitted_at or self.created_at, # Best available exchange-related timestamp
   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
96 | …
97 | …
   |

gal_friday/models/portfolio_snapshot.py:1:1: D100 Missing docstring in public module
gal_friday/models/portfolio_snapshot.py:9:7: D101 Missing docstring in public class
   |
 9 | class PortfolioSnapshot(Base):
   |       ^^^^^^^^^^^^^^^^^ D101
10 |     __tablename__ = "portfolio_snapshots"
   |

gal_friday/models/portfolio_snapshot.py:13:100: E501 Line too long (124 > 99)
   |
12 |     snapshot_pk = Column(Integer, primary_key=True, autoincrement=True)
13 |     snapshot_timestamp = Column(DateTime(timezone=True), unique=True, nullable=False, server_default=func.now(), index=True)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
14 |     total_equity = Column(Numeric(18, 8), nullable=False)
15 |     available_balance = Column(Numeric(18, 8), nullable=False)
   |

gal_friday/models/portfolio_snapshot.py:22:9: D105 Missing docstring in magic method
   |
20 |     positions = Column(JSON, nullable=False)  # JSON object detailing current positions
21 |
22 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
23 |         return (
24 |             f"<PortfolioSnapshot(snapshot_pk={self.snapshot_pk}, "
   |

gal_friday/models/portfolio_snapshot.py:32:100: E501 Line too long (107 > 99)
   |
30 |         return {
31 |             "snapshot_pk": self.snapshot_pk,
32 |             "snapshot_timestamp": self.snapshot_timestamp.isoformat() if self.snapshot_timestamp else None,
   |                                                                                                    ^^^^^^^^ E501
33 |             "total_equity": float(self.total_equity) if self.total_equity is not None else None,
34 |             "available_balance": float(self.available_balance) if self.available_balance is not None else None,
   |

gal_friday/models/portfolio_snapshot.py:34:100: E501 Line too long (111 > 99)
   |
32 |             "snapshot_timestamp": self.snapshot_timestamp.isoformat() if self.snapshot_timestamp else None,
33 |             "total_equity": float(self.total_equity) if self.total_equity is not None else None,
34 |             "available_balance": float(self.available_balance) if self.available_balance is not None else None,
   |                                                                                                    ^^^^^^^^^^^^ E501
35 |             "total_exposure_pct": self.total_exposure_pct,
36 |             "daily_drawdown_pct": self.daily_drawdown_pct,
   |

gal_friday/models/portfolio_snapshot.py:39:100: E501 Line too long (100 > 99)
   |
37 |             "weekly_drawdown_pct": self.weekly_drawdown_pct,
38 |             "total_drawdown_pct": self.total_drawdown_pct,
39 |             "positions": self.positions, # Assuming positions is already a dict or JSON-serializable
   |                                                                                                    ^ E501
40 |         }
   |

gal_friday/models/signal.py:1:1: D100 Missing docstring in public module
gal_friday/models/signal.py:20:7: D101 Missing docstring in public class
   |
20 | class Signal(Base):
   |       ^^^^^^ D101
21 |     __tablename__ = "signals"
   |

gal_friday/models/signal.py:23:100: E501 Line too long (109 > 99)
   |
21 |     __tablename__ = "signals"
22 |
23 |     signal_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
   |                                                                                                    ^^^^^^^^^^ E501
24 |     trading_pair: Mapped[str] = mapped_column(String(16), nullable=False)
25 |     exchange: Mapped[str] = mapped_column(String(32), nullable=False)
   |

gal_friday/models/signal.py:32:100: E501 Line too long (103 > 99)
   |
30 |     proposed_sl_price: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False)
31 |     proposed_tp_price: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False)
32 |     prediction_event_id: Mapped[uuid.UUID | None] = mapped_column(PG_UUID(as_uuid=True), nullable=True)
   |                                                                                                    ^^^^ E501
33 |     prediction_value: Mapped[float | None] = mapped_column(Float, nullable=True)
34 |     status: Mapped[str] = mapped_column(String(10), nullable=False)
   |

gal_friday/models/signal.py:37:100: E501 Line too long (128 > 99)
   |
35 |     rejection_reason: Mapped[str | None] = mapped_column(Text, nullable=True)
36 |     risk_check_details: Mapped[dict[str, Any] | None] = mapped_column(JSON, nullable=True)
37 |     created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, server_default=func.now(), index=True)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
38 |
39 |     # Relationships
   |

gal_friday/models/signal.py:40:100: E501 Line too long (112 > 99)
   |
39 |     # Relationships
40 |     orders: Mapped[list["Order"]] = relationship("Order", back_populates="signal", cascade="all, delete-orphan")
   |                                                                                                    ^^^^^^^^^^^^^ E501
41 |     trade: Mapped["Trade | None"] = relationship("Trade", back_populates="signal", uselist=False, cascade="all, delete-orphan")
   |

gal_friday/models/signal.py:41:100: E501 Line too long (127 > 99)
   |
39 |     # Relationships
40 |     orders: Mapped[list["Order"]] = relationship("Order", back_populates="signal", cascade="all, delete-orphan")
41 |     trade: Mapped["Trade | None"] = relationship("Trade", back_populates="signal", uselist=False, cascade="all, delete-orphan")
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
42 |
43 |     def __repr__(self) -> str: # Added -> str
   |

gal_friday/models/signal.py:43:9: D105 Missing docstring in magic method
   |
41 |     trade: Mapped["Trade | None"] = relationship("Trade", back_populates="signal", uselist=False, cascade="all, delete-orphan")
42 |
43 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
44 |         return (
45 |             f"<Signal(signal_id={self.signal_id}, trading_pair='{self.trading_pair}', "
   |

gal_friday/models/signal.py:57:9: F841 Local variable `event_data` is assigned to but never used
   |
55 |         # from gal_friday.core.events import TradeSignalProposedEvent
56 |
57 |         event_data = {
   |         ^^^^^^^^^^ F841
58 |             "source_module": self.__class__.__name__,
59 |             "event_id": uuid.uuid4(), # New event ID
   |
   = help: Remove assignment to unused variable `event_data`

gal_friday/models/signal.py:72:100: E501 Line too long (117 > 99)
   |
70 |             "triggering_prediction_event_id": self.prediction_event_id,
71 |             # 'triggering_prediction' field in event might need more data if available
72 |             "triggering_prediction": {"value": self.prediction_value} if self.prediction_value is not None else None,
   |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
73 |         }
74 |         # In a real implementation:
   |

gal_friday/models/signal.py:96:100: E501 Line too long (114 > 99)
   |
94 |             strategy_id=self.strategy_id,
95 |             triggering_prediction_event_id=self.prediction_event_id, # Ensure uuid.UUID | None
96 |             triggering_prediction={"value": self.prediction_value} if self.prediction_value is not None else None,
   |                                                                                                    ^^^^^^^^^^^^^^^ E501
97 |         )
   |

gal_friday/models/system_log.py:1:1: D100 Missing docstring in public module
gal_friday/models/system_log.py:15:7: D101 Missing docstring in public class
   |
15 | class SystemLog(Base):
   |       ^^^^^^^^^ D101
16 |     __tablename__ = "system_logs"
   |

gal_friday/models/system_log.py:19:100: E501 Line too long (131 > 99)
   |
18 |     log_pk: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
19 |     log_timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, server_default=func.now(), index=True)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
20 |     source_module: Mapped[str] = mapped_column(String(64), nullable=False, index=True)
21 |     log_level: Mapped[str] = mapped_column(String(10), nullable=False, index=True)
   |

gal_friday/models/system_log.py:31:100: E501 Line too long (112 > 99)
   |
29 |     exception_type: Mapped[str | None] = mapped_column(Text, nullable=True)
30 |     stack_trace: Mapped[str | None] = mapped_column(Text, nullable=True)
31 |     # Using generic JSON for broader compatibility, can be switched to JSONB if PG-specific features are needed.
   |                                                                                                    ^^^^^^^^^^^^^ E501
32 |     context: Mapped[dict[str, Any] | None] = mapped_column(JSON, nullable=True)
   |

gal_friday/models/system_log.py:34:9: D105 Missing docstring in magic method
   |
32 |     context: Mapped[dict[str, Any] | None] = mapped_column(JSON, nullable=True)
33 |
34 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
35 |         return (
36 |             f"<SystemLog(log_pk={self.log_pk}, source_module='{self.source_module}', "
   |

gal_friday/models/system_log.py:65:100: E501 Line too long (101 > 99)
   |
63 |             source_module=self.source_module,
64 |             event_id=uuid.uuid4(),  # Generate a new UUID for this event instance
65 |             timestamp=self.log_timestamp or datetime.utcnow(), # Use the log's timestamp if available
   |                                                                                                    ^^ E501
66 |             level=self.log_level.upper(),
67 |             message=self.message,
   |

gal_friday/models/trade.py:1:1: D100 Missing docstring in public module
gal_friday/models/trade.py:19:7: D101 Missing docstring in public class
   |
19 | class Trade(Base):
   |       ^^^^^ D101
20 |     __tablename__ = "trades"
   |

gal_friday/models/trade.py:23:100: E501 Line too long (131 > 99)
   |
22 | …primary_key=True, autoincrement=True)
23 | …UUID(as_uuid=True), unique=True, nullable=False, default=uuid.uuid4, index=True)
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
24 | …lumn(PG_UUID(as_uuid=True), ForeignKey("signals.signal_id"), index=True, nullable=True)
   |

gal_friday/models/trade.py:24:100: E501 Line too long (138 > 99)
   |
22 | …ary_key=True, autoincrement=True)
23 | …(as_uuid=True), unique=True, nullable=False, default=uuid.uuid4, index=True)
24 | …(PG_UUID(as_uuid=True), ForeignKey("signals.signal_id"), index=True, nullable=True)
   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
25 | …
26 | …), nullable=False, index=True)
   |

gal_friday/models/trade.py:31:100: E501 Line too long (109 > 99)
   |
29 |     side: Mapped[str] = mapped_column(String(4), nullable=False)  # Side of the entry
30 |
31 |     entry_order_pk: Mapped[int | None] = mapped_column(Integer, ForeignKey("orders.order_pk"), nullable=True)
   |                                                                                                    ^^^^^^^^^^ E501
32 |     exit_order_pk: Mapped[int | None] = mapped_column(Integer, ForeignKey("orders.order_pk"), nullable=True)
   |

gal_friday/models/trade.py:32:100: E501 Line too long (108 > 99)
   |
31 |     entry_order_pk: Mapped[int | None] = mapped_column(Integer, ForeignKey("orders.order_pk"), nullable=True)
32 |     exit_order_pk: Mapped[int | None] = mapped_column(Integer, ForeignKey("orders.order_pk"), nullable=True)
   |                                                                                                    ^^^^^^^^^ E501
33 |
34 |     entry_timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True)
   |

gal_friday/models/trade.py:34:100: E501 Line too long (106 > 99)
   |
32 |     exit_order_pk: Mapped[int | None] = mapped_column(Integer, ForeignKey("orders.order_pk"), nullable=True)
33 |
34 |     entry_timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True)
   |                                                                                                    ^^^^^^^ E501
35 |     exit_timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True)
   |

gal_friday/models/trade.py:35:100: E501 Line too long (105 > 99)
   |
34 |     entry_timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True)
35 |     exit_timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True)
   |                                                                                                    ^^^^^^ E501
36 |
37 |     quantity: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False)
   |

gal_friday/models/trade.py:40:100: E501 Line too long (115 > 99)
   |
38 |     average_entry_price: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False)
39 |     average_exit_price: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False)
40 |     total_commission: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False) # Should be in quote currency
   |                                                                                                    ^^^^^^^^^^^^^^^^ E501
41 |     realized_pnl: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False) # Quote currency
42 |     realized_pnl_pct: Mapped[float] = mapped_column(Float, nullable=False)
   |

gal_friday/models/trade.py:51:100: E501 Line too long (100 > 99)
   |
49 |         "Order",
50 |         foreign_keys=[entry_order_pk],
51 |         backref="trade_as_entry", # Use backref to avoid conflict if Order directly relates to Trade
   |                                                                                                    ^ E501
52 |         # Or ensure Order.trade_entry uses a specific foreign_keys if defined there
53 |     )
   |

gal_friday/models/trade.py:60:9: D105 Missing docstring in magic method
   |
58 |     )
59 |
60 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
61 |         return (
62 |             f"<Trade(trade_id={self.trade_id}, trading_pair='{self.trading_pair}', "
   |

gal_friday/models/trade.py:67:9: D205 1 blank line required between summary line and description
   |
66 |       def to_event(self) -> "MarketDataTradeEvent": # Added to_event with type hints
67 | /         """Converts the Trade object to a MarketDataTradeEvent.
68 | |         This represents the entry part of the trade as a market event.
69 | |         Exit would be a separate event if needed.
70 | |         """
   | |___________^ D205
71 |           # Assuming MarketDataTradeEvent is importable from gal_friday.core.events
72 |           # import uuid # Already imported
   |
   = help: Insert single blank line

gal_friday/models/trade.py:80:100: E501 Line too long (103 > 99)
   |
78 |         # A MarketDataTradeEvent typically represents a single execution (fill).
79 |         # Here, we can represent the entry fill as an example.
80 |         # A more complete system might generate two MarketDataTradeEvents (one for entry, one for exit)
   |                                                                                                    ^^^^ E501
81 |         # or use a different event type for completed round-trip trades.
   |

gal_friday/models/trade.py:83:9: F841 Local variable `event_data` is assigned to but never used
   |
81 |         # or use a different event type for completed round-trip trades.
82 |
83 |         event_data = {
   |         ^^^^^^^^^^ F841
84 |             "source_module": self.__class__.__name__,
85 |             "event_id": uuid.uuid4(), # New event ID for this specific event
   |
   = help: Remove assignment to unused variable `event_data`

gal_friday/monitoring/alerting_system.py:597:17: S101 Use of `assert` detected
    |
595 |             if account_sid and auth_token and from_number: # Using individual checks for clarity
596 |                 # Assertions to help mypy confirm the types are strings
597 |                 assert isinstance(account_sid, str), "TWILIO_ACCOUNT_SID must be a non-empty string"
    |                 ^^^^^^ S101
598 |                 assert isinstance(auth_token, str), "TWILIO_AUTH_TOKEN must be a non-empty string"
599 |                 assert isinstance(from_number, str), "alerting.sms.from_number must be a non-empty string"
    |

gal_friday/monitoring/alerting_system.py:597:100: E501 Line too long (100 > 99)
    |
595 |             if account_sid and auth_token and from_number: # Using individual checks for clarity
596 |                 # Assertions to help mypy confirm the types are strings
597 |                 assert isinstance(account_sid, str), "TWILIO_ACCOUNT_SID must be a non-empty string"
    |                                                                                                    ^ E501
598 |                 assert isinstance(auth_token, str), "TWILIO_AUTH_TOKEN must be a non-empty string"
599 |                 assert isinstance(from_number, str), "alerting.sms.from_number must be a non-empty string"
    |

gal_friday/monitoring/alerting_system.py:598:17: S101 Use of `assert` detected
    |
596 |                 # Assertions to help mypy confirm the types are strings
597 |                 assert isinstance(account_sid, str), "TWILIO_ACCOUNT_SID must be a non-empty string"
598 |                 assert isinstance(auth_token, str), "TWILIO_AUTH_TOKEN must be a non-empty string"
    |                 ^^^^^^ S101
599 |                 assert isinstance(from_number, str), "alerting.sms.from_number must be a non-empty string"
    |

gal_friday/monitoring/alerting_system.py:599:17: S101 Use of `assert` detected
    |
597 |                 assert isinstance(account_sid, str), "TWILIO_ACCOUNT_SID must be a non-empty string"
598 |                 assert isinstance(auth_token, str), "TWILIO_AUTH_TOKEN must be a non-empty string"
599 |                 assert isinstance(from_number, str), "alerting.sms.from_number must be a non-empty string"
    |                 ^^^^^^ S101
600 |
601 |                 self.channels[AlertChannel.SMS] = SMSChannel(
    |

gal_friday/monitoring/alerting_system.py:599:100: E501 Line too long (106 > 99)
    |
597 |                 assert isinstance(account_sid, str), "TWILIO_ACCOUNT_SID must be a non-empty string"
598 |                 assert isinstance(auth_token, str), "TWILIO_AUTH_TOKEN must be a non-empty string"
599 |                 assert isinstance(from_number, str), "alerting.sms.from_number must be a non-empty string"
    |                                                                                                    ^^^^^^^ E501
600 |
601 |                 self.channels[AlertChannel.SMS] = SMSChannel(
    |

gal_friday/monitoring/alerting_system.py:611:100: E501 Line too long (107 > 99)
    |
609 |                 self.logger.warning(
610 |                     "SMS alerting enabled but missing one or more required configurations "
611 |                     "(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, or alerting.sms.from_number was empty/None). "
    |                                                                                                    ^^^^^^^^ E501
612 |                     "SMS channel will not be initialized.",
613 |                     source_module=self._source_module,
    |

gal_friday/monitoring/dashboard_pages.py:25:100: E501 Line too long (118 > 99)
   |
23 |     DASHBOARD_CSS = """
24 |     <style>
25 |     body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background: #f5f7fa; }
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
26 |     .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
27 |     .header { background: #2c3e50; color: white; padding: 1rem; border-radius: 5px 5px 0 0; margin-bottom: 1rem; }
   |

gal_friday/monitoring/dashboard_pages.py:27:100: E501 Line too long (114 > 99)
   |
25 |     body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background: #f5f7fa; }
26 |     .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
27 |     .header { background: #2c3e50; color: white; padding: 1rem; border-radius: 5px 5px 0 0; margin-bottom: 1rem; }
   |                                                                                                    ^^^^^^^^^^^^^^^ E501
28 |     .card { background: white; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 1rem; padding: 1rem; }
29 |     .row { display: flex; flex-wrap: wrap; margin: 0 -10px; }
   |

gal_friday/monitoring/dashboard_pages.py:28:100: E501 Line too long (127 > 99)
   |
26 |     .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
27 |     .header { background: #2c3e50; color: white; padding: 1rem; border-radius: 5px 5px 0 0; margin-bottom: 1rem; }
28 |     .card { background: white; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 1rem; padding: 1rem; }
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
29 |     .row { display: flex; flex-wrap: wrap; margin: 0 -10px; }
30 |     .col { flex: 1; padding: 0 10px; min-width: 250px; }
   |

gal_friday/monitoring/dashboard_pages.py:38:100: E501 Line too long (110 > 99)
   |
36 |     .alert-warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
37 |     .alert-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
38 |     .metric-card { padding: 15px; border-radius: 4px; margin-bottom: 10px; color: white; text-align: center; }
   |                                                                                                    ^^^^^^^^^^^ E501
39 |     .metric-card h3 { margin-top: 0; }
40 |     .metric-card p { font-size: 1.8rem; font-weight: bold; margin: 10px 0; }
   |

gal_friday/monitoring/dashboard_pages.py:46:100: E501 Line too long (125 > 99)
   |
44 | …
45 | …
46 | …hite; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; }
   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
47 | …00; text-align: center; white-space: nowrap; vertical-align: middle; user-select: none; border: 1px solid transparent; padding: .375r…
48 | …: #4e73df; border-color: #4e73df; }
   |

gal_friday/monitoring/dashboard_pages.py:47:100: E501 Line too long (379 > 99)
   |
45 | …
46 | …radius: 3px; cursor: pointer; }
47 | …ertical-align: middle; user-select: none; border: 1px solid transparent; padding: .375rem .75rem; font-size: 1rem; line-height: 1.5; border-radius: .25rem; transition: color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out; }
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
48 | …
49 | …
   |

gal_friday/monitoring/dashboard_pages.py:53:100: E501 Line too long (152 > 99)
   |
51 | …; width: 60px; height: 34px; }
52 | …
53 | …t: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
54 | …26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
55 | …
   |

gal_friday/monitoring/dashboard_pages.py:54:100: E501 Line too long (168 > 99)
   |
52 | …
53 | …ght: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
54 | …dth: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
55 | …
56 | …
   |

gal_friday/monitoring/dashboard_pages.py:313:100: E501 Line too long (132 > 99)
    |
311 |                 </div>
312 |                 <p><strong>Description:</strong> {model.description or 'No description'}</p>
313 |                 <p><strong>Last Updated:</strong> {(model.updated_at.strftime('%Y-%m-%d %H:%M') if model.updated_at else 'N/A')}</p>
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
314 |                 <p><strong>Training Data:</strong> {model.training_data_path or 'N/A'}</p>
315 |                 <p><strong>Pairs:</strong> {
    |

gal_friday/portfolio/funds_manager.py:41:24: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `session_maker`
   |
39 |         self,
40 |         logger_service: LoggerService,
41 |         session_maker: Any, # async_sessionmaker | None = None, for consistency, but unused
   |                        ^^^ ANN401
42 |         valuation_currency: str = "USD",
43 |     ) -> None:
   |

gal_friday/portfolio/funds_manager.py:49:100: E501 Line too long (101 > 99)
   |
47 |         ----
48 |             logger_service: Service for logging.
49 |             session_maker: SQLAlchemy async_sessionmaker (unused in this class, for API consistency).
   |                                                                                                    ^^ E501
50 |             valuation_currency: The currency for overall valuation (default: "USD").
51 |         """
   |

gal_friday/portfolio/position_manager.py:38:100: E501 Line too long (102 > 99)
   |
38 | # PositionInfo dataclass might be replaced by the Position SQLAlchemy model for direct DB interaction.
   |                                                                                                    ^^^ E501
39 | # However, it can still be useful for business logic or as a DTO if its structure differs
40 | # from the DB model or if we want to decouple business logic from DB schema.
   |

gal_friday/portfolio/position_manager.py:44:100: E501 Line too long (106 > 99)
   |
43 | class PositionManager:
44 |     """Manages trading positions, including updates from trades and PnL calculations, using SQLAlchemy."""
   |                                                                                                    ^^^^^^^ E501
45 |
46 |     def __init__(
   |

gal_friday/portfolio/position_manager.py:66:100: E501 Line too long (123 > 99)
   |
64 |         self.config_manager = config_manager
65 |         # self._positions: dict[str, PositionInfo] = {} # In-memory store removed
66 |         self._lock = asyncio.Lock() # Lock can still be useful for critical async operations on a single position if needed
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
67 |
68 |     # The `positions` property and `get_open_positions` will now fetch from DB.
   |

gal_friday/portfolio/position_manager.py:82:100: E501 Line too long (115 > 99)
   |
80 |     async def get_position(self, trading_pair: str) -> PositionModel | None:
81 |         """Get a specific active position by trading_pair from the database."""
82 |         self.logger.debug(f"Fetching position for trading_pair: {trading_pair}", source_module=self._source_module)
   |                                                                                                    ^^^^^^^^^^^^^^^^ E501
83 |         return await self.position_repository.get_position_by_pair(trading_pair)
84 |         # If PositionInfo DTO is still desired:
   |

gal_friday/portfolio/position_manager.py:91:100: E501 Line too long (111 > 99)
   |
89 |         self,
90 |         # initial_positions: dict[str, dict[str, Any]], # This would now be pre-loading DB
91 |         # split_symbol_func: Callable[[str], tuple[str, str]], # Asset splitting can be internal or from config
   |                                                                                                    ^^^^^^^^^^^^ E501
92 |     ) -> None:
93 |         """Initializes positions by loading them from the database.
   |

gal_friday/portfolio/position_manager.py:93:9: D205 1 blank line required between summary line and description
    |
 91 |           # split_symbol_func: Callable[[str], tuple[str, str]], # Asset splitting can be internal or from config
 92 |       ) -> None:
 93 | /         """Initializes positions by loading them from the database.
 94 | |         The concept of initializing from a config dict is replaced by ensuring
 95 | |         positions are correctly populated in the DB, possibly by a seeding process
 96 | |         or by prior application state. This method could verify DB connection
 97 | |         or log current position count.
 98 | |         """
    | |___________^ D205
 99 |           # This method might no longer be needed if positions are purely DB driven.
100 |           # Or, it could be used to load positions from DB into a cache if desired,
    |
    = help: Insert single blank line

gal_friday/portfolio/position_manager.py:180:100: E501 Line too long (130 > 99)
    |
178 |             commission_arg = kwargs.get("commission", Decimal(0))
179 |
180 |             # Ensure required fields are present (those not in _UpdatePositionKwargs or without defaults in _UpdatePositionParams)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
181 |             # 'trading_pair', 'side', 'timestamp', 'trade_id' are required by _UpdatePositionKwargs if total=True,
182 |             # or by _UpdatePositionParams if they have no defaults.
    |

gal_friday/portfolio/position_manager.py:181:100: E501 Line too long (114 > 99)
    |
180 |             # Ensure required fields are present (those not in _UpdatePositionKwargs or without defaults in _UpdatePositionParams)
181 |             # 'trading_pair', 'side', 'timestamp', 'trade_id' are required by _UpdatePositionKwargs if total=True,
    |                                                                                                    ^^^^^^^^^^^^^^^ E501
182 |             # or by _UpdatePositionParams if they have no defaults.
183 |             # Assuming they are always provided as per TypedDict or dataclass requirements.
    |

gal_friday/portfolio/position_manager.py:196:100: E501 Line too long (119 > 99)
    |
194 |                 fee=Decimal(str(fee_arg)) if not isinstance(fee_arg, Decimal) else fee_arg,
195 |                 fee_currency=kwargs.get("fee_currency"),
196 |                 commission=Decimal(str(commission_arg)) if not isinstance(commission_arg, Decimal) else commission_arg,
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
197 |                 commission_asset=kwargs.get("commission_asset"),
198 |             )
    |

gal_friday/portfolio/position_manager.py:200:100: E501 Line too long (138 > 99)
    |
198 | …
199 | …# Added KeyError for direct kwargs access
200 | …update_position_for_trade: {e}", source_module=self._source_module, context=kwargs)
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
201 | …
    |

gal_friday/portfolio/position_manager.py:238:100: E501 Line too long (100 > 99)
    |
237 |         async with self._lock: # Lock to ensure atomic read-modify-write for a given trading_pair
238 |             position_model = await self._get_or_create_db_position(params.trading_pair, params.side)
    |                                                                                                    ^ E501
239 |
240 |             # Trade history is not directly part of the PositionModel in the schema.
    |

gal_friday/portfolio/position_manager.py:254:100: E501 Line too long (104 > 99)
    |
252 |                 # old_value = avg_entry_price * current_quantity
253 |                 # new_value = params.price * params.quantity
254 |                 new_total_cost = (avg_entry_price * current_quantity) + (params.price * params.quantity)
    |                                                                                                    ^^^^^ E501
255 |                 new_quantity = current_quantity + params.quantity
    |

gal_friday/portfolio/position_manager.py:267:100: E501 Line too long (123 > 99)
    |
265 |                 if current_quantity < params.quantity:
266 |                     self.logger.warning(
267 |                         f"Selling {params.quantity} of {params.trading_pair}, but current position is {current_quantity}. "
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
268 |                         "Position will go negative or this represents a short sale opening/extension.",
269 |                         source_module=self._source_module,
    |

gal_friday/portfolio/position_manager.py:268:100: E501 Line too long (103 > 99)
    |
266 |                     self.logger.warning(
267 |                         f"Selling {params.quantity} of {params.trading_pair}, but current position is {current_quantity}. "
268 |                         "Position will go negative or this represents a short sale opening/extension.",
    |                                                                                                    ^^^^ E501
269 |                         source_module=self._source_module,
270 |                     )
    |

gal_friday/portfolio/position_manager.py:274:100: E501 Line too long (110 > 99)
    |
272 |                 # Realized PnL = (sell_price - avg_entry_price) * sell_quantity
273 |                 realized_pnl_trade = (params.price - avg_entry_price) * params.quantity
274 |                 position_model.realized_pnl = (position_model.realized_pnl or Decimal(0)) + realized_pnl_trade
    |                                                                                                    ^^^^^^^^^^^ E501
275 |                 new_quantity = current_quantity - params.quantity
276 |                 position_model.quantity = new_quantity
    |

gal_friday/portfolio/position_manager.py:282:100: E501 Line too long (123 > 99)
    |
280 |                     position_model.is_active = False # Close position if quantity is zero
281 |                     position_model.closed_at = params.timestamp # Record closing time
282 |                 # If new_quantity is < 0 (short position), AEP logic might need adjustment based on strategy for short AEP.
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
283 |                 # Current AEP calculation is simplified for long positions.
    |

gal_friday/portfolio/position_manager.py:286:100: E501 Line too long (106 > 99)
    |
285 |             else: # Should be caught by _validate_trade_params
286 |                 self.logger.error(f"Invalid trade side: {params.side}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^ E501
287 |                 return Decimal(0), None
    |

gal_friday/portfolio/position_manager.py:292:100: E501 Line too long (131 > 99)
    |
291 |             try:
292 |                 updated_pos = await self.position_repository.update(str(position_model.id), position_model.to_dict(exclude={"id"}))
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
293 |                 if not updated_pos: # Should not happen if ID is correct and row exists
294 |                     self.logger.error(f"Failed to update position {position_model.id} in DB.", source_module=self._source_module)
    |

gal_friday/portfolio/position_manager.py:294:100: E501 Line too long (129 > 99)
    |
292 |                 updated_pos = await self.position_repository.update(str(position_model.id), position_model.to_dict(exclude={"id"}))
293 |                 if not updated_pos: # Should not happen if ID is correct and row exists
294 |                     self.logger.error(f"Failed to update position {position_model.id} in DB.", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
295 |                     return realized_pnl_trade, None # Or raise an error
    |

gal_friday/portfolio/position_manager.py:306:100: E501 Line too long (137 > 99)
    |
304 | …
305 | …
306 | …position in DB for {params.trading_pair}: {e}", source_module=self._source_module)
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
307 | …
    |

gal_friday/portfolio/position_manager.py:331:100: E501 Line too long (106 > 99)
    |
330 |     # _get_or_create_position needs to interact with the database now.
331 |     async def _get_or_create_db_position(self, trading_pair: str, side_if_creating: str) -> PositionModel:
    |                                                                                                    ^^^^^^^ E501
332 |         """Get existing active position from DB or create a new one if it doesn't exist."""
333 |         position = await self.position_repository.get_position_by_pair(trading_pair)
    |

gal_friday/portfolio/position_manager.py:336:100: E501 Line too long (161 > 99)
    |
334 | …
335 | …tion? Or new one?
336 | …exists but is inactive. Treating as new for this context.", source_module=self._source_module)
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
337 | …tivate or error?
338 | …ing is inactive.
    |

gal_friday/portfolio/position_manager.py:339:100: E501 Line too long (112 > 99)
    |
337 |                  # This logic might need refinement: should we reactivate or error?
338 |                  # For now, assume we create a new one if the existing is inactive.
339 |                  # This implies `get_position_by_pair` should only return active ones, or this logic handles it.
    |                                                                                                    ^^^^^^^^^^^^^ E501
340 |                  # If `get_position_by_pair` already filters by is_active=True, then this `if` is for a case
341 |                  # where an inactive one was somehow fetched, or if we want to prevent re-opening.
    |

gal_friday/portfolio/position_manager.py:340:100: E501 Line too long (108 > 99)
    |
338 |                  # For now, assume we create a new one if the existing is inactive.
339 |                  # This implies `get_position_by_pair` should only return active ones, or this logic handles it.
340 |                  # If `get_position_by_pair` already filters by is_active=True, then this `if` is for a case
    |                                                                                                    ^^^^^^^^^ E501
341 |                  # where an inactive one was somehow fetched, or if we want to prevent re-opening.
342 |                  # Let's assume get_position_by_pair returns only active.
    |

gal_friday/portfolio/position_manager.py:348:100: E501 Line too long (126 > 99)
    |
347 |         # Position not found or inactive, create a new one
348 |         self.logger.info(f"No active position found for {trading_pair}. Creating new one.", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
349 |
350 |         # Asset splitting logic - assuming it's from config or a utility
    |

gal_friday/portfolio/position_manager.py:357:100: E501 Line too long (106 > 99)
    |
355 |         # Or, if it's a short, it's 'SHORT', if long, it's 'LONG'. This is simplified here.
356 |         # The PositionModel has `side` (LONG/SHORT). A trade has `side` (BUY/SELL).
357 |         # This needs careful mapping. If first trade is BUY, position is LONG. If SELL, position is SHORT.
    |                                                                                                    ^^^^^^^ E501
358 |         # The `side_if_creating` argument would be the intended position side (LONG/SHORT).
    |

gal_friday/portfolio/position_manager.py:374:100: E501 Line too long (143 > 99)
    |
372 | …
373 | …ory.create(new_pos_data)
374 | …for {trading_pair} with ID {created_position.id}", source_module=self._source_module)
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
375 | …
376 | …
    |

gal_friday/portfolio/position_manager.py:377:100: E501 Line too long (130 > 99)
    |
375 |             return created_position
376 |         except Exception as e:
377 |             self.logger.exception(f"Error creating new position in DB for {trading_pair}: {e}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
378 |             # Decide on error handling: re-raise, or return a specific error object/None
379 |             raise # Re-raise for now
    |

gal_friday/portfolio/position_manager.py:391:100: E501 Line too long (119 > 99)
    |
390 |         # For all pairs:
391 |         all_positions = await self.position_repository.find_all(filters={"is_active": True}) # Or all, including closed
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
392 |         total_pnl = sum((pos.realized_pnl for pos in all_positions if pos.realized_pnl is not None), Decimal(0))
393 |         return total_pnl
    |

gal_friday/portfolio/position_manager.py:392:100: E501 Line too long (112 > 99)
    |
390 |         # For all pairs:
391 |         all_positions = await self.position_repository.find_all(filters={"is_active": True}) # Or all, including closed
392 |         total_pnl = sum((pos.realized_pnl for pos in all_positions if pos.realized_pnl is not None), Decimal(0))
    |                                                                                                    ^^^^^^^^^^^^^ E501
393 |         return total_pnl
    |

gal_friday/portfolio/position_manager.py:393:16: RET504 Unnecessary assignment to `total_pnl` before `return` statement
    |
391 |         all_positions = await self.position_repository.find_all(filters={"is_active": True}) # Or all, including closed
392 |         total_pnl = sum((pos.realized_pnl for pos in all_positions if pos.realized_pnl is not None), Decimal(0))
393 |         return total_pnl
    |                ^^^^^^^^^ RET504
394 |
395 |     # _TradeRecordParams and _TradeRecordKwargs might be less relevant if TradeInfo is not directly stored with PositionModel
    |
    = help: Remove unnecessary assignment

gal_friday/portfolio/position_manager.py:395:100: E501 Line too long (125 > 99)
    |
393 |         return total_pnl
394 |
395 |     # _TradeRecordParams and _TradeRecordKwargs might be less relevant if TradeInfo is not directly stored with PositionModel
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
396 |     # or if trade recording is handled by a separate TradeRepository.
397 |     # For now, keeping if the internal logic still uses them to construct TradeInfo objects if needed.
    |

gal_friday/portfolio/position_manager.py:397:100: E501 Line too long (102 > 99)
    |
395 |     # _TradeRecordParams and _TradeRecordKwargs might be less relevant if TradeInfo is not directly stored with PositionModel
396 |     # or if trade recording is handled by a separate TradeRepository.
397 |     # For now, keeping if the internal logic still uses them to construct TradeInfo objects if needed.
    |                                                                                                    ^^^ E501
398 |     @dataclass
399 |     class _TradeRecordParams: # Can remain for internal use if TradeInfo objects are constructed
    |

gal_friday/portfolio/reconciliation_service.py:6:29: TC003 Move standard library import `collections.abc.Sequence` into a type-checking block
  |
4 | import contextlib
5 | import uuid
6 | from collections.abc import Sequence  # Added Sequence
  |                             ^^^^^^^^ TC003
7 | from dataclasses import dataclass, field
8 | from datetime import UTC, datetime, timedelta
  |
  = help: Move into type-checking block

gal_friday/portfolio/reconciliation_service.py:145:100: E501 Line too long (108 > 99)
    |
143 |     def __init__(self,
144 |                  config_manager: ConfigManager, # Renamed for clarity
145 |                  portfolio_manager: PortfolioManager, # Stays as is, its internal methods will be refactored
    |                                                                                                    ^^^^^^^^^ E501
146 |                  execution_handler: ExecutionHandler, # Stays as is
147 |                  alerting_system: AlertingSystem, # Renamed for clarity
    |

gal_friday/portfolio/reconciliation_service.py:296:100: E501 Line too long (102 > 99)
    |
294 |             )
295 |             # Attempt to save the failed report
296 |             await self._save_reconciliation_event_and_adjustments(report) # Adjustments might be empty
    |                                                                                                    ^^^ E501
297 |             await self._send_critical_alert(f"Reconciliation failed: {e!s}")
    |

gal_friday/portfolio/reconciliation_service.py:305:100: E501 Line too long (107 > 99)
    |
303 |         try:
304 |             # Get positions from both sources
305 |             # Assuming portfolio_manager.get_all_db_positions() is refactored to return List[PositionModel]
    |                                                                                                    ^^^^^^^^ E501
306 |             internal_positions_models: Sequence[PositionModel] = await self.portfolio_manager.get_all_db_positions() # type: ignore
307 |             exchange_positions_data = await self.execution_handler.get_exchange_positions() # type: ignore
    |

gal_friday/portfolio/reconciliation_service.py:306:100: E501 Line too long (116 > 99)
    |
304 |             # Get positions from both sources
305 |             # Assuming portfolio_manager.get_all_db_positions() is refactored to return List[PositionModel]
306 |             internal_positions_models: Sequence[PositionModel] = await self.portfolio_manager.get_all_db_positions() # type: ignore
    |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
307 |             exchange_positions_data = await self.execution_handler.get_exchange_positions() # type: ignore
    |

gal_friday/portfolio/reconciliation_service.py:309:100: E501 Line too long (100 > 99)
    |
307 |             exchange_positions_data = await self.execution_handler.get_exchange_positions() # type: ignore
308 |
309 |             report.positions_checked = len(internal_positions_models) + len(exchange_positions_data)
    |                                                                                                    ^ E501
310 |
311 |             # Create position maps
    |

gal_friday/portfolio/reconciliation_service.py:348:100: E501 Line too long (116 > 99)
    |
346 |                     report.position_discrepancies.append(discrepancy)
347 |
348 |                     if self._can_auto_correct(exchange_qty): # Check if the exchange quantity itself is small enough
    |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
349 |                         await self._add_missing_db_position(pair, exchange_pos_data, report)
350 |                     else:
    |

gal_friday/portfolio/reconciliation_service.py:373:100: E501 Line too long (103 > 99)
    |
372 |                         if self._can_auto_correct(qty_diff):
373 |                             await self._adjust_db_position_quantity(internal_pos, exchange_qty, report)
    |                                                                                                    ^^^^ E501
374 |                         else:
375 |                             report.manual_review_required.append({
    |

gal_friday/portfolio/reconciliation_service.py:381:100: E501 Line too long (108 > 99)
    |
379 |                             })
380 |         except Exception as e:
381 |             self.logger.exception("Error during position reconciliation", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^ E501
382 |             report.error_messages.append(f"Position reconciliation error: {e!s}")
383 |             raise
    |

gal_friday/portfolio/reconciliation_service.py:442:100: E501 Line too long (104 > 99)
    |
441 |                 # Check if order exists in our system using OrderRepository
442 |                 tracked_order_model = await self.order_repository.find_by_exchange_id(exchange_order_id)
    |                                                                                                    ^^^^^ E501
443 |
444 |                 if not tracked_order_model:
    |

gal_friday/portfolio/reconciliation_service.py:457:100: E501 Line too long (105 > 99)
    |
455 |                         })
456 |         except Exception as e:
457 |             self.logger.exception("Error during order reconciliation", source_module=self._source_module)
    |                                                                                                    ^^^^^^ E501
458 |             report.error_messages.append(f"Order reconciliation error: {e!s}")
459 |             raise
    |

gal_friday/portfolio/reconciliation_service.py:537:100: E501 Line too long (104 > 99)
    |
535 |                     )
536 |
537 |                 # Recording of adjustments will be handled by _save_reconciliation_event_and_adjustments
    |                                                                                                    ^^^^^ E501
538 |             except Exception as e:
539 |                 self.logger.error(
    |

gal_friday/portfolio/reconciliation_service.py:548:100: E501 Line too long (119 > 99)
    |
546 |                 )
547 |
548 |     async def _add_missing_db_position(self, pair: str, exchange_pos_data: dict, report: ReconciliationReport) -> None:
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
549 |         """Marks for auto-correction: Add position that exists on exchange but not internally.
550 |         Actual DB write happens via portfolio_manager or directly if this service owns position creation logic.
    |

gal_friday/portfolio/reconciliation_service.py:549:9: D205 1 blank line required between summary line and description
    |
548 |       async def _add_missing_db_position(self, pair: str, exchange_pos_data: dict, report: ReconciliationReport) -> None:
549 | /         """Marks for auto-correction: Add position that exists on exchange but not internally.
550 | |         Actual DB write happens via portfolio_manager or directly if this service owns position creation logic.
551 | |         For now, this method prepares the 'correction' dict for the report.
552 | |         """
    | |___________^ D205
553 |           # This method now just prepares the correction for the report.
554 |           # The actual DB creation should be handled by PortfolioManager or a dedicated method
    |
    = help: Insert single blank line

gal_friday/portfolio/reconciliation_service.py:550:100: E501 Line too long (111 > 99)
    |
548 |     async def _add_missing_db_position(self, pair: str, exchange_pos_data: dict, report: ReconciliationReport) -> None:
549 |         """Marks for auto-correction: Add position that exists on exchange but not internally.
550 |         Actual DB write happens via portfolio_manager or directly if this service owns position creation logic.
    |                                                                                                    ^^^^^^^^^^^^ E501
551 |         For now, this method prepares the 'correction' dict for the report.
552 |         """
    |

gal_friday/portfolio/reconciliation_service.py:556:100: E501 Line too long (104 > 99)
    |
554 |         # The actual DB creation should be handled by PortfolioManager or a dedicated method
555 |         # that uses self.position_repository.create()
556 |         # For this refactor, we assume `portfolio_manager.create_new_position_from_exchange_data` exists
    |                                                                                                    ^^^^^ E501
557 |         # or this is noted for `_apply_auto_corrections`.
    |

gal_friday/portfolio/reconciliation_service.py:570:100: E501 Line too long (117 > 99)
    |
568 |         }
569 |         report.auto_corrections.append(correction_data)
570 |         self.logger.info(f"Marked missing position for {pair} for auto-creation.", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
    |

gal_friday/portfolio/reconciliation_service.py:574:100: E501 Line too long (101 > 99)
    |
573 |     async def _adjust_db_position_quantity(
574 |         self, internal_pos_model: PositionModel, exchange_qty: Decimal, report: ReconciliationReport,
    |                                                                                                    ^^ E501
575 |     ) -> None:
576 |         """Marks for auto-correction: Adjust internal position quantity to match exchange."""
    |

gal_friday/portfolio/reconciliation_service.py:588:100: E501 Line too long (138 > 99)
    |
586 | …
587 | …
588 | …s_model.trading_pair} for quantity adjustment.", source_module=self._source_module)
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
589 | …
590 | …action is via PortfolioManager
    |

gal_friday/portfolio/reconciliation_service.py:591:100: E501 Line too long (112 > 99)
    |
590 |     async def _adjust_balance( # This method's DB interaction is via PortfolioManager
591 |         self, currency: str, internal_balance: Decimal, exchange_balance: Decimal, report: ReconciliationReport,
    |                                                                                                    ^^^^^^^^^^^^^ E501
592 |     ) -> None:
593 |         """Marks for auto-correction: Adjust internal balance to match exchange."""
    |

gal_friday/portfolio/reconciliation_service.py:605:100: E501 Line too long (109 > 99)
    |
603 |         }
604 |         report.auto_corrections.append(correction_data)
605 |         self.logger.info(f"Marked balance for {currency} for adjustment.", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^ E501
606 |
607 |     async def _save_reconciliation_event_and_adjustments(self, report: ReconciliationReport) -> None:
    |

gal_friday/portfolio/reconciliation_service.py:607:100: E501 Line too long (101 > 99)
    |
605 |         self.logger.info(f"Marked balance for {currency} for adjustment.", source_module=self._source_module)
606 |
607 |     async def _save_reconciliation_event_and_adjustments(self, report: ReconciliationReport) -> None:
    |                                                                                                    ^^ E501
608 |         """Saves the main reconciliation event and all its adjustments to the database."""
609 |         try:
    |

gal_friday/portfolio/reconciliation_service.py:619:100: E501 Line too long (123 > 99)
    |
617 |                 "manual_review_required": len(report.manual_review_required),
618 |                 "report": report.to_dict(), # Full report as JSON
619 |                 "duration_seconds": Decimal(str(report.duration_seconds)) if report.duration_seconds is not None else None,
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
620 |             }
621 |             created_event = await self.reconciliation_repository.save_reconciliation_event(event_data)
    |

gal_friday/portfolio/reconciliation_service.py:621:100: E501 Line too long (102 > 99)
    |
619 |                 "duration_seconds": Decimal(str(report.duration_seconds)) if report.duration_seconds is not None else None,
620 |             }
621 |             created_event = await self.reconciliation_repository.save_reconciliation_event(event_data)
    |                                                                                                    ^^^ E501
622 |             self.logger.info(f"Saved reconciliation event {created_event.reconciliation_id}", source_module=self._source_module)
    |

gal_friday/portfolio/reconciliation_service.py:622:100: E501 Line too long (128 > 99)
    |
620 |             }
621 |             created_event = await self.reconciliation_repository.save_reconciliation_event(event_data)
622 |             self.logger.info(f"Saved reconciliation event {created_event.reconciliation_id}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
623 |
624 |             # Save all adjustments (auto-corrections and those needing manual review if they are stored)
    |

gal_friday/portfolio/reconciliation_service.py:624:100: E501 Line too long (104 > 99)
    |
622 |             self.logger.info(f"Saved reconciliation event {created_event.reconciliation_id}", source_module=self._source_module)
623 |
624 |             # Save all adjustments (auto-corrections and those needing manual review if they are stored)
    |                                                                                                    ^^^^^ E501
625 |             # For now, only saving auto_corrections as explicit adjustments.
626 |             for adj_data in report.auto_corrections:
    |

gal_friday/portfolio/reconciliation_service.py:630:100: E501 Line too long (101 > 99)
    |
628 |                 adjustment_to_save = {
629 |                     "reconciliation_id": created_event.reconciliation_id,
630 |                     "trading_pair": adj_data.get("pair") or adj_data.get("currency", "UNKNOWN_PAIR"),
    |                                                                                                    ^^ E501
631 |                     "adjustment_type": adj_data.get("adjustment_type", "UNKNOWN_ADJUSTMENT"),
632 |                     "old_value": adj_data.get("old_value"), # Should be Decimal or None
    |

gal_friday/portfolio/reconciliation_service.py:643:100: E501 Line too long (160 > 99)
    |
642 | …_adjustment(adjustment_to_save)
643 | …} adjustments for event {created_event.reconciliation_id}", source_module=self._source_module)
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
644 | …
645 | …
    |

gal_friday/portfolio/reconciliation_service.py:646:100: E501 Line too long (161 > 99)
    |
645 | …
646 | …ort/adjustments for event {report.reconciliation_id}: {e}", source_module=self._source_module)
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
647 | …
    |

gal_friday/portfolio/reconciliation_service.py:721:100: E501 Line too long (118 > 99)
    |
719 |             # Ideally, repo methods return SQLAlchemy models.
720 |             # Get the most recent reconciliation event (limit to 1 day for efficiency)
721 |             recent_events = await self.reconciliation_repository.get_recent_reconciliation_events(days=1, status=None)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
722 |             latest_event_model = recent_events[0] if recent_events else None
723 |             if latest_event_model:
    |

gal_friday/portfolio/reconciliation_service.py:723:13: SIM108 Use ternary operator `last_report_data = latest_event_model.report if latest_event_model else None` instead of `if`-`else`-block
    |
721 |               recent_events = await self.reconciliation_repository.get_recent_reconciliation_events(days=1, status=None)
722 |               latest_event_model = recent_events[0] if recent_events else None
723 | /             if latest_event_model:
724 | |                 # Convert model to dict for status, or use a Pydantic model constructed from it
725 | |                 last_report_data = latest_event_model.report # The JSONB field
726 | |             else:
727 | |                 last_report_data = None
    | |_______________________________________^ SIM108
728 |           else:
729 |               last_report_data = None
    |
    = help: Replace `if`-`else`-block with `last_report_data = latest_event_model.report if latest_event_model else None`

gal_friday/portfolio/reconciliation_service.py:729:13: F841 Local variable `last_report_data` is assigned to but never used
    |
727 |                 last_report_data = None
728 |         else:
729 |             last_report_data = None
    |             ^^^^^^^^^^^^^^^^ F841
730 |
731 |         last_run = (
    |
    = help: Remove assignment to unused variable `last_report_data`

gal_friday/portfolio_manager.py:74:9: D417 Missing argument description in the docstring for `__init__`: `session_maker`
   |
72 |     """
73 |
74 |     def __init__(
   |         ^^^^^^^^ D417
75 |         self,
76 |         *,  # Force keyword arguments for better readability
   |

gal_friday/portfolio_manager.py:105:100: E501 Line too long (135 > 99)
    |
103 | …
104 | …ce, self.valuation_currency)
105 | …_service, session_maker, config_manager) # Added session_maker and config_manager
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
106 | …
107 | …
    |

gal_friday/portfolio_manager.py:147:13: F841 Local variable `initial_positions_config` is assigned to but never used
    |
145 |             await self.funds_manager.initialize_funds(initial_capital)
146 |
147 |             initial_positions_config = self.config_manager.get("portfolio.initial_positions", {})
    |             ^^^^^^^^^^^^^^^^^^^^^^^^ F841
148 |             await self.position_manager.initialize_positions() # Removed arguments
    |
    = help: Remove assignment to unused variable `initial_positions_config`

gal_friday/portfolio_manager.py:164:100: E501 Line too long (125 > 99)
    |
162 |             self.logger.info(
163 |                 "Initial Positions: %s",
164 |                 {p: {"qty": str(info.quantity), "aep": str(info.entry_price)} for p, info in self._cached_positions.items()},
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
165 |                 source_module=self._source_module,
166 |             )
    |

gal_friday/portfolio_manager.py:399:100: E501 Line too long (114 > 99)
    |
397 |                     else: # Position closed or inactive
398 |                         self._cached_positions.pop(updated_pos_model.trading_pair, None)
399 |             elif event.order_status in ["FILLED", "PARTIALLY_FILLED"]: # If update failed but should have happened
    |                                                                                                    ^^^^^^^^^^^^^^^ E501
400 |                 self.logger.warning(
401 |                     f"Position model for {event.trading_pair} was not updated in cache after trade {event.exchange_order_id}.",
    |

gal_friday/portfolio_manager.py:401:100: E501 Line too long (127 > 99)
    |
399 |             elif event.order_status in ["FILLED", "PARTIALLY_FILLED"]: # If update failed but should have happened
400 |                 self.logger.warning(
401 |                     f"Position model for {event.trading_pair} was not updated in cache after trade {event.exchange_order_id}.",
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
402 |                     source_module=self._source_module,
403 |                 )
    |

gal_friday/portfolio_manager.py:551:100: E501 Line too long (104 > 99)
    |
549 |         }
550 |         positions_str = {}
551 |         # Create a shallow copy for safe iteration, as self._cached_positions might be updated elsewhere
    |                                                                                                    ^^^^^ E501
552 |         # by async methods. This is a synchronous method.
553 |         cached_positions_copy = self._cached_positions.copy()
    |

gal_friday/portfolio_manager.py:600:100: E501 Line too long (106 > 99)
    |
599 |         positions_dict = {}
600 |         # Create a shallow copy for safe iteration if self._cached_positions can be modified by async code
    |                                                                                                    ^^^^^^^ E501
601 |         cached_positions_copy = self._cached_positions.copy()
602 |         for pair, pos_model in cached_positions_copy.items(): # Use cache
    |

gal_friday/portfolio_manager.py:612:100: E501 Line too long (101 > 99)
    |
610 |                     market_value = pos_model.quantity * latest_price
611 |                     if (
612 |                         pos_model.entry_price > 0 or pos_model.quantity != 0 # Changed to entry_price
    |                                                                                                    ^^ E501
613 |                     ):  # Avoid PNL calc on zero avg price unless qty exists
614 |                         unrealized_pnl = (
    |

gal_friday/portfolio_manager.py:628:100: E501 Line too long (100 > 99)
    |
626 |                     "unrealized_pnl": str(unrealized_pnl) if unrealized_pnl is not None else None,
627 |                     "realized_pnl": str(pos_model.realized_pnl),
628 |                     "trade_count": 0, # PositionModel does not have trade_history, using placeholder
    |                                                                                                    ^ E501
629 |                 }
    |

gal_friday/portfolio_manager.py:697:100: E501 Line too long (102 > 99)
    |
695 |             List of historical trades for the specified pair
696 |         """
697 |         position_model = await self.position_manager.get_position(pair)  # Await and get PositionModel
    |                                                                                                    ^^^ E501
698 |         if not position_model:
699 |             return []
    |

gal_friday/portfolio_manager.py:702:100: E501 Line too long (100 > 99)
    |
701 |         # PositionModel does not have a direct 'trade_history' attribute.
702 |         # This would need to be fetched from a TradeRepository based on position_id or trading_pair.
    |                                                                                                    ^ E501
703 |         # For now, returning empty list to fix attr-defined.
704 |         self.logger.debug( # Changed to debug as this is an expected temporary state
    |

gal_friday/portfolio_manager.py:705:100: E501 Line too long (111 > 99)
    |
703 |         # For now, returning empty list to fix attr-defined.
704 |         self.logger.debug( # Changed to debug as this is an expected temporary state
705 |             f"Trade history retrieval for PositionModel is not fully implemented. Returning empty for {pair}.",
    |                                                                                                    ^^^^^^^^^^^^ E501
706 |             source_module=self._source_module,
707 |         )
    |

gal_friday/portfolio_manager.py:708:100: E501 Line too long (101 > 99)
    |
706 |             source_module=self._source_module,
707 |         )
708 |         actual_trade_history: list[Any] = [] # Placeholder, assuming trades would be dicts or objects
    |                                                                                                    ^^ E501
709 |
710 |         result = []
    |

gal_friday/portfolio_manager.py:712:100: E501 Line too long (111 > 99)
    |
710 |         result = []
711 |         for trade in actual_trade_history: # This loop won't run with placeholder
712 |             # Assuming 'trade' object would have timestamp, side, quantity, price, commission, commission_asset
    |                                                                                                    ^^^^^^^^^^^^ E501
713 |             result.append(
714 |                 {
    |

gal_friday/portfolio_manager.py:733:100: E501 Line too long (104 > 99)
    |
731 |         """
732 |         # Since we're making this method async and the position manager likely has an async method
733 |         # we can properly await it. If position_manager.get_open_positions is sync, we'd need to adjust.
    |                                                                                                    ^^^^^ E501
734 |         # Based on the file structure, this is likely async
735 |         return list(await self.position_manager.get_open_positions())
    |

gal_friday/predictors/lstm_predictor.py:54:1: E402 Module level import not at top of file
   |
54 | import torch  # Add import for torch.Tensor
   | ^^^^^^^^^^^^ E402
   |

gal_friday/predictors/xgboost_predictor.py:311:9: PLR0911 Too many return statements (7 > 6)
    |
310 |     @classmethod
311 |     def run_inference_in_process(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
312 |         cls,
313 |         model_id: str,
    |

gal_friday/predictors/xgboost_predictor.py:311:9: PLR0912 Too many branches (14 > 12)
    |
310 |     @classmethod
311 |     def run_inference_in_process(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
312 |         cls,
313 |         model_id: str,
    |

gal_friday/predictors/xgboost_predictor.py:354:100: E501 Line too long (103 > 99)
    |
352 |             # Logically, if load_model_error_info was empty, model should be a Booster instance.
353 |             if model is None:
354 |                 error_msg = "Model loading failed silently (model is None but no error info returned)."
    |                                                                                                    ^^^^ E501
355 |                 logger.error(f"{error_msg} (model_id: {model_id})")
356 |                 result["error"] = error_msg
    |

gal_friday/predictors/xgboost_predictor.py:386:100: E501 Line too long (100 > 99)
    |
384 |             # Now check feature_prep_error_info regardless of which path was taken
385 |             if feature_prep_error_info: # This is now well-defined
386 |                 result["error"] = feature_prep_error_info.get("error", "Failed to prepare features")
    |                                                                                                    ^ E501
387 |                 return result
    |

gal_friday/predictors/xgboost_predictor.py:391:100: E501 Line too long (100 > 99)
    |
389 |             if processed_features is None:
390 |                 # This case should ideally be covered by feature_prep_error_info having an error.
391 |                 # If _prepare_features can return (None, {}) without error, this guard is important.
    |                                                                                                    ^ E501
392 |                 if not result.get("error"): # Check if error was already set by a previous step
393 |                     result["error"] = "Feature preparation returned None without explicit error info."
    |

gal_friday/predictors/xgboost_predictor.py:393:100: E501 Line too long (102 > 99)
    |
391 |                 # If _prepare_features can return (None, {}) without error, this guard is important.
392 |                 if not result.get("error"): # Check if error was already set by a previous step
393 |                     result["error"] = "Feature preparation returned None without explicit error info."
    |                                                                                                    ^^^ E501
394 |                 return result
    |

gal_friday/risk_manager.py:447:15: C901 `_stage1_initial_validation_and_price_rounding` is too complex (16 > 15)
    |
445 |         # self._validate_config() # Call will be made at the end of _load_config
446 |
447 |     async def _stage1_initial_validation_and_price_rounding(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
448 |         self, ctx: Stage1Context,
449 |     ) -> tuple[Decimal | None, Decimal, Decimal | None]:
    |

gal_friday/risk_manager.py:447:15: PLR0912 Too many branches (17 > 12)
    |
445 |         # self._validate_config() # Call will be made at the end of _load_config
446 |
447 |     async def _stage1_initial_validation_and_price_rounding(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
448 |         self, ctx: Stage1Context,
449 |     ) -> tuple[Decimal | None, Decimal, Decimal | None]:
    |

gal_friday/risk_manager.py:450:9: D205 1 blank line required between summary line and description
    |
448 |           self, ctx: Stage1Context,
449 |       ) -> tuple[Decimal | None, Decimal, Decimal | None]:
450 | /         """Stage 1: Initial Validation & Price Rounding.
451 | |         Validates proposed prices, calculates SL if not provided, rounds prices to tick size.
452 | |         Returns (rounded_entry_price, rounded_sl_price, rounded_tp_price).
453 | |         SL price is guaranteed non-None if process continues.
454 | |         """
    | |___________^ D205
455 |           # Basic validation of proposed prices (e.g., SL relative to entry)
456 |           if ctx.proposed_entry_price_decimal is not None and ctx.proposed_sl_price_decimal is not None:
    |
    = help: Insert single blank line

gal_friday/risk_manager.py:456:100: E501 Line too long (102 > 99)
    |
454 |         """
455 |         # Basic validation of proposed prices (e.g., SL relative to entry)
456 |         if ctx.proposed_entry_price_decimal is not None and ctx.proposed_sl_price_decimal is not None:
    |                                                                                                    ^^^ E501
457 |             if ctx.event.side.upper() == "BUY" and ctx.proposed_sl_price_decimal >= ctx.proposed_entry_price_decimal:
458 |                 raise SignalValidationStageError("SL price must be below entry for BUY signal.", "Stage1")
    |

gal_friday/risk_manager.py:457:100: E501 Line too long (117 > 99)
    |
455 |         # Basic validation of proposed prices (e.g., SL relative to entry)
456 |         if ctx.proposed_entry_price_decimal is not None and ctx.proposed_sl_price_decimal is not None:
457 |             if ctx.event.side.upper() == "BUY" and ctx.proposed_sl_price_decimal >= ctx.proposed_entry_price_decimal:
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
458 |                 raise SignalValidationStageError("SL price must be below entry for BUY signal.", "Stage1")
459 |             if ctx.event.side.upper() == "SELL" and ctx.proposed_sl_price_decimal <= ctx.proposed_entry_price_decimal:
    |

gal_friday/risk_manager.py:458:100: E501 Line too long (106 > 99)
    |
456 |         if ctx.proposed_entry_price_decimal is not None and ctx.proposed_sl_price_decimal is not None:
457 |             if ctx.event.side.upper() == "BUY" and ctx.proposed_sl_price_decimal >= ctx.proposed_entry_price_decimal:
458 |                 raise SignalValidationStageError("SL price must be below entry for BUY signal.", "Stage1")
    |                                                                                                    ^^^^^^^ E501
459 |             if ctx.event.side.upper() == "SELL" and ctx.proposed_sl_price_decimal <= ctx.proposed_entry_price_decimal:
460 |                 raise SignalValidationStageError("SL price must be above entry for SELL signal.", "Stage1")
    |

gal_friday/risk_manager.py:459:100: E501 Line too long (118 > 99)
    |
457 |             if ctx.event.side.upper() == "BUY" and ctx.proposed_sl_price_decimal >= ctx.proposed_entry_price_decimal:
458 |                 raise SignalValidationStageError("SL price must be below entry for BUY signal.", "Stage1")
459 |             if ctx.event.side.upper() == "SELL" and ctx.proposed_sl_price_decimal <= ctx.proposed_entry_price_decimal:
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
460 |                 raise SignalValidationStageError("SL price must be above entry for SELL signal.", "Stage1")
    |

gal_friday/risk_manager.py:460:100: E501 Line too long (107 > 99)
    |
458 |                 raise SignalValidationStageError("SL price must be below entry for BUY signal.", "Stage1")
459 |             if ctx.event.side.upper() == "SELL" and ctx.proposed_sl_price_decimal <= ctx.proposed_entry_price_decimal:
460 |                 raise SignalValidationStageError("SL price must be above entry for SELL signal.", "Stage1")
    |                                                                                                    ^^^^^^^^ E501
461 |
462 |         effective_entry_for_calc = ctx.proposed_entry_price_decimal
    |

gal_friday/risk_manager.py:467:100: E501 Line too long (149 > 99)
    |
465 | …
466 | …
467 | …price is required or must be calculable from a Limit entry price in Stage 1.", "Stage1")
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
468 | …
469 | …
    |

gal_friday/risk_manager.py:470:100: E501 Line too long (122 > 99)
    |
469 |             if ctx.event.side.upper() == "BUY":
470 |                 sl_price_to_round = effective_entry_for_calc * (Decimal("1") - self._min_sl_distance_pct / Decimal("100"))
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^ E501
471 |             else:  # SELL
472 |                 sl_price_to_round = effective_entry_for_calc * (Decimal("1") + self._min_sl_distance_pct / Decimal("100"))
    |

gal_friday/risk_manager.py:472:100: E501 Line too long (122 > 99)
    |
470 |                 sl_price_to_round = effective_entry_for_calc * (Decimal("1") - self._min_sl_distance_pct / Decimal("100"))
471 |             else:  # SELL
472 |                 sl_price_to_round = effective_entry_for_calc * (Decimal("1") + self._min_sl_distance_pct / Decimal("100"))
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^ E501
473 |
474 |         rounded_entry_price = self._round_price_to_tick_size(effective_entry_for_calc, ctx.event.trading_pair)
    |

gal_friday/risk_manager.py:474:100: E501 Line too long (110 > 99)
    |
472 |                 sl_price_to_round = effective_entry_for_calc * (Decimal("1") + self._min_sl_distance_pct / Decimal("100"))
473 |
474 |         rounded_entry_price = self._round_price_to_tick_size(effective_entry_for_calc, ctx.event.trading_pair)
    |                                                                                                    ^^^^^^^^^^^ E501
475 |         rounded_sl_price = self._round_price_to_tick_size(sl_price_to_round, ctx.event.trading_pair)
    |

gal_friday/risk_manager.py:475:100: E501 Line too long (100 > 99)
    |
474 |         rounded_entry_price = self._round_price_to_tick_size(effective_entry_for_calc, ctx.event.trading_pair)
475 |         rounded_sl_price = self._round_price_to_tick_size(sl_price_to_round, ctx.event.trading_pair)
    |                                                                                                    ^ E501
476 |
477 |         if rounded_sl_price is None:
    |

gal_friday/risk_manager.py:482:100: E501 Line too long (116 > 99)
    |
480 |         rounded_tp_price = None
481 |         if ctx.proposed_tp_price_decimal is not None:
482 |             rounded_tp_price = self._round_price_to_tick_size(ctx.proposed_tp_price_decimal, ctx.event.trading_pair)
    |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
483 |         elif rounded_entry_price is not None:
484 |             risk_per_unit = abs(rounded_entry_price - rounded_sl_price)
    |

gal_friday/risk_manager.py:494:100: E501 Line too long (112 > 99)
    |
492 |         if rounded_entry_price is not None:
493 |             if rounded_entry_price == rounded_sl_price:
494 |                  raise SignalValidationStageError("Entry and SL prices are identical after rounding.", "Stage1")
    |                                                                                                    ^^^^^^^^^^^^^ E501
495 |             sl_distance_pct = abs(rounded_sl_price - rounded_entry_price) / rounded_entry_price * Decimal("100")
496 |             if sl_distance_pct < self._min_sl_distance_pct:
    |

gal_friday/risk_manager.py:495:100: E501 Line too long (112 > 99)
    |
493 |             if rounded_entry_price == rounded_sl_price:
494 |                  raise SignalValidationStageError("Entry and SL prices are identical after rounding.", "Stage1")
495 |             sl_distance_pct = abs(rounded_sl_price - rounded_entry_price) / rounded_entry_price * Decimal("100")
    |                                                                                                    ^^^^^^^^^^^^^ E501
496 |             if sl_distance_pct < self._min_sl_distance_pct:
497 |                 raise SignalValidationStageError(
    |

gal_friday/risk_manager.py:498:100: E501 Line too long (133 > 99)
    |
496 |             if sl_distance_pct < self._min_sl_distance_pct:
497 |                 raise SignalValidationStageError(
498 |                     f"Stop-loss distance ({sl_distance_pct:.2f}%) is less than minimum required ({self._min_sl_distance_pct:.2f}%).",
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
499 |                     "Stage1",
500 |                 )
    |

gal_friday/risk_manager.py:502:100: E501 Line too long (117 > 99)
    |
500 |                 )
501 |         elif ctx.event.entry_type.upper() == "LIMIT":
502 |              raise SignalValidationStageError("Entry price required for LIMIT order validation in Stage1.", "Stage1")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
503 |
504 |         return rounded_entry_price, rounded_sl_price, rounded_tp_price
    |

gal_friday/risk_manager.py:527:100: E501 Line too long (121 > 99)
    |
526 |     def _validate_and_raise_if_error(
527 |         self, error_condition: bool, failure_reason: str, stage_name: str, log_message: str, log_context: dict[str, Any],
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
528 |     ) -> None:
529 |         """Helper to validate a condition and raise SignalValidationStageError if true."""
    |

gal_friday/risk_manager.py:622:100: E501 Line too long (102 > 99)
    |
621 |         # Start risk metrics calculation task
622 |         self._risk_metrics_task_obj = asyncio.create_task(self._risk_metrics_task()) # Fixed reference
    |                                                                                                    ^^^ E501
623 |
624 |         self._is_running = True
    |

gal_friday/risk_manager.py:782:13: S101 Use of `assert` detected
    |
780 |                 log_context={"signal_id": str(event.signal_id)},
781 |             )
782 |             assert ref_entry_for_calculation is not None, "ref_entry_for_calculation should be Decimal after validation"
    |             ^^^^^^ S101
783 |             assert final_rounded_entry_price is not None, "final_rounded_entry_price should be Decimal after validation"
    |

gal_friday/risk_manager.py:782:100: E501 Line too long (120 > 99)
    |
780 |                 log_context={"signal_id": str(event.signal_id)},
781 |             )
782 |             assert ref_entry_for_calculation is not None, "ref_entry_for_calculation should be Decimal after validation"
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^ E501
783 |             assert final_rounded_entry_price is not None, "final_rounded_entry_price should be Decimal after validation"
    |

gal_friday/risk_manager.py:783:13: S101 Use of `assert` detected
    |
781 |             )
782 |             assert ref_entry_for_calculation is not None, "ref_entry_for_calculation should be Decimal after validation"
783 |             assert final_rounded_entry_price is not None, "final_rounded_entry_price should be Decimal after validation"
    |             ^^^^^^ S101
784 |
785 |             # --- Stage 3: Position Sizing & Portfolio Checks (Portfolio/Equity checks first) ---
    |

gal_friday/risk_manager.py:783:100: E501 Line too long (120 > 99)
    |
781 |             )
782 |             assert ref_entry_for_calculation is not None, "ref_entry_for_calculation should be Decimal after validation"
783 |             assert final_rounded_entry_price is not None, "final_rounded_entry_price should be Decimal after validation"
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^ E501
784 |
785 |             # --- Stage 3: Position Sizing & Portfolio Checks (Portfolio/Equity checks first) ---
    |

gal_friday/risk_manager.py:905:13: S101 Use of `assert` detected
    |
903 |                     "final_validation",
904 |                 )
905 |             assert final_effective_entry_price is not None, "final_effective_entry_price should be Decimal after validation"
    |             ^^^^^^ S101
906 |
907 |             final_validation_ctx = FinalValidationDataContext(
    |

gal_friday/risk_manager.py:905:100: E501 Line too long (124 > 99)
    |
903 |                     "final_validation",
904 |                 )
905 |             assert final_effective_entry_price is not None, "final_effective_entry_price should be Decimal after validation"
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
906 |
907 |             final_validation_ctx = FinalValidationDataContext(
    |

gal_friday/risk_manager.py:1538:100: E501 Line too long (116 > 99)
     |
1536 |             if rounded_entry_price is not None:
1537 |                 if ctx.side == "BUY":
1538 |                     ctx.sl_price = rounded_entry_price * (Decimal("1") - self._min_sl_distance_pct / Decimal("100"))
     |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
1539 |                 else:  # SELL
1540 |                     ctx.sl_price = rounded_entry_price * (Decimal("1") + self._min_sl_distance_pct / Decimal("100"))
     |

gal_friday/risk_manager.py:1540:100: E501 Line too long (116 > 99)
     |
1538 |                     ctx.sl_price = rounded_entry_price * (Decimal("1") - self._min_sl_distance_pct / Decimal("100"))
1539 |                 else:  # SELL
1540 |                     ctx.sl_price = rounded_entry_price * (Decimal("1") + self._min_sl_distance_pct / Decimal("100"))
     |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
1541 |             else:
1542 |                 return False, "Cannot calculate SL without entry price", None, None, None
     |

gal_friday/risk_manager.py:1548:100: E501 Line too long (114 > 99)
     |
1546 |         # Validate SL distance
1547 |         if rounded_entry_price is not None and rounded_sl_price is not None:
1548 |             sl_distance_pct = abs((rounded_sl_price - rounded_entry_price) / rounded_entry_price) * Decimal("100")
     |                                                                                                    ^^^^^^^^^^^^^^^ E501
1549 |             if sl_distance_pct < self._min_sl_distance_pct:
1550 |                 return False, f"SL distance {sl_distance_pct:.2f}% below minimum {self._min_sl_distance_pct}%", None, None, None
     |

gal_friday/risk_manager.py:1550:100: E501 Line too long (128 > 99)
     |
1548 |             sl_distance_pct = abs((rounded_sl_price - rounded_entry_price) / rounded_entry_price) * Decimal("100")
1549 |             if sl_distance_pct < self._min_sl_distance_pct:
1550 |                 return False, f"SL distance {sl_distance_pct:.2f}% below minimum {self._min_sl_distance_pct}%", None, None, None
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1551 |
1552 |         # Calculate TP if not provided
     |

gal_friday/risk_manager.py:1592:100: E501 Line too long (115 > 99)
     |
1590 |         try:
1591 |             if tick_size and tick_size > 0:
1592 |                 result_price: Decimal = (price / tick_size).quantize(Decimal("1"), rounding=ROUND_DOWN) * tick_size
     |                                                                                                    ^^^^^^^^^^^^^^^^ E501
1593 |                 return result_price
1594 |             return price
     |

gal_friday/risk_manager.py:1599:100: E501 Line too long (112 > 99)
     |
1597 |                 f"Error rounding price to tick size for {trading_pair}",
1598 |                 source_module=self._source_module,
1599 |                 context={"trading_pair": trading_pair, "price": price, "tick_size": tick_size, "error": str(e)},
     |                                                                                                    ^^^^^^^^^^^^^ E501
1600 |             )
1601 |             return None
     |

gal_friday/risk_manager.py:1609:100: E501 Line too long (118 > 99)
     |
1607 |         """Validate prices for fat finger and stop loss distance."""
1608 |         # Fat finger check for limit orders
1609 |         if ctx.entry_type == "LIMIT" and ctx.current_market_price is not None and ctx.rounded_entry_price is not None:
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
1610 |             deviation_pct = abs((ctx.rounded_entry_price - ctx.current_market_price) / ctx.current_market_price) * Decimal("100")
1611 |             if deviation_pct > self._fat_finger_max_deviation_pct:
     |

gal_friday/risk_manager.py:1610:100: E501 Line too long (129 > 99)
     |
1608 |         # Fat finger check for limit orders
1609 |         if ctx.entry_type == "LIMIT" and ctx.current_market_price is not None and ctx.rounded_entry_price is not None:
1610 |             deviation_pct = abs((ctx.rounded_entry_price - ctx.current_market_price) / ctx.current_market_price) * Decimal("100")
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1611 |             if deviation_pct > self._fat_finger_max_deviation_pct:
1612 |                 return False, f"Entry price deviates {deviation_pct:.2f}% from market (max {self._fat_finger_max_deviation_pct}%)"
     |

gal_friday/risk_manager.py:1612:100: E501 Line too long (130 > 99)
     |
1610 |             deviation_pct = abs((ctx.rounded_entry_price - ctx.current_market_price) / ctx.current_market_price) * Decimal("100")
1611 |             if deviation_pct > self._fat_finger_max_deviation_pct:
1612 |                 return False, f"Entry price deviates {deviation_pct:.2f}% from market (max {self._fat_finger_max_deviation_pct}%)"
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1613 |
1614 |         # Validate SL distance
     |

gal_friday/risk_manager.py:1617:100: E501 Line too long (110 > 99)
     |
1615 |         effective_entry = ctx.rounded_entry_price or ctx.effective_entry_price_for_non_limit
1616 |         if effective_entry is not None:
1617 |             sl_distance_pct = abs((ctx.rounded_sl_price - effective_entry) / effective_entry) * Decimal("100")
     |                                                                                                    ^^^^^^^^^^^ E501
1618 |             if sl_distance_pct < self._min_sl_distance_pct:
1619 |                 return False, f"SL distance {sl_distance_pct:.2f}% below minimum {self._min_sl_distance_pct}%"
     |

gal_friday/risk_manager.py:1619:100: E501 Line too long (110 > 99)
     |
1617 |             sl_distance_pct = abs((ctx.rounded_sl_price - effective_entry) / effective_entry) * Decimal("100")
1618 |             if sl_distance_pct < self._min_sl_distance_pct:
1619 |                 return False, f"SL distance {sl_distance_pct:.2f}% below minimum {self._min_sl_distance_pct}%"
     |                                                                                                    ^^^^^^^^^^^ E501
1620 |
1621 |             # Validate SL is on correct side
     |

gal_friday/risk_manager.py:1680:100: E501 Line too long (110 > 99)
     |
1678 |                     return SizingResult(
1679 |                         is_valid=False,
1680 |                         rejection_reason=f"Position value exceeds max order size ${self._max_order_size_usd}",
     |                                                                                                    ^^^^^^^^^^^ E501
1681 |                     )
1682 |                 position_value = rounded_quantity * ref_entry_price
     |

gal_friday/risk_manager.py:1689:100: E501 Line too long (119 > 99)
     |
1687 |                 return SizingResult(
1688 |                     is_valid=False,
1689 |                     rejection_reason=f"Position size {position_pct:.2f}% exceeds max {self._max_single_position_pct}%",
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
1690 |                 )
     |

gal_friday/risk_manager.py:1710:9: PLR0911 Too many return statements (7 > 6)
     |
1708 |             )
1709 |
1710 |     def _check_position_scaling(
     |         ^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
1711 |         self,
1712 |         ctx: PositionScalingContext,
     |

gal_friday/risk_manager.py:1736:100: E501 Line too long (156 > 99)
     |
1734 | …t_pct:
1735 | …
1736 | …* self._max_exposure_per_asset_pct / Decimal("100")) - (existing_qty * ctx.ref_entry_price)
     |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1737 | …
1738 | …ximum exposure", None, None
     |

gal_friday/risk_manager.py:1741:100: E501 Line too long (112 > 99)
     |
1740 |                         scaled_qty = max_additional_value / ctx.ref_entry_price
1741 |                         scaled_qty_result = self._calculate_lot_size_with_fallback(ctx.trading_pair, scaled_qty)
     |                                                                                                    ^^^^^^^^^^^^^ E501
1742 |                         scaled_qty = scaled_qty_result if scaled_qty_result is not None else Decimal("0")
     |

gal_friday/risk_manager.py:1742:100: E501 Line too long (105 > 99)
     |
1740 |                         scaled_qty = max_additional_value / ctx.ref_entry_price
1741 |                         scaled_qty_result = self._calculate_lot_size_with_fallback(ctx.trading_pair, scaled_qty)
1742 |                         scaled_qty = scaled_qty_result if scaled_qty_result is not None else Decimal("0")
     |                                                                                                    ^^^^^^ E501
1743 |
1744 |                         if scaled_qty is None or scaled_qty <= 0:
     |

gal_friday/risk_manager.py:1775:20: B007 Loop control variable `default` not used within loop body
     |
1773 |         }
1774 |
1775 |         for field, default in extracted.items():
     |                    ^^^^^^^ B007
1776 |             try:
1777 |                 if field in portfolio_state:
     |
     = help: Rename unused `default` to `_default`

gal_friday/risk_manager.py:1786:13: SIM105 Use `contextlib.suppress(InvalidOperation, ValueError)` instead of `try`-`except`-`pass`
     |
1784 |           # Handle special cases
1785 |           if "current_equity_usd" not in portfolio_state and "equity" in portfolio_state:
1786 | /             try:
1787 | |                 extracted["current_equity_usd"] = Decimal(str(portfolio_state["equity"]))
1788 | |             except (InvalidOperation, ValueError):
1789 | |                 pass
     | |____________________^ SIM105
1790 |
1791 |           # Calculate total exposure if not provided
     |
     = help: Replace with `contextlib.suppress(InvalidOperation, ValueError)`

gal_friday/risk_manager.py:1805:1: W293 Blank line contains whitespace
     |
1803 |     async def _handle_execution_report_for_losses(self, event: ExecutionReportEvent) -> None:
1804 |         """Handle execution reports to track consecutive losses for dynamic risk adjustment.
1805 |
     | ^^^^^^^^ W293
1806 |         Args:
1807 |             event: The execution report event to process
     |
     = help: Remove whitespace from blank line

gal_friday/risk_manager.py:1834:100: E501 Line too long (118 > 99)
     |
1832 |                 await asyncio.sleep(self._risk_metrics_interval_s)
1833 |
1834 |     async def _reject_signal(self, signal_id: uuid.UUID, event: TradeSignalProposedEvent, reason: str | None) -> None:
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
1835 |         """Reject a trade signal with a given reason.
     |

gal_friday/risk_manager.py:1836:1: W293 Blank line contains whitespace
     |
1834 |     async def _reject_signal(self, signal_id: uuid.UUID, event: TradeSignalProposedEvent, reason: str | None) -> None:
1835 |         """Reject a trade signal with a given reason.
1836 |
     | ^^^^^^^^ W293
1837 |         Args:
1838 |             signal_id: The ID of the signal to reject
     |
     = help: Remove whitespace from blank line

gal_friday/risk_manager.py:1860:100: E501 Line too long (103 > 99)
     |
1858 |             exchange=event.exchange,
1859 |             side=event.side,
1860 |             reason=reason if reason is not None else "No reason provided.", # Ensure reason is not None
     |                                                                                                    ^^^^ E501
1861 |         )
     |

gal_friday/risk_manager.py:1868:1: W293 Blank line contains whitespace
     |
1866 |     async def _approve_signal(self, ctx: FinalValidationDataContext) -> None:
1867 |         """Approve a trade signal with calculated risk parameters.
1868 |
     | ^^^^^^^^ W293
1869 |         Args:
1870 |             ctx: Final validation context
     |
     = help: Remove whitespace from blank line

gal_friday/risk_manager.py:1887:100: E501 Line too long (101 > 99)
     |
1885 |         # Create and publish approval event
1886 |         # Ensure tp_price is a Decimal by providing default of 0 if None
1887 |         tp_price_decimal = ctx.rounded_tp_price if ctx.rounded_tp_price is not None else Decimal("0")
     |                                                                                                    ^^ E501
1888 |
1889 |         approval_params = TradeSignalApprovedParams(
     |

gal_friday/risk_manager.py:1913:1: W293 Blank line contains whitespace
     |
1911 |     def _stage3_position_sizing_and_portfolio_checks(self, ctx: Stage3Context) -> Decimal:
1912 |         """Calculate position size and perform portfolio checks.
1913 |
     | ^^^^^^^^ W293
1914 |         Args:
1915 |             ctx: Context containing event and price information
     |
     = help: Remove whitespace from blank line

gal_friday/risk_manager.py:1916:1: W293 Blank line contains whitespace
     |
1914 |         Args:
1915 |             ctx: Context containing event and price information
1916 |
     | ^^^^^^^^^^^^ W293
1917 |         Returns:
1918 |             Decimal: Calculated position size
     |
     = help: Remove whitespace from blank line

gal_friday/risk_manager.py:1936:100: E501 Line too long (135 > 99)
     |
1934 | …
1935 | …
1936 | …lf, ctx: Stage2Context) -> tuple[Decimal | None, Decimal | None, Decimal | None]:
     |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1937 | …finger, SL distance).
     |

gal_friday/risk_manager.py:1938:1: W293 Blank line contains whitespace
     |
1936 |     async def _stage2_market_price_dependent_checks(self, ctx: Stage2Context) -> tuple[Decimal | None, Decimal | None, Decimal | Non…
1937 |         """Perform market price dependent checks (fat finger, SL distance).
1938 |
     | ^^^^^^^^ W293
1939 |         Args:
1940 |             ctx: Context containing event and price information
     |
     = help: Remove whitespace from blank line

gal_friday/risk_manager.py:1941:1: W293 Blank line contains whitespace
     |
1939 |         Args:
1940 |             ctx: Context containing event and price information
1941 |
     | ^^^^^^^^^^^^ W293
1942 |         Returns:
1943 |             tuple: (effective_entry_price_for_non_limit, ref_entry_for_calculation, final_rounded_entry_price)
     |
     = help: Remove whitespace from blank line

gal_friday/risk_manager.py:1943:100: E501 Line too long (110 > 99)
     |
1942 |         Returns:
1943 |             tuple: (effective_entry_price_for_non_limit, ref_entry_for_calculation, final_rounded_entry_price)
     |                                                                                                    ^^^^^^^^^^^ E501
1944 |         """
1945 |         # Implementation would check for fat finger errors and SL distance validations
     |

gal_friday/risk_manager.py:1950:100: E501 Line too long (104 > 99)
     |
1948 |         # For market orders, use current market price as reference
1949 |         effective_entry_price_for_non_limit = None
1950 |         if event.entry_type.upper() == "MARKET" and ctx.current_market_price_for_validation is not None:
     |                                                                                                    ^^^^^ E501
1951 |             effective_entry_price_for_non_limit = ctx.current_market_price_for_validation
     |

gal_friday/risk_manager.py:1971:100: E501 Line too long (118 > 99)
     |
1969 |         is_valid, reason = self._validate_prices_fat_finger_and_sl_distance(price_validation_ctx)
1970 |         if not is_valid:
1971 |             raise SignalValidationStageError(reason or "Unknown validation error", "Stage2: Fat Finger & SL Distance")
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
1972 |
1973 |         return effective_entry_price_for_non_limit, ref_entry_for_calculation, ctx.rounded_entry_price
     |

gal_friday/risk_manager.py:1973:100: E501 Line too long (102 > 99)
     |
1971 |             raise SignalValidationStageError(reason or "Unknown validation error", "Stage2: Fat Finger & SL Distance")
1972 |
1973 |         return effective_entry_price_for_non_limit, ref_entry_for_calculation, ctx.rounded_entry_price
     |                                                                                                    ^^^ E501
1974 |
1975 |     def _calculate_lot_size_with_fallback(self, trading_pair: str, quantity: Decimal) -> Decimal | None:
     |

gal_friday/risk_manager.py:1975:100: E501 Line too long (104 > 99)
     |
1973 |         return effective_entry_price_for_non_limit, ref_entry_for_calculation, ctx.rounded_entry_price
1974 |
1975 |     def _calculate_lot_size_with_fallback(self, trading_pair: str, quantity: Decimal) -> Decimal | None:
     |                                                                                                    ^^^^^ E501
1976 |         """Round quantity to exchange step size with fallback mechanisms.
     |

gal_friday/risk_manager.py:1977:1: W293 Blank line contains whitespace
     |
1975 |     def _calculate_lot_size_with_fallback(self, trading_pair: str, quantity: Decimal) -> Decimal | None:
1976 |         """Round quantity to exchange step size with fallback mechanisms.
1977 |
     | ^^^^^^^^ W293
1978 |         Args:
1979 |             trading_pair: The trading pair to calculate for
     |
     = help: Remove whitespace from blank line

gal_friday/risk_manager.py:1981:1: W293 Blank line contains whitespace
     |
1979 |             trading_pair: The trading pair to calculate for
1980 |             quantity: The raw quantity to round
1981 |
     | ^^^^^^^^^^^^ W293
1982 |         Returns:
1983 |             Rounded quantity or None if below minimum
     |
     = help: Remove whitespace from blank line

gal_friday/risk_manager.py:1999:100: E501 Line too long (100 > 99)
     |
1998 |         # Round down to step size
1999 |         rounded_qty = (quantity / step_size).quantize(Decimal("1"), rounding=ROUND_DOWN) * step_size
     |                                                                                                    ^ E501
2000 |
2001 |         # Check if below minimum
     |

generate_ddl.py:1:1: D100 Missing docstring in public module
generate_ddl.py:7:20: PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  |
5 | # Ensure the current directory (project root) is in sys.path
6 | # This allows 'from gal_friday...' imports if the script is in the project root
7 | sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))
  |                    ^^^^^^^^^^^^^^^ PTH100
8 |
9 | from sqlalchemy.dialects import postgresql
  |

generate_ddl.py:7:36: PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  |
5 | # Ensure the current directory (project root) is in sys.path
6 | # This allows 'from gal_friday...' imports if the script is in the project root
7 | sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))
  |                                    ^^^^^^^^^^^^^^^ PTH120
8 |
9 | from sqlalchemy.dialects import postgresql
  |

generate_ddl.py:17:61: F401 `gal_friday.dal.models.drift_detection_event.DriftDetectionEvent` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
15 | try:
16 |     from gal_friday.dal.models import Base
17 |     from gal_friday.dal.models.drift_detection_event import DriftDetectionEvent
   |                                                             ^^^^^^^^^^^^^^^^^^^ F401
18 |     from gal_friday.dal.models.experiment import Experiment
19 |     from gal_friday.dal.models.experiment_assignment import ExperimentAssignment
   |
   = help: Remove unused import: `gal_friday.dal.models.drift_detection_event.DriftDetectionEvent`

generate_ddl.py:18:50: F401 `gal_friday.dal.models.experiment.Experiment` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
16 |     from gal_friday.dal.models import Base
17 |     from gal_friday.dal.models.drift_detection_event import DriftDetectionEvent
18 |     from gal_friday.dal.models.experiment import Experiment
   |                                                  ^^^^^^^^^^ F401
19 |     from gal_friday.dal.models.experiment_assignment import ExperimentAssignment
20 |     from gal_friday.dal.models.experiment_outcome import ExperimentOutcome
   |
   = help: Remove unused import: `gal_friday.dal.models.experiment.Experiment`

generate_ddl.py:19:61: F401 `gal_friday.dal.models.experiment_assignment.ExperimentAssignment` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
17 |     from gal_friday.dal.models.drift_detection_event import DriftDetectionEvent
18 |     from gal_friday.dal.models.experiment import Experiment
19 |     from gal_friday.dal.models.experiment_assignment import ExperimentAssignment
   |                                                             ^^^^^^^^^^^^^^^^^^^^ F401
20 |     from gal_friday.dal.models.experiment_outcome import ExperimentOutcome
21 |     from gal_friday.dal.models.model_deployment import ModelDeployment
   |
   = help: Remove unused import: `gal_friday.dal.models.experiment_assignment.ExperimentAssignment`

generate_ddl.py:20:58: F401 `gal_friday.dal.models.experiment_outcome.ExperimentOutcome` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
18 |     from gal_friday.dal.models.experiment import Experiment
19 |     from gal_friday.dal.models.experiment_assignment import ExperimentAssignment
20 |     from gal_friday.dal.models.experiment_outcome import ExperimentOutcome
   |                                                          ^^^^^^^^^^^^^^^^^ F401
21 |     from gal_friday.dal.models.model_deployment import ModelDeployment
22 |     from gal_friday.dal.models.model_version import ModelVersion
   |
   = help: Remove unused import: `gal_friday.dal.models.experiment_outcome.ExperimentOutcome`

generate_ddl.py:21:56: F401 `gal_friday.dal.models.model_deployment.ModelDeployment` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
19 |     from gal_friday.dal.models.experiment_assignment import ExperimentAssignment
20 |     from gal_friday.dal.models.experiment_outcome import ExperimentOutcome
21 |     from gal_friday.dal.models.model_deployment import ModelDeployment
   |                                                        ^^^^^^^^^^^^^^^ F401
22 |     from gal_friday.dal.models.model_version import ModelVersion
23 |     from gal_friday.dal.models.order import Order
   |
   = help: Remove unused import: `gal_friday.dal.models.model_deployment.ModelDeployment`

generate_ddl.py:22:53: F401 `gal_friday.dal.models.model_version.ModelVersion` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
20 |     from gal_friday.dal.models.experiment_outcome import ExperimentOutcome
21 |     from gal_friday.dal.models.model_deployment import ModelDeployment
22 |     from gal_friday.dal.models.model_version import ModelVersion
   |                                                     ^^^^^^^^^^^^ F401
23 |     from gal_friday.dal.models.order import Order
24 |     from gal_friday.dal.models.position import Position
   |
   = help: Remove unused import: `gal_friday.dal.models.model_version.ModelVersion`

generate_ddl.py:23:45: F401 `gal_friday.dal.models.order.Order` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
21 |     from gal_friday.dal.models.model_deployment import ModelDeployment
22 |     from gal_friday.dal.models.model_version import ModelVersion
23 |     from gal_friday.dal.models.order import Order
   |                                             ^^^^^ F401
24 |     from gal_friday.dal.models.position import Position
25 |     from gal_friday.dal.models.position_adjustment import PositionAdjustment
   |
   = help: Remove unused import: `gal_friday.dal.models.order.Order`

generate_ddl.py:24:48: F401 `gal_friday.dal.models.position.Position` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
22 |     from gal_friday.dal.models.model_version import ModelVersion
23 |     from gal_friday.dal.models.order import Order
24 |     from gal_friday.dal.models.position import Position
   |                                                ^^^^^^^^ F401
25 |     from gal_friday.dal.models.position_adjustment import PositionAdjustment
26 |     from gal_friday.dal.models.reconciliation_event import ReconciliationEvent
   |
   = help: Remove unused import: `gal_friday.dal.models.position.Position`

generate_ddl.py:25:59: F401 `gal_friday.dal.models.position_adjustment.PositionAdjustment` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
23 |     from gal_friday.dal.models.order import Order
24 |     from gal_friday.dal.models.position import Position
25 |     from gal_friday.dal.models.position_adjustment import PositionAdjustment
   |                                                           ^^^^^^^^^^^^^^^^^^ F401
26 |     from gal_friday.dal.models.reconciliation_event import ReconciliationEvent
27 |     from gal_friday.dal.models.retraining_job import RetrainingJob
   |
   = help: Remove unused import: `gal_friday.dal.models.position_adjustment.PositionAdjustment`

generate_ddl.py:26:60: F401 `gal_friday.dal.models.reconciliation_event.ReconciliationEvent` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
24 |     from gal_friday.dal.models.position import Position
25 |     from gal_friday.dal.models.position_adjustment import PositionAdjustment
26 |     from gal_friday.dal.models.reconciliation_event import ReconciliationEvent
   |                                                            ^^^^^^^^^^^^^^^^^^^ F401
27 |     from gal_friday.dal.models.retraining_job import RetrainingJob
28 |     from gal_friday.dal.models.trade_signal import TradeSignal
   |
   = help: Remove unused import: `gal_friday.dal.models.reconciliation_event.ReconciliationEvent`

generate_ddl.py:27:54: F401 `gal_friday.dal.models.retraining_job.RetrainingJob` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
25 |     from gal_friday.dal.models.position_adjustment import PositionAdjustment
26 |     from gal_friday.dal.models.reconciliation_event import ReconciliationEvent
27 |     from gal_friday.dal.models.retraining_job import RetrainingJob
   |                                                      ^^^^^^^^^^^^^ F401
28 |     from gal_friday.dal.models.trade_signal import TradeSignal
29 |     print("Successfully imported models.", file=sys.stderr)
   |
   = help: Remove unused import: `gal_friday.dal.models.retraining_job.RetrainingJob`

generate_ddl.py:28:52: F401 `gal_friday.dal.models.trade_signal.TradeSignal` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
26 |     from gal_friday.dal.models.reconciliation_event import ReconciliationEvent
27 |     from gal_friday.dal.models.retraining_job import RetrainingJob
28 |     from gal_friday.dal.models.trade_signal import TradeSignal
   |                                                    ^^^^^^^^^^^ F401
29 |     print("Successfully imported models.", file=sys.stderr)
30 | except ImportError as e:
   |
   = help: Remove unused import: `gal_friday.dal.models.trade_signal.TradeSignal`

generate_ddl.py:29:5: T201 `print` found
   |
27 |     from gal_friday.dal.models.retraining_job import RetrainingJob
28 |     from gal_friday.dal.models.trade_signal import TradeSignal
29 |     print("Successfully imported models.", file=sys.stderr)
   |     ^^^^^ T201
30 | except ImportError as e:
31 |     print(f"Error importing models: {e}. Check PYTHONPATH and script location.", file=sys.stderr)
   |
   = help: Remove `print`

generate_ddl.py:31:5: T201 `print` found
   |
29 |     print("Successfully imported models.", file=sys.stderr)
30 | except ImportError as e:
31 |     print(f"Error importing models: {e}. Check PYTHONPATH and script location.", file=sys.stderr)
   |     ^^^^^ T201
32 |     print(f"Current sys.path: {sys.path}", file=sys.stderr)
33 |     sys.exit(1)
   |
   = help: Remove `print`

generate_ddl.py:32:5: T201 `print` found
   |
30 | except ImportError as e:
31 |     print(f"Error importing models: {e}. Check PYTHONPATH and script location.", file=sys.stderr)
32 |     print(f"Current sys.path: {sys.path}", file=sys.stderr)
   |     ^^^^^ T201
33 |     sys.exit(1)
   |
   = help: Remove `print`

generate_ddl.py:35:11: ANN201 Missing return type annotation for public function `main`
   |
33 |     sys.exit(1)
34 |
35 | async def main():
   |           ^^^^ ANN201
36 |     # Define a dummy URL; only the dialect matters for DDL compilation without a connection.
37 |     # Ensure the dialect matches your target database (postgresql).
   |
   = help: Add return type annotation: `None`

generate_ddl.py:35:11: D103 Missing docstring in public function
   |
33 |     sys.exit(1)
34 |
35 | async def main():
   |           ^^^^ D103
36 |     # Define a dummy URL; only the dialect matters for DDL compilation without a connection.
37 |     # Ensure the dialect matches your target database (postgresql).
   |

generate_ddl.py:40:5: F841 Local variable `engine` is assigned to but never used
   |
38 |     # Using asyncpg dialect as it's used in the project.
39 |     dummy_url = "postgresql+asyncpg://user:pass@localhost/dbname"
40 |     engine = create_async_engine(dummy_url, poolclass=NullPool)
   |     ^^^^^^ F841
41 |     pg_dialect = postgresql.dialect()
   |
   = help: Remove assignment to unused variable `engine`

generate_ddl.py:43:5: T201 `print` found
   |
41 |     pg_dialect = postgresql.dialect()
42 |
43 |     print("-- UPGRADE DDL --")
   |     ^^^^^ T201
44 |     for table in Base.metadata.sorted_tables:
45 |         try:
   |
   = help: Remove `print`

generate_ddl.py:48:13: T201 `print` found
   |
46 |             # Compile DDL using the engine's dialect
47 |             ddl_statement = str(CreateTable(table).compile(dialect=pg_dialect)).strip()
48 |             print(f"{ddl_statement};")
   |             ^^^^^ T201
49 |         except Exception as e:
50 |             print(f"-- Error compiling CREATE for table {table.name}: {e}", file=sys.stderr)
   |
   = help: Remove `print`

generate_ddl.py:50:13: T201 `print` found
   |
48 |             print(f"{ddl_statement};")
49 |         except Exception as e:
50 |             print(f"-- Error compiling CREATE for table {table.name}: {e}", file=sys.stderr)
   |             ^^^^^ T201
   |
   = help: Remove `print`

generate_ddl.py:53:5: T201 `print` found
   |
53 |     print("\n-- DOWNGRADE DDL --")
   |     ^^^^^ T201
54 |     for table in reversed(Base.metadata.sorted_tables):
55 |         try:
   |
   = help: Remove `print`

generate_ddl.py:58:13: T201 `print` found
   |
56 |             # Compile DDL using the engine's dialect
57 |             ddl_statement = str(DropTable(table).compile(dialect=pg_dialect)).strip()
58 |             print(f"{ddl_statement};")
   |             ^^^^^ T201
59 |         except Exception as e:
60 |             print(f"-- Error compiling DROP for table {table.name}: {e}", file=sys.stderr)
   |
   = help: Remove `print`

generate_ddl.py:60:13: T201 `print` found
   |
58 |             print(f"{ddl_statement};")
59 |         except Exception as e:
60 |             print(f"-- Error compiling DROP for table {table.name}: {e}", file=sys.stderr)
   |             ^^^^^ T201
61 |
62 | if __name__ == "__main__":
   |
   = help: Remove `print`

scripts/train_initial_model.py:51:5: T201 `print` found
   |
49 |     from gal_friday.config_manager import ConfigManager
50 | except ImportError as e:
51 |     print(f"Error importing ConfigManager: {e}")
   |     ^^^^^ T201
52 |     print("Ensure the script is run from the project root or the PYTHONPATH is set correctly.")
53 |     sys.exit(1)
   |
   = help: Remove `print`

scripts/train_initial_model.py:52:5: T201 `print` found
   |
50 | except ImportError as e:
51 |     print(f"Error importing ConfigManager: {e}")
52 |     print("Ensure the script is run from the project root or the PYTHONPATH is set correctly.")
   |     ^^^^^ T201
53 |     sys.exit(1)
   |
   = help: Remove `print`

scripts/train_initial_model.py:372:5: D417 Missing argument descriptions in the docstring for `train_model`: `x_test`, `x_train`
    |
372 | def train_model(
    |     ^^^^^^^^^^^ D417
373 |     x_train: pd.DataFrame,
374 |     y_train: pd.Series,
    |

tests/__init__.py:1:1: D104 Missing docstring in public package
tests/conftest.py:171:100: E501 Line too long (104 > 99)
    |
169 |             """Get decimal configuration value."""
170 |             value = self.get(key, default)
171 |             return Decimal(str(value)) if value is not None else (Decimal(default) if default else None)
    |                                                                                                    ^^^^^ E501
172 |
173 |         def get_list(self, key, default=None):
    |

tests/conftest.py:299:56: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
297 |             # Add some variation based on features
298 |             base = self.default_prediction
299 |             if "rsi" in features and features["rsi"] < 30:
    |                                                        ^^ PLR2004
300 |                 base += 0.1  # Oversold, likely to go up
301 |             elif "rsi" in features and features["rsi"] > 70:
    |

tests/conftest.py:301:58: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
299 |             if "rsi" in features and features["rsi"] < 30:
300 |                 base += 0.1  # Oversold, likely to go up
301 |             elif "rsi" in features and features["rsi"] > 70:
    |                                                          ^^ PLR2004
302 |                 base -= 0.1  # Overbought, likely to go down
    |

tests/dal/test_connection_pool.py:1:1: D100 Missing docstring in public module
tests/dal/test_connection_pool.py:13:5: D103 Missing docstring in public function
   |
12 | @pytest.fixture
13 | def mock_config():
   |     ^^^^^^^^^^^ D103
14 |     mock = MagicMock(spec=ConfigManager)
15 |     mock.get.side_effect = lambda key, default=None: {
   |

tests/dal/test_connection_pool.py:29:5: D103 Missing docstring in public function
   |
28 | @pytest.fixture
29 | def mock_logger():
   |     ^^^^^^^^^^^ D103
30 |     # Use a real logger instance but with a mock handler or spy on its methods
31 |     # For simplicity here, MagicMock is fine for checking calls.
   |

tests/dal/test_connection_pool.py:42:11: D103 Missing docstring in public function
   |
40 | @pytest.mark.asyncio
41 | @patch("gal_friday.dal.connection_pool.create_async_engine", autospec=True)
42 | async def test_initialize_success(mock_create_engine, mock_config, mock_logger):
   |           ^^^^^^^^^^^^^^^^^^^^^^^ D103
43 |     mock_engine_instance = AsyncMock()
44 |     mock_create_engine.return_value = mock_engine_instance
   |

tests/dal/test_connection_pool.py:55:9: S106 Possible hardcoded password assigned to argument: "password"
   |
53 |         drivername="postgresql+asyncpg",
54 |         username="test",
55 |         password="test",
   |         ^^^^^^^^^^^^^^^ S106
56 |         host="localhost",
57 |         database="testdb",
   |

tests/dal/test_connection_pool.py:64:40: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
63 |     assert str(call_args[0]) == str(expected_url)
64 |     assert call_kwargs["pool_size"] == 5
   |                                        ^ PLR2004
65 |     assert call_kwargs["max_overflow"] == 5 # 10 (max_size) - 5 (min_size)
66 |     assert call_kwargs["echo"] is False
   |

tests/dal/test_connection_pool.py:65:43: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
63 |     assert str(call_args[0]) == str(expected_url)
64 |     assert call_kwargs["pool_size"] == 5
65 |     assert call_kwargs["max_overflow"] == 5 # 10 (max_size) - 5 (min_size)
   |                                           ^ PLR2004
66 |     assert call_kwargs["echo"] is False
67 |     assert call_kwargs["pool_recycle"] == 300
   |

tests/dal/test_connection_pool.py:67:43: PLR2004 Magic value used in comparison, consider replacing `300` with a constant variable
   |
65 |     assert call_kwargs["max_overflow"] == 5 # 10 (max_size) - 5 (min_size)
66 |     assert call_kwargs["echo"] is False
67 |     assert call_kwargs["pool_recycle"] == 300
   |                                           ^^^ PLR2004
68 |     assert call_kwargs["pool_timeout"] == 10
   |

tests/dal/test_connection_pool.py:68:43: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
66 |     assert call_kwargs["echo"] is False
67 |     assert call_kwargs["pool_recycle"] == 300
68 |     assert call_kwargs["pool_timeout"] == 10
   |                                           ^^ PLR2004
   |

tests/dal/test_connection_pool.py:77:11: D103 Missing docstring in public function
   |
76 | @pytest.mark.asyncio
77 | async def test_initialize_failure_no_url(mock_config, mock_logger):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
78 |     # mock_config.get("database.connection_string") should return "" or None
79 |     # Make sure other keys still return their defaults if get() is called for them.
   |

tests/dal/test_connection_pool.py:102:11: D103 Missing docstring in public function
    |
100 | @pytest.mark.asyncio
101 | @patch("gal_friday.dal.connection_pool.create_async_engine", autospec=True)
102 | async def test_acquire_session(mock_create_engine, mock_config, mock_logger):
    |           ^^^^^^^^^^^^^^^^^^^^ D103
103 |     mock_engine_instance = AsyncMock()
104 |     mock_create_engine.return_value = mock_engine_instance
    |

tests/dal/test_connection_pool.py:117:100: E501 Line too long (145 > 99)
    |
115 | …
116 | …nmaker)
117 | …nstance # When mock_sm_instance_for_pool() is called, it returns mock_session_instance
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
118 | …
    |

tests/dal/test_connection_pool.py:126:100: E501 Line too long (107 > 99)
    |
125 |     mock_sm_instance_for_pool.assert_called_once() # Assert our mock session_maker was used
126 |     mock_session_instance.close.assert_called_once() # Assert session.close() was called by context manager
    |                                                                                                    ^^^^^^^^ E501
127 |     mock_session_instance.rollback.assert_not_called() # Assert rollback was not called for success path
    |

tests/dal/test_connection_pool.py:127:100: E501 Line too long (104 > 99)
    |
125 |     mock_sm_instance_for_pool.assert_called_once() # Assert our mock session_maker was used
126 |     mock_session_instance.close.assert_called_once() # Assert session.close() was called by context manager
127 |     mock_session_instance.rollback.assert_not_called() # Assert rollback was not called for success path
    |                                                                                                    ^^^^^ E501
128 |
129 |     pool._session_maker = original_session_maker # Restore original session_maker
    |

tests/dal/test_connection_pool.py:132:11: D103 Missing docstring in public function
    |
131 | @pytest.mark.asyncio
132 | async def test_acquire_before_initialize(mock_config, mock_logger):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
133 |     pool = DatabaseConnectionPool(config=mock_config, logger=mock_logger)
134 |     with pytest.raises(RuntimeError, match="Session maker is not initialized. Call initialize() first."):
    |

tests/dal/test_connection_pool.py:134:100: E501 Line too long (105 > 99)
    |
132 | async def test_acquire_before_initialize(mock_config, mock_logger):
133 |     pool = DatabaseConnectionPool(config=mock_config, logger=mock_logger)
134 |     with pytest.raises(RuntimeError, match="Session maker is not initialized. Call initialize() first."):
    |                                                                                                    ^^^^^^ E501
135 |         async with pool.acquire():
136 |             pass # This code should not be reached
    |

tests/dal/test_connection_pool.py:140:11: D103 Missing docstring in public function
    |
138 | @pytest.mark.asyncio
139 | @patch("gal_friday.dal.connection_pool.create_async_engine", autospec=True)
140 | async def test_close_pool(mock_create_engine, mock_config, mock_logger):
    |           ^^^^^^^^^^^^^^^ D103
141 |     mock_engine_instance = AsyncMock()
142 |     # We need to mock the dispose method on the instance that will be stored in _engine
    |

tests/dal/test_connection_pool.py:163:11: D103 Missing docstring in public function
    |
161 | @pytest.mark.asyncio
162 | @patch("gal_friday.dal.connection_pool.create_async_engine", autospec=True)
163 | async def test_acquire_session_handles_exception(mock_create_engine, mock_config, mock_logger):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
164 |     mock_engine_instance = AsyncMock()
165 |     mock_create_engine.return_value = mock_engine_instance
    |

tests/test_data_ingestion.py:61:35: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
60 |         assert event.trading_pair == "XRP/USD"
61 |         assert len(event.bids) == 3
   |                                   ^ PLR2004
62 |         assert len(event.asks) == 3
63 |         assert event.bids[0][0] == Decimal("0.5000")
   |

tests/test_data_ingestion.py:62:35: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
60 |         assert event.trading_pair == "XRP/USD"
61 |         assert len(event.bids) == 3
62 |         assert len(event.asks) == 3
   |                                   ^ PLR2004
63 |         assert event.bids[0][0] == Decimal("0.5000")
   |

tests/test_data_ingestion.py:68:9: F841 Local variable `processor` is assigned to but never used
   |
66 |     async def test_order_book_depth_calculation(self, sample_l2_data):
67 |         """Test order book depth calculations."""
68 |         processor = MarketDataProcessor()
   |         ^^^^^^^^^ F841
69 |
70 |         # Calculate bid/ask depth
   |
   = help: Remove assignment to unused variable `processor`

tests/test_data_ingestion.py:233:39: PLR2004 Magic value used in comparison, consider replacing `120` with a constant variable
    |
231 |         gaps = processor.detect_data_gaps(timestamps, expected_interval=60)
232 |         assert len(gaps) == 1
233 |         assert gaps[0]["duration"] == 120  # 2 minutes
    |                                       ^^^ PLR2004
234 |
235 |     @pytest.mark.asyncio
    |

tests/test_data_ingestion.py:238:9: F841 Local variable `validator` is assigned to but never used
    |
236 |     async def test_corrupt_data_detection(self):
237 |         """Test detection and handling of corrupt data."""
238 |         validator = DataValidator()
    |         ^^^^^^^^^ F841
239 |
240 |         corrupt_scenarios = [
    |
    = help: Remove assignment to unused variable `validator`

tests/test_data_ingestion.py:277:16: E712 Avoid equality comparisons to `False`; use `if not processor.is_duplicate(event1):` for false checks
    |
275 |         )
276 |
277 |         assert processor.is_duplicate(event1) == False
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E712
278 |         processor.mark_processed(event1)
279 |         assert processor.is_duplicate(event2) == True
    |
    = help: Replace with `not processor.is_duplicate(event1)`

tests/test_data_ingestion.py:279:16: E712 Avoid equality comparisons to `True`; use `if processor.is_duplicate(event2):` for truth checks
    |
277 |         assert processor.is_duplicate(event1) == False
278 |         processor.mark_processed(event1)
279 |         assert processor.is_duplicate(event2) == True
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E712
    |
    = help: Replace with `processor.is_duplicate(event2)`

tests/test_data_ingestion.py:312:34: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
310 |             p99_latency = sorted(latencies)[int(len(latencies) * 0.99)]
311 |
312 |             assert avg_latency < 10  # Average < 10ms
    |                                  ^^ PLR2004
313 |             assert p99_latency < 50  # 99th percentile < 50ms
314 |             assert max_latency < 100  # Max < 100ms
    |

tests/test_data_ingestion.py:313:34: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
312 |             assert avg_latency < 10  # Average < 10ms
313 |             assert p99_latency < 50  # 99th percentile < 50ms
    |                                  ^^ PLR2004
314 |             assert max_latency < 100  # Max < 100ms
    |

tests/test_data_ingestion.py:314:34: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
312 |             assert avg_latency < 10  # Average < 10ms
313 |             assert p99_latency < 50  # 99th percentile < 50ms
314 |             assert max_latency < 100  # Max < 100ms
    |                                  ^^^ PLR2004
315 |
316 |     @pytest.mark.asyncio
    |

tests/test_data_ingestion.py:347:29: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
346 |         assert processed_count >= target_events * 0.99  # 99% processed
347 |         assert throughput > 100  # > 100 events/second
    |                             ^^^ PLR2004
348 |
349 |     @pytest.mark.asyncio
    |

tests/test_data_ingestion.py:382:32: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
380 |         memory_leaked = final_memory - baseline_memory
381 |
382 |         assert memory_growth < 100  # Less than 100MB growth
    |                                ^^^ PLR2004
383 |         assert memory_leaked < 10   # Less than 10MB leaked
    |

tests/test_data_ingestion.py:383:32: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
382 |         assert memory_growth < 100  # Less than 100MB growth
383 |         assert memory_leaked < 10   # Less than 10MB leaked
    |                                ^^ PLR2004
    |

tests/test_data_ingestion.py:386:7: F811 Redefinition of unused `MarketDataProcessor` from line 21
    |
386 | class MarketDataProcessor:
    |       ^^^^^^^^^^^^^^^^^^^ F811
387 |     """Mock market data processor for testing."""
    |
    = help: Remove definition: `MarketDataProcessor`

tests/test_data_ingestion.py:389:9: D107 Missing docstring in `__init__`
    |
387 |     """Mock market data processor for testing."""
388 |
389 |     def __init__(self):
    |         ^^^^^^^^ D107
390 |         self.processed_sequences = set()
    |

tests/test_data_ingestion.py:434:7: F811 Redefinition of unused `DataValidator` from line 20
    |
434 | class DataValidator:
    |       ^^^^^^^^^^^^^ F811
435 |     """Mock data validator for testing."""
    |
    = help: Remove definition: `DataValidator`

tests/test_data_ingestion.py:454:9: SIM110 Use `return all(not (ask[0] <= 0 or ask[1] <= 0) for ask in data.get("asks", []))` instead of `for` loop
    |
452 |                   return False
453 |
454 | /         for ask in data.get("asks", []):
455 | |             if ask[0] <= 0 or ask[1] <= 0:
456 | |                 return False
457 | |
458 | |         return True
    | |___________________^ SIM110
459 |
460 |       def validate_ohlcv_data(self, data: dict) -> bool:
    |
    = help: Replace with `return all(not (ask[0] <= 0 or ask[1] <= 0) for ask in data.get("asks", []))`

tests/test_data_ingestion.py:476:9: SIM103 Return the negated condition directly
    |
474 |               return False
475 |
476 | /         if any(data[k] < 0 for k in ["open", "high", "low", "close"]):
477 | |             return False
478 | |
479 | |         return True
    | |___________________^ SIM103
    |
    = help: Inline condition

tests/test_data_ingestion.py:500:100: E501 Line too long (117 > 99)
    |
499 | # Monkey patch for testing
500 | MarketDataL2Event.create_test_event = classmethod(lambda cls, pair, **kwargs: create_test_event(cls, pair, **kwargs))
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
    |

tests/test_end_to_end_integration.py:34:9: D107 Missing docstring in `__init__`
   |
32 |     """Mock Kraken client for testing."""
33 |
34 |     def __init__(self):
   |         ^^^^^^^^ D107
35 |         self.positions = {
36 |             "XRP/USD": {"amount": Decimal("1000"), "avg_price": Decimal("0.5")},
   |

tests/test_end_to_end_integration.py:502:5: T201 `print` found
    |
500 | def run_integration_tests():
501 |     """Run all integration tests."""
502 |     print("=" * 70)
    |     ^^^^^ T201
503 |     print("GAL-FRIDAY END-TO-END INTEGRATION TESTS")
504 |     print("=" * 70)
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:503:5: T201 `print` found
    |
501 |     """Run all integration tests."""
502 |     print("=" * 70)
503 |     print("GAL-FRIDAY END-TO-END INTEGRATION TESTS")
    |     ^^^^^ T201
504 |     print("=" * 70)
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:504:5: T201 `print` found
    |
502 |     print("=" * 70)
503 |     print("GAL-FRIDAY END-TO-END INTEGRATION TESTS")
504 |     print("=" * 70)
    |     ^^^^^ T201
505 |
506 |     print("\nTesting complete system integration...")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:506:5: T201 `print` found
    |
504 |     print("=" * 70)
505 |
506 |     print("\nTesting complete system integration...")
    |     ^^^^^ T201
507 |     print("✓ Market data → Prediction flow")
508 |     print("✓ Prediction → Trading signal flow")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:507:5: T201 `print` found
    |
506 |     print("\nTesting complete system integration...")
507 |     print("✓ Market data → Prediction flow")
    |     ^^^^^ T201
508 |     print("✓ Prediction → Trading signal flow")
509 |     print("✓ Model registry lifecycle")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:508:5: T201 `print` found
    |
506 |     print("\nTesting complete system integration...")
507 |     print("✓ Market data → Prediction flow")
508 |     print("✓ Prediction → Trading signal flow")
    |     ^^^^^ T201
509 |     print("✓ Model registry lifecycle")
510 |     print("✓ A/B testing experiments")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:509:5: T201 `print` found
    |
507 |     print("✓ Market data → Prediction flow")
508 |     print("✓ Prediction → Trading signal flow")
509 |     print("✓ Model registry lifecycle")
    |     ^^^^^ T201
510 |     print("✓ A/B testing experiments")
511 |     print("✓ Portfolio reconciliation")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:510:5: T201 `print` found
    |
508 |     print("✓ Prediction → Trading signal flow")
509 |     print("✓ Model registry lifecycle")
510 |     print("✓ A/B testing experiments")
    |     ^^^^^ T201
511 |     print("✓ Portfolio reconciliation")
512 |     print("✓ WebSocket management")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:511:5: T201 `print` found
    |
509 |     print("✓ Model registry lifecycle")
510 |     print("✓ A/B testing experiments")
511 |     print("✓ Portfolio reconciliation")
    |     ^^^^^ T201
512 |     print("✓ WebSocket management")
513 |     print("✓ Drift detection")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:512:5: T201 `print` found
    |
510 |     print("✓ A/B testing experiments")
511 |     print("✓ Portfolio reconciliation")
512 |     print("✓ WebSocket management")
    |     ^^^^^ T201
513 |     print("✓ Drift detection")
514 |     print("✓ Performance optimization")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:513:5: T201 `print` found
    |
511 |     print("✓ Portfolio reconciliation")
512 |     print("✓ WebSocket management")
513 |     print("✓ Drift detection")
    |     ^^^^^ T201
514 |     print("✓ Performance optimization")
515 |     print("✓ Dashboard metrics")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:514:5: T201 `print` found
    |
512 |     print("✓ WebSocket management")
513 |     print("✓ Drift detection")
514 |     print("✓ Performance optimization")
    |     ^^^^^ T201
515 |     print("✓ Dashboard metrics")
516 |     print("✓ Full trading cycle")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:515:5: T201 `print` found
    |
513 |     print("✓ Drift detection")
514 |     print("✓ Performance optimization")
515 |     print("✓ Dashboard metrics")
    |     ^^^^^ T201
516 |     print("✓ Full trading cycle")
517 |     print("✓ System resilience")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:516:5: T201 `print` found
    |
514 |     print("✓ Performance optimization")
515 |     print("✓ Dashboard metrics")
516 |     print("✓ Full trading cycle")
    |     ^^^^^ T201
517 |     print("✓ System resilience")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:517:5: T201 `print` found
    |
515 |     print("✓ Dashboard metrics")
516 |     print("✓ Full trading cycle")
517 |     print("✓ System resilience")
    |     ^^^^^ T201
518 |
519 |     print("\nAll integration tests passed! ✅")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:519:5: T201 `print` found
    |
517 |     print("✓ System resilience")
518 |
519 |     print("\nAll integration tests passed! ✅")
    |     ^^^^^ T201
520 |     print("\nThe system demonstrates:")
521 |     print("- Seamless component integration")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:520:5: T201 `print` found
    |
519 |     print("\nAll integration tests passed! ✅")
520 |     print("\nThe system demonstrates:")
    |     ^^^^^ T201
521 |     print("- Seamless component integration")
522 |     print("- Proper event flow throughout")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:521:5: T201 `print` found
    |
519 |     print("\nAll integration tests passed! ✅")
520 |     print("\nThe system demonstrates:")
521 |     print("- Seamless component integration")
    |     ^^^^^ T201
522 |     print("- Proper event flow throughout")
523 |     print("- Resilient error handling")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:522:5: T201 `print` found
    |
520 |     print("\nThe system demonstrates:")
521 |     print("- Seamless component integration")
522 |     print("- Proper event flow throughout")
    |     ^^^^^ T201
523 |     print("- Resilient error handling")
524 |     print("- Performance optimization")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:523:5: T201 `print` found
    |
521 |     print("- Seamless component integration")
522 |     print("- Proper event flow throughout")
523 |     print("- Resilient error handling")
    |     ^^^^^ T201
524 |     print("- Performance optimization")
525 |     print("- Complete feature coverage")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:524:5: T201 `print` found
    |
522 |     print("- Proper event flow throughout")
523 |     print("- Resilient error handling")
524 |     print("- Performance optimization")
    |     ^^^^^ T201
525 |     print("- Complete feature coverage")
    |
    = help: Remove `print`

tests/test_end_to_end_integration.py:525:5: T201 `print` found
    |
523 |     print("- Resilient error handling")
524 |     print("- Performance optimization")
525 |     print("- Complete feature coverage")
    |     ^^^^^ T201
    |
    = help: Remove `print`

tests/test_execution_handler.py:29:9: D107 Missing docstring in `__init__`
   |
27 |     """Comprehensive mock of Kraken API for testing."""
28 |
29 |     def __init__(self):
   |         ^^^^^^^^ D107
30 |         self.orders = {}
31 |         self.order_counter = 1000
   |

tests/test_execution_handler.py:76:100: E501 Line too long (115 > 99)
   |
74 |                 "ordertype": params["ordertype"],
75 |                 "price": params.get("price", "0"),
76 |                 "order": f"{params['type']} {params['volume']} {params['pair']} @ {params.get('price', 'market')}",
   |                                                                                                    ^^^^^^^^^^^^^^^^ E501
77 |             },
78 |             "vol": params["volume"],
   |

tests/test_execution_handler.py:112:62: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
111 |         # Auto-fill market orders quickly
112 |         if order["descr"]["ordertype"] == "market" and age > 0.5:
    |                                                              ^^^ PLR2004
113 |             self._fill_order(txid)
    |

tests/test_execution_handler.py:117:22: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
115 |         # Partially fill limit orders over time
116 |         elif order["descr"]["ordertype"] == "limit" and order["status"] == "open":
117 |             if age > 2:
    |                      ^ PLR2004
118 |                 self._partially_fill_order(txid, Decimal("0.3"))
119 |             if age > 5:
    |

tests/test_execution_handler.py:119:22: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
117 |             if age > 2:
118 |                 self._partially_fill_order(txid, Decimal("0.3"))
119 |             if age > 5:
    |                      ^ PLR2004
120 |                 self._partially_fill_order(txid, Decimal("0.7"))
121 |             if age > 10:
    |

tests/test_execution_handler.py:121:22: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
119 |             if age > 5:
120 |                 self._partially_fill_order(txid, Decimal("0.7"))
121 |             if age > 10:
    |                      ^^ PLR2004
122 |                 self._fill_order(txid)
    |

tests/test_execution_handler.py:202:100: E501 Line too long (103 > 99)
    |
200 |             # Add some slippage for market orders
201 |             if order["descr"]["ordertype"] == "market":
202 |                 slippage = Decimal("0.0001") if order["descr"]["type"] == "buy" else Decimal("-0.0001")
    |                                                                                                    ^^^^ E501
203 |                 order["price"] = str(base_price + slippage)
204 |             else:
    |

tests/test_execution_handler.py:384:100: E501 Line too long (110 > 99)
    |
383 |         # Check for partial fill reports
384 |         partial_reports = [r for r in execution_reports if r.order_status == "OPEN" and r.quantity_filled > 0]
    |                                                                                                    ^^^^^^^^^^^ E501
385 |         assert len(partial_reports) > 0
386 |         assert partial_reports[0].quantity_filled < partial_reports[0].quantity_ordered
    |

tests/test_execution_handler.py:466:13: B007 Loop control variable `i` not used within loop body
    |
464 |         # Send multiple orders rapidly
465 |         signals = []
466 |         for i in range(5):
    |             ^ B007
467 |             signal = TradeSignalApprovedEvent.create_test_signal(
468 |                 pair="XRP/USD",
    |
    = help: Rename unused `i` to `_i`

tests/test_execution_handler.py:482:28: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
480 |         # Should take at least 4 seconds due to rate limiting (1 call/second)
481 |         duration = end_time - start_time
482 |         assert duration >= 3  # Allow some tolerance
    |                            ^ PLR2004
483 |
484 |     @pytest.mark.asyncio
    |

tests/test_halt_mechanism.py:20:100: E501 Line too long (101 > 99)
   |
18 |     """Test suite for HaltCoordinator functionality."""
19 |
20 |     def test_halt_coordinator_initialization(self, mock_config_manager, pubsub_manager, mock_logger):
   |                                                                                                    ^^ E501
21 |         """Test HALT coordinator initializes with correct conditions."""
22 |         coordinator = HaltCoordinator(mock_config_manager, pubsub_manager, mock_logger)
   |

tests/test_halt_mechanism.py:119:37: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
117 |         # Should be halted
118 |         assert monitoring.is_halted()
119 |         assert len(state_events) >= 2  # RUNNING + HALTED
    |                                     ^ PLR2004
120 |         assert state_events[-1].new_state == "HALTED"
121 |         assert "drawdown" in state_events[-1].reason.lower()
    |

tests/test_halt_mechanism.py:250:39: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
249 |         # Should have commands for both positions
250 |         assert len(close_commands) == 2
    |                                       ^ PLR2004
251 |
252 |         # Check XRP position closure
    |

tests/test_integration.py:44:16: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
   |
42 |         # Set up event capture
43 |         async def capture_market_data(event):
44 |             if isinstance(event, (MarketDataL2Event, MarketDataOHLCVEvent)):
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
45 |                 events_captured["market_data"].append(event)
   |
   = help: Convert to `X | Y`

tests/test_integration.py:66:100: E501 Line too long (101 > 99)
   |
64 |         integrated_system.pubsub.subscribe(EventType.MARKET_DATA_L2, capture_market_data)
65 |         integrated_system.pubsub.subscribe(EventType.PREDICTION, capture_predictions)
66 |         integrated_system.pubsub.subscribe(EventType.TRADE_SIGNAL_PROPOSED, capture_proposed_signals)
   |                                                                                                    ^^ E501
67 |         integrated_system.pubsub.subscribe(EventType.TRADE_SIGNAL_APPROVED, capture_approved_signals)
68 |         integrated_system.pubsub.subscribe(EventType.EXECUTION_REPORT, capture_execution_reports)
   |

tests/test_integration.py:67:100: E501 Line too long (101 > 99)
   |
65 |         integrated_system.pubsub.subscribe(EventType.PREDICTION, capture_predictions)
66 |         integrated_system.pubsub.subscribe(EventType.TRADE_SIGNAL_PROPOSED, capture_proposed_signals)
67 |         integrated_system.pubsub.subscribe(EventType.TRADE_SIGNAL_APPROVED, capture_approved_signals)
   |                                                                                                    ^^ E501
68 |         integrated_system.pubsub.subscribe(EventType.EXECUTION_REPORT, capture_execution_reports)
   |

tests/test_integration.py:252:38: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
251 |         # Verify state transitions
252 |         assert len(state_changes) >= 3
    |                                      ^ PLR2004
253 |         assert state_changes[0].new_state == "RUNNING"
254 |         assert state_changes[1].new_state == "HALTED"
    |

tests/test_integration.py:323:29: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
322 |         # System should handle at least 50 events/second
323 |         assert throughput > 50
    |                             ^^ PLR2004
324 |
325 |     @pytest.mark.asyncio
    |

tests/test_integration.py:352:13: SIM102 Use a single `if` statement instead of nested `if` statements
    |
351 |           async def track_execution(event):
352 | /             if isinstance(event, ExecutionReportEvent):
353 | |                 if hasattr(event, "metadata") and event.metadata.get("correlation_id") == str(correlation_id):
    | |______________________________________________________________________________________________________________^ SIM102
354 |                       latency = (datetime.now(UTC) - start_time).total_seconds() * 1000
355 |                       latencies.append(latency)
    |
    = help: Combine `if` statements using `and`

tests/test_integration.py:353:100: E501 Line too long (110 > 99)
    |
351 |         async def track_execution(event):
352 |             if isinstance(event, ExecutionReportEvent):
353 |                 if hasattr(event, "metadata") and event.metadata.get("correlation_id") == str(correlation_id):
    |                                                                                                    ^^^^^^^^^^^ E501
354 |                     latency = (datetime.now(UTC) - start_time).total_seconds() * 1000
355 |                     latencies.append(latency)
    |

tests/test_integration.py:372:34: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
370 |         if latencies:
371 |             avg_latency = sum(latencies) / len(latencies)
372 |             assert avg_latency < 1000  # Less than 1 second
    |                                  ^^^^ PLR2004
    |

tests/test_integration.py:384:16: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
383 |         async def track_signals(event):
384 |             if isinstance(event, (TradeSignalApprovedEvent, TradeSignalRejectedEvent)):
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
385 |                 signals_processed.append(event)
    |
    = help: Convert to `X | Y`

tests/test_integration.py:446:42: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
445 |         # Verify all signals were processed
446 |         assert len(signals_processed) == 10
    |                                          ^^ PLR2004
447 |         approved_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalApprovedEvent))
448 |         rejected_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalRejectedEvent))
    |

tests/test_integration.py:447:100: E501 Line too long (101 > 99)
    |
445 |         # Verify all signals were processed
446 |         assert len(signals_processed) == 10
447 |         approved_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalApprovedEvent))
    |                                                                                                    ^^ E501
448 |         rejected_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalRejectedEvent))
449 |         assert approved_count == 5
    |

tests/test_integration.py:448:100: E501 Line too long (101 > 99)
    |
446 |         assert len(signals_processed) == 10
447 |         approved_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalApprovedEvent))
448 |         rejected_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalRejectedEvent))
    |                                                                                                    ^^ E501
449 |         assert approved_count == 5
450 |         assert rejected_count == 5
    |

tests/test_integration.py:449:34: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
447 |         approved_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalApprovedEvent))
448 |         rejected_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalRejectedEvent))
449 |         assert approved_count == 5
    |                                  ^ PLR2004
450 |         assert rejected_count == 5
    |

tests/test_integration.py:450:34: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
448 |         rejected_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalRejectedEvent))
449 |         assert approved_count == 5
450 |         assert rejected_count == 5
    |                                  ^ PLR2004
451 |
452 |     @pytest.mark.asyncio
    |

tests/test_integration.py:487:7: F811 Redefinition of unused `PredictionEvent` from line 19
    |
486 | # Extension for PredictionEvent creation
487 | class PredictionEvent:
    |       ^^^^^^^^^^^^^^^ F811
488 |     """Mock prediction event for testing."""
489 |     def __init__(self, **kwargs):
    |
    = help: Remove definition: `PredictionEvent`

tests/test_integration.py:489:9: D107 Missing docstring in `__init__`
    |
487 | class PredictionEvent:
488 |     """Mock prediction event for testing."""
489 |     def __init__(self, **kwargs):
    |         ^^^^^^^^ D107
490 |         self.__dict__.update(kwargs)
491 |         self.event_type = EventType.PREDICTION
    |

tests/test_integration.py:495:7: F811 Redefinition of unused `TradeSignalRejectedEvent` from line 23
    |
494 | # Extension for TradeSignalRejectedEvent
495 | class TradeSignalRejectedEvent:
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ F811
496 |     """Mock rejected signal event for testing."""
497 |     def __init__(self, **kwargs):
    |
    = help: Remove definition: `TradeSignalRejectedEvent`

tests/test_integration.py:497:9: D107 Missing docstring in `__init__`
    |
495 | class TradeSignalRejectedEvent:
496 |     """Mock rejected signal event for testing."""
497 |     def __init__(self, **kwargs):
    |         ^^^^^^^^ D107
498 |         self.__dict__.update(kwargs)
499 |         self.event_type = EventType.TRADE_SIGNAL_REJECTED
    |

tests/test_intelligence_layer_demo.py:7:5: T201 `print` found
  |
5 | def demonstrate_model_prediction_flow():
6 |     """Show how model predictions flow to trading signals."""
7 |     print("=== Gal-Friday Model Prediction → Trading Signal Flow ===\n")
  |     ^^^^^ T201
8 |
9 |     print("1. Model Prediction Generation:")
  |
  = help: Remove `print`

tests/test_intelligence_layer_demo.py:9:5: T201 `print` found
   |
 7 |     print("=== Gal-Friday Model Prediction → Trading Signal Flow ===\n")
 8 |
 9 |     print("1. Model Prediction Generation:")
   |     ^^^^^ T201
10 |     print("   - XGBoost Model: Generates probability of price increase")
11 |     print("   - RandomForest Model: Generates directional prediction")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:10:5: T201 `print` found
   |
 9 |     print("1. Model Prediction Generation:")
10 |     print("   - XGBoost Model: Generates probability of price increase")
   |     ^^^^^ T201
11 |     print("   - RandomForest Model: Generates directional prediction")
12 |     print("   - LSTM Model: Generates time-series forecast")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:11:5: T201 `print` found
   |
 9 |     print("1. Model Prediction Generation:")
10 |     print("   - XGBoost Model: Generates probability of price increase")
11 |     print("   - RandomForest Model: Generates directional prediction")
   |     ^^^^^ T201
12 |     print("   - LSTM Model: Generates time-series forecast")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:12:5: T201 `print` found
   |
10 |     print("   - XGBoost Model: Generates probability of price increase")
11 |     print("   - RandomForest Model: Generates directional prediction")
12 |     print("   - LSTM Model: Generates time-series forecast")
   |     ^^^^^ T201
13 |
14 |     print("\n2. Prediction Event Flow:")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:14:5: T201 `print` found
   |
12 |     print("   - LSTM Model: Generates time-series forecast")
13 |
14 |     print("\n2. Prediction Event Flow:")
   |     ^^^^^ T201
15 |     print("   Model → PredictionEvent → PubSub → StrategyArbitrator")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:15:5: T201 `print` found
   |
14 |     print("\n2. Prediction Event Flow:")
15 |     print("   Model → PredictionEvent → PubSub → StrategyArbitrator")
   |     ^^^^^ T201
16 |
17 |     print("\n3. Strategy Arbitrator Processing:")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:17:5: T201 `print` found
   |
15 |     print("   Model → PredictionEvent → PubSub → StrategyArbitrator")
16 |
17 |     print("\n3. Strategy Arbitrator Processing:")
   |     ^^^^^ T201
18 |     print("   a) Receives PredictionEvent with:")
19 |     print("      - prediction_value: 0.75 (75% probability of price increase)")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:18:5: T201 `print` found
   |
17 |     print("\n3. Strategy Arbitrator Processing:")
18 |     print("   a) Receives PredictionEvent with:")
   |     ^^^^^ T201
19 |     print("      - prediction_value: 0.75 (75% probability of price increase)")
20 |     print("      - trading_pair: 'XRP/USD'")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:19:5: T201 `print` found
   |
17 |     print("\n3. Strategy Arbitrator Processing:")
18 |     print("   a) Receives PredictionEvent with:")
19 |     print("      - prediction_value: 0.75 (75% probability of price increase)")
   |     ^^^^^ T201
20 |     print("      - trading_pair: 'XRP/USD'")
21 |     print("      - associated_features: {momentum_5: 0.02, rsi: 45}")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:20:5: T201 `print` found
   |
18 |     print("   a) Receives PredictionEvent with:")
19 |     print("      - prediction_value: 0.75 (75% probability of price increase)")
20 |     print("      - trading_pair: 'XRP/USD'")
   |     ^^^^^ T201
21 |     print("      - associated_features: {momentum_5: 0.02, rsi: 45}")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:21:5: T201 `print` found
   |
19 |     print("      - prediction_value: 0.75 (75% probability of price increase)")
20 |     print("      - trading_pair: 'XRP/USD'")
21 |     print("      - associated_features: {momentum_5: 0.02, rsi: 45}")
   |     ^^^^^ T201
22 |
23 |     print("\n   b) Applies Strategy Logic:")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:23:5: T201 `print` found
   |
21 |     print("      - associated_features: {momentum_5: 0.02, rsi: 45}")
22 |
23 |     print("\n   b) Applies Strategy Logic:")
   |     ^^^^^ T201
24 |     print("      - Buy threshold: 0.65 ✓ (0.75 > 0.65)")
25 |     print("      - Confirmation rule: momentum_5 > 0 ✓")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:24:5: T201 `print` found
   |
23 |     print("\n   b) Applies Strategy Logic:")
24 |     print("      - Buy threshold: 0.65 ✓ (0.75 > 0.65)")
   |     ^^^^^ T201
25 |     print("      - Confirmation rule: momentum_5 > 0 ✓")
26 |     print("      - Result: BUY signal generated")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:25:5: T201 `print` found
   |
23 |     print("\n   b) Applies Strategy Logic:")
24 |     print("      - Buy threshold: 0.65 ✓ (0.75 > 0.65)")
25 |     print("      - Confirmation rule: momentum_5 > 0 ✓")
   |     ^^^^^ T201
26 |     print("      - Result: BUY signal generated")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:26:5: T201 `print` found
   |
24 |     print("      - Buy threshold: 0.65 ✓ (0.75 > 0.65)")
25 |     print("      - Confirmation rule: momentum_5 > 0 ✓")
26 |     print("      - Result: BUY signal generated")
   |     ^^^^^ T201
27 |
28 |     print("\n   c) Calculates Risk Parameters:")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:28:5: T201 `print` found
   |
26 |     print("      - Result: BUY signal generated")
27 |
28 |     print("\n   c) Calculates Risk Parameters:")
   |     ^^^^^ T201
29 |     print("      - Current price: $0.5000")
30 |     print("      - Stop loss: $0.4900 (2% risk)")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:29:5: T201 `print` found
   |
28 |     print("\n   c) Calculates Risk Parameters:")
29 |     print("      - Current price: $0.5000")
   |     ^^^^^ T201
30 |     print("      - Stop loss: $0.4900 (2% risk)")
31 |     print("      - Take profit: $0.5200 (4% reward)")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:30:5: T201 `print` found
   |
28 |     print("\n   c) Calculates Risk Parameters:")
29 |     print("      - Current price: $0.5000")
30 |     print("      - Stop loss: $0.4900 (2% risk)")
   |     ^^^^^ T201
31 |     print("      - Take profit: $0.5200 (4% reward)")
32 |     print("      - Risk/Reward ratio: 1:2")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:31:5: T201 `print` found
   |
29 |     print("      - Current price: $0.5000")
30 |     print("      - Stop loss: $0.4900 (2% risk)")
31 |     print("      - Take profit: $0.5200 (4% reward)")
   |     ^^^^^ T201
32 |     print("      - Risk/Reward ratio: 1:2")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:32:5: T201 `print` found
   |
30 |     print("      - Stop loss: $0.4900 (2% risk)")
31 |     print("      - Take profit: $0.5200 (4% reward)")
32 |     print("      - Risk/Reward ratio: 1:2")
   |     ^^^^^ T201
33 |
34 |     print("\n4. Trade Signal Published:")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:34:5: T201 `print` found
   |
32 |     print("      - Risk/Reward ratio: 1:2")
33 |
34 |     print("\n4. Trade Signal Published:")
   |     ^^^^^ T201
35 |     print("   - TradeSignalProposedEvent → RiskManager → ExecutionHandler")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:35:5: T201 `print` found
   |
34 |     print("\n4. Trade Signal Published:")
35 |     print("   - TradeSignalProposedEvent → RiskManager → ExecutionHandler")
   |     ^^^^^ T201
36 |
37 |     # Example prediction flow
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:38:5: T201 `print` found
   |
37 |     # Example prediction flow
38 |     print("\n5. Example Prediction Processing:")
   |     ^^^^^ T201
39 |     predictions = [
40 |         {"model": "XGBoost", "value": 0.75, "action": "BUY", "confidence": "HIGH"},
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:46:9: T201 `print` found
   |
45 |     for pred in predictions:
46 |         print(f"   - {pred['model']}: {pred['value']:.2f} → {pred['action']} ({pred['confidence']})")
   |         ^^^^^ T201
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:46:100: E501 Line too long (101 > 99)
   |
45 |     for pred in predictions:
46 |         print(f"   - {pred['model']}: {pred['value']:.2f} → {pred['action']} ({pred['confidence']})")
   |                                                                                                    ^^ E501
   |

tests/test_intelligence_layer_demo.py:51:5: T201 `print` found
   |
49 | def demonstrate_ab_testing():
50 |     """Demonstrate A/B testing framework."""
51 |     print("\n\n=== Gal-Friday A/B Testing Framework ===\n")
   |     ^^^^^ T201
52 |
53 |     print("1. Experiment Configuration:")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:53:5: T201 `print` found
   |
51 |     print("\n\n=== Gal-Friday A/B Testing Framework ===\n")
52 |
53 |     print("1. Experiment Configuration:")
   |     ^^^^^ T201
54 |     print("   - Control: XGBoost v1.0 (current production)")
55 |     print("   - Treatment: XGBoost v1.1 (improved features)")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:54:5: T201 `print` found
   |
53 |     print("1. Experiment Configuration:")
54 |     print("   - Control: XGBoost v1.0 (current production)")
   |     ^^^^^ T201
55 |     print("   - Treatment: XGBoost v1.1 (improved features)")
56 |     print("   - Traffic split: 50/50")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:55:5: T201 `print` found
   |
53 |     print("1. Experiment Configuration:")
54 |     print("   - Control: XGBoost v1.0 (current production)")
55 |     print("   - Treatment: XGBoost v1.1 (improved features)")
   |     ^^^^^ T201
56 |     print("   - Traffic split: 50/50")
57 |     print("   - Minimum samples: 1000 per variant")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:56:5: T201 `print` found
   |
54 |     print("   - Control: XGBoost v1.0 (current production)")
55 |     print("   - Treatment: XGBoost v1.1 (improved features)")
56 |     print("   - Traffic split: 50/50")
   |     ^^^^^ T201
57 |     print("   - Minimum samples: 1000 per variant")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:57:5: T201 `print` found
   |
55 |     print("   - Treatment: XGBoost v1.1 (improved features)")
56 |     print("   - Traffic split: 50/50")
57 |     print("   - Minimum samples: 1000 per variant")
   |     ^^^^^ T201
58 |
59 |     print("\n2. Traffic Routing Strategies:")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:59:5: T201 `print` found
   |
57 |     print("   - Minimum samples: 1000 per variant")
58 |
59 |     print("\n2. Traffic Routing Strategies:")
   |     ^^^^^ T201
60 |     print("   ✓ Random: Randomly assign predictions")
61 |     print("   ✓ Deterministic: Hash-based consistent assignment")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:60:5: T201 `print` found
   |
59 |     print("\n2. Traffic Routing Strategies:")
60 |     print("   ✓ Random: Randomly assign predictions")
   |     ^^^^^ T201
61 |     print("   ✓ Deterministic: Hash-based consistent assignment")
62 |     print("   ✓ Epsilon-Greedy: Explore 10%, exploit best 90%")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:61:5: T201 `print` found
   |
59 |     print("\n2. Traffic Routing Strategies:")
60 |     print("   ✓ Random: Randomly assign predictions")
61 |     print("   ✓ Deterministic: Hash-based consistent assignment")
   |     ^^^^^ T201
62 |     print("   ✓ Epsilon-Greedy: Explore 10%, exploit best 90%")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:62:5: T201 `print` found
   |
60 |     print("   ✓ Random: Randomly assign predictions")
61 |     print("   ✓ Deterministic: Hash-based consistent assignment")
62 |     print("   ✓ Epsilon-Greedy: Explore 10%, exploit best 90%")
   |     ^^^^^ T201
63 |
64 |     print("\n3. Real-time Experiment Monitoring:")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:64:5: T201 `print` found
   |
62 |     print("   ✓ Epsilon-Greedy: Explore 10%, exploit best 90%")
63 |
64 |     print("\n3. Real-time Experiment Monitoring:")
   |     ^^^^^ T201
65 |
66 |     # Simulate experiment progress
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:85:9: T201 `print` found
   |
84 |     for variant, data in experiment_data.items():
85 |         print(f"\n   {variant.upper()} Model:")
   |         ^^^^^ T201
86 |         print(f"   - Samples: {data['samples']:,}")
87 |         print(f"   - Accuracy: {data['accuracy']:.1%}")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:86:9: T201 `print` found
   |
84 |     for variant, data in experiment_data.items():
85 |         print(f"\n   {variant.upper()} Model:")
86 |         print(f"   - Samples: {data['samples']:,}")
   |         ^^^^^ T201
87 |         print(f"   - Accuracy: {data['accuracy']:.1%}")
88 |         print(f"   - Win Rate: {data['profitable']/data['signals']:.1%}")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:87:9: T201 `print` found
   |
85 |         print(f"\n   {variant.upper()} Model:")
86 |         print(f"   - Samples: {data['samples']:,}")
87 |         print(f"   - Accuracy: {data['accuracy']:.1%}")
   |         ^^^^^ T201
88 |         print(f"   - Win Rate: {data['profitable']/data['signals']:.1%}")
89 |         print(f"   - Total Return: ${data['total_return']:,.2f}")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:88:9: T201 `print` found
   |
86 |         print(f"   - Samples: {data['samples']:,}")
87 |         print(f"   - Accuracy: {data['accuracy']:.1%}")
88 |         print(f"   - Win Rate: {data['profitable']/data['signals']:.1%}")
   |         ^^^^^ T201
89 |         print(f"   - Total Return: ${data['total_return']:,.2f}")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:89:9: T201 `print` found
   |
87 |         print(f"   - Accuracy: {data['accuracy']:.1%}")
88 |         print(f"   - Win Rate: {data['profitable']/data['signals']:.1%}")
89 |         print(f"   - Total Return: ${data['total_return']:,.2f}")
   |         ^^^^^ T201
90 |
91 |     # Calculate statistics
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:95:5: T201 `print` found
   |
93 |             experiment_data["control"]["accuracy"] * 100)
94 |
95 |     print("\n4. Statistical Analysis:")
   |     ^^^^^ T201
96 |     print(f"   - Lift: +{lift:.1f}%")
97 |     print("   - P-value: 0.023 (significant at 95% confidence)")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:96:5: T201 `print` found
   |
95 |     print("\n4. Statistical Analysis:")
96 |     print(f"   - Lift: +{lift:.1f}%")
   |     ^^^^^ T201
97 |     print("   - P-value: 0.023 (significant at 95% confidence)")
98 |     print("   - Recommendation: Promote treatment to production ✓")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:97:5: T201 `print` found
   |
95 |     print("\n4. Statistical Analysis:")
96 |     print(f"   - Lift: +{lift:.1f}%")
97 |     print("   - P-value: 0.023 (significant at 95% confidence)")
   |     ^^^^^ T201
98 |     print("   - Recommendation: Promote treatment to production ✓")
   |
   = help: Remove `print`

tests/test_intelligence_layer_demo.py:98:5: T201 `print` found
    |
 96 |     print(f"   - Lift: +{lift:.1f}%")
 97 |     print("   - P-value: 0.023 (significant at 95% confidence)")
 98 |     print("   - Recommendation: Promote treatment to production ✓")
    |     ^^^^^ T201
 99 |
100 |     print("\n5. Automated Actions:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:100:5: T201 `print` found
    |
 98 |     print("   - Recommendation: Promote treatment to production ✓")
 99 |
100 |     print("\n5. Automated Actions:")
    |     ^^^^^ T201
101 |     print("   - Experiment stopped at statistical significance")
102 |     print("   - Winner (treatment) promoted to staging")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:101:5: T201 `print` found
    |
100 |     print("\n5. Automated Actions:")
101 |     print("   - Experiment stopped at statistical significance")
    |     ^^^^^ T201
102 |     print("   - Winner (treatment) promoted to staging")
103 |     print("   - Alert sent to team with results")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:102:5: T201 `print` found
    |
100 |     print("\n5. Automated Actions:")
101 |     print("   - Experiment stopped at statistical significance")
102 |     print("   - Winner (treatment) promoted to staging")
    |     ^^^^^ T201
103 |     print("   - Alert sent to team with results")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:103:5: T201 `print` found
    |
101 |     print("   - Experiment stopped at statistical significance")
102 |     print("   - Winner (treatment) promoted to staging")
103 |     print("   - Alert sent to team with results")
    |     ^^^^^ T201
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:108:5: T201 `print` found
    |
106 | def demonstrate_drift_detection():
107 |     """Demonstrate drift detection capabilities."""
108 |     print("\n\n=== Gal-Friday Drift Detection ===\n")
    |     ^^^^^ T201
109 |
110 |     print("1. Types of Drift Monitored:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:110:5: T201 `print` found
    |
108 |     print("\n\n=== Gal-Friday Drift Detection ===\n")
109 |
110 |     print("1. Types of Drift Monitored:")
    |     ^^^^^ T201
111 |     print("   - Data Drift: Changes in input feature distributions")
112 |     print("   - Concept Drift: Changes in P(Y|X) relationships")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:111:5: T201 `print` found
    |
110 |     print("1. Types of Drift Monitored:")
111 |     print("   - Data Drift: Changes in input feature distributions")
    |     ^^^^^ T201
112 |     print("   - Concept Drift: Changes in P(Y|X) relationships")
113 |     print("   - Prediction Drift: Changes in model output distribution")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:112:5: T201 `print` found
    |
110 |     print("1. Types of Drift Monitored:")
111 |     print("   - Data Drift: Changes in input feature distributions")
112 |     print("   - Concept Drift: Changes in P(Y|X) relationships")
    |     ^^^^^ T201
113 |     print("   - Prediction Drift: Changes in model output distribution")
114 |     print("   - Performance Drift: Degradation in accuracy/profits")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:113:5: T201 `print` found
    |
111 |     print("   - Data Drift: Changes in input feature distributions")
112 |     print("   - Concept Drift: Changes in P(Y|X) relationships")
113 |     print("   - Prediction Drift: Changes in model output distribution")
    |     ^^^^^ T201
114 |     print("   - Performance Drift: Degradation in accuracy/profits")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:114:5: T201 `print` found
    |
112 |     print("   - Concept Drift: Changes in P(Y|X) relationships")
113 |     print("   - Prediction Drift: Changes in model output distribution")
114 |     print("   - Performance Drift: Degradation in accuracy/profits")
    |     ^^^^^ T201
115 |
116 |     print("\n2. Drift Detection Methods:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:116:5: T201 `print` found
    |
114 |     print("   - Performance Drift: Degradation in accuracy/profits")
115 |
116 |     print("\n2. Drift Detection Methods:")
    |     ^^^^^ T201
117 |     print("   - Population Stability Index (PSI)")
118 |     print("   - Kolmogorov-Smirnov Test")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:117:5: T201 `print` found
    |
116 |     print("\n2. Drift Detection Methods:")
117 |     print("   - Population Stability Index (PSI)")
    |     ^^^^^ T201
118 |     print("   - Kolmogorov-Smirnov Test")
119 |     print("   - Wasserstein Distance")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:118:5: T201 `print` found
    |
116 |     print("\n2. Drift Detection Methods:")
117 |     print("   - Population Stability Index (PSI)")
118 |     print("   - Kolmogorov-Smirnov Test")
    |     ^^^^^ T201
119 |     print("   - Wasserstein Distance")
120 |     print("   - Performance Metrics Tracking")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:119:5: T201 `print` found
    |
117 |     print("   - Population Stability Index (PSI)")
118 |     print("   - Kolmogorov-Smirnov Test")
119 |     print("   - Wasserstein Distance")
    |     ^^^^^ T201
120 |     print("   - Performance Metrics Tracking")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:120:5: T201 `print` found
    |
118 |     print("   - Kolmogorov-Smirnov Test")
119 |     print("   - Wasserstein Distance")
120 |     print("   - Performance Metrics Tracking")
    |     ^^^^^ T201
121 |
122 |     print("\n3. Example Drift Detection:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:122:5: T201 `print` found
    |
120 |     print("   - Performance Metrics Tracking")
121 |
122 |     print("\n3. Example Drift Detection:")
    |     ^^^^^ T201
123 |
124 |     drift_examples = [
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:152:9: T201 `print` found
    |
151 |     for drift in drift_examples:
152 |         print(f"\n   {drift['type']}:")
    |         ^^^^^ T201
153 |         print(f"   - Feature: {drift['feature']}")
154 |         print(f"   - Baseline: {drift['baseline']:.2f} → Current: {drift['current']:.2f}")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:153:9: T201 `print` found
    |
151 |     for drift in drift_examples:
152 |         print(f"\n   {drift['type']}:")
153 |         print(f"   - Feature: {drift['feature']}")
    |         ^^^^^ T201
154 |         print(f"   - Baseline: {drift['baseline']:.2f} → Current: {drift['current']:.2f}")
155 |         print(f"   - PSI Score: {drift['psi']:.3f}")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:154:9: T201 `print` found
    |
152 |         print(f"\n   {drift['type']}:")
153 |         print(f"   - Feature: {drift['feature']}")
154 |         print(f"   - Baseline: {drift['baseline']:.2f} → Current: {drift['current']:.2f}")
    |         ^^^^^ T201
155 |         print(f"   - PSI Score: {drift['psi']:.3f}")
156 |         print(f"   - Status: {drift['status']} {'⚠️' if drift['status'] != 'OK' else '✓'}")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:155:9: T201 `print` found
    |
153 |         print(f"   - Feature: {drift['feature']}")
154 |         print(f"   - Baseline: {drift['baseline']:.2f} → Current: {drift['current']:.2f}")
155 |         print(f"   - PSI Score: {drift['psi']:.3f}")
    |         ^^^^^ T201
156 |         print(f"   - Status: {drift['status']} {'⚠️' if drift['status'] != 'OK' else '✓'}")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:156:9: T201 `print` found
    |
154 |         print(f"   - Baseline: {drift['baseline']:.2f} → Current: {drift['current']:.2f}")
155 |         print(f"   - PSI Score: {drift['psi']:.3f}")
156 |         print(f"   - Status: {drift['status']} {'⚠️' if drift['status'] != 'OK' else '✓'}")
    |         ^^^^^ T201
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:161:5: T201 `print` found
    |
159 | def demonstrate_automated_retraining():
160 |     """Demonstrate automated retraining pipeline."""
161 |     print("\n\n=== Gal-Friday Automated Retraining ===\n")
    |     ^^^^^ T201
162 |
163 |     print("1. Retraining Triggers:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:163:5: T201 `print` found
    |
161 |     print("\n\n=== Gal-Friday Automated Retraining ===\n")
162 |
163 |     print("1. Retraining Triggers:")
    |     ^^^^^ T201
164 |     print("   ✓ Scheduled: Every 30 days")
165 |     print("   ✓ Drift Detected: PSI > 0.1")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:164:5: T201 `print` found
    |
163 |     print("1. Retraining Triggers:")
164 |     print("   ✓ Scheduled: Every 30 days")
    |     ^^^^^ T201
165 |     print("   ✓ Drift Detected: PSI > 0.1")
166 |     print("   ✓ Performance Degraded: Accuracy drop > 10%")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:165:5: T201 `print` found
    |
163 |     print("1. Retraining Triggers:")
164 |     print("   ✓ Scheduled: Every 30 days")
165 |     print("   ✓ Drift Detected: PSI > 0.1")
    |     ^^^^^ T201
166 |     print("   ✓ Performance Degraded: Accuracy drop > 10%")
167 |     print("   ✓ Manual: On-demand retraining")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:166:5: T201 `print` found
    |
164 |     print("   ✓ Scheduled: Every 30 days")
165 |     print("   ✓ Drift Detected: PSI > 0.1")
166 |     print("   ✓ Performance Degraded: Accuracy drop > 10%")
    |     ^^^^^ T201
167 |     print("   ✓ Manual: On-demand retraining")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:167:5: T201 `print` found
    |
165 |     print("   ✓ Drift Detected: PSI > 0.1")
166 |     print("   ✓ Performance Degraded: Accuracy drop > 10%")
167 |     print("   ✓ Manual: On-demand retraining")
    |     ^^^^^ T201
168 |
169 |     print("\n2. Retraining Pipeline:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:169:5: T201 `print` found
    |
167 |     print("   ✓ Manual: On-demand retraining")
168 |
169 |     print("\n2. Retraining Pipeline:")
    |     ^^^^^ T201
170 |
171 |     pipeline_steps = [
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:180:9: T201 `print` found
    |
179 |     for i, (step, description, status) in enumerate(pipeline_steps, 1):
180 |         print(f"   Step {i}: {step}")
    |         ^^^^^ T201
181 |         print(f"           {description} {status}")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:181:9: T201 `print` found
    |
179 |     for i, (step, description, status) in enumerate(pipeline_steps, 1):
180 |         print(f"   Step {i}: {step}")
181 |         print(f"           {description} {status}")
    |         ^^^^^ T201
182 |
183 |     print("\n3. Example Retraining Job:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:183:5: T201 `print` found
    |
181 |         print(f"           {description} {status}")
182 |
183 |     print("\n3. Example Retraining Job:")
    |     ^^^^^ T201
184 |     job_info = {
185 |         "job_id": "retrain_20240115_drift",
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:194:5: T201 `print` found
    |
192 |     }
193 |
194 |     print(f"   Job ID: {job_info['job_id']}")
    |     ^^^^^ T201
195 |     print(f"   Trigger: {job_info['trigger']}")
196 |     print(f"   Model: {job_info['model']}")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:195:5: T201 `print` found
    |
194 |     print(f"   Job ID: {job_info['job_id']}")
195 |     print(f"   Trigger: {job_info['trigger']}")
    |     ^^^^^ T201
196 |     print(f"   Model: {job_info['model']}")
197 |     print(f"   Duration: {job_info['duration']}")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:196:5: T201 `print` found
    |
194 |     print(f"   Job ID: {job_info['job_id']}")
195 |     print(f"   Trigger: {job_info['trigger']}")
196 |     print(f"   Model: {job_info['model']}")
    |     ^^^^^ T201
197 |     print(f"   Duration: {job_info['duration']}")
198 |     print(f"   Training Samples: {job_info['samples']:,}")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:197:5: T201 `print` found
    |
195 |     print(f"   Trigger: {job_info['trigger']}")
196 |     print(f"   Model: {job_info['model']}")
197 |     print(f"   Duration: {job_info['duration']}")
    |     ^^^^^ T201
198 |     print(f"   Training Samples: {job_info['samples']:,}")
199 |     print(f"   Performance Improvement: +{job_info['performance_improvement']}%")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:198:5: T201 `print` found
    |
196 |     print(f"   Model: {job_info['model']}")
197 |     print(f"   Duration: {job_info['duration']}")
198 |     print(f"   Training Samples: {job_info['samples']:,}")
    |     ^^^^^ T201
199 |     print(f"   Performance Improvement: +{job_info['performance_improvement']}%")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:199:5: T201 `print` found
    |
197 |     print(f"   Duration: {job_info['duration']}")
198 |     print(f"   Training Samples: {job_info['samples']:,}")
199 |     print(f"   Performance Improvement: +{job_info['performance_improvement']}%")
    |     ^^^^^ T201
200 |
201 |     print("\n4. Validation Results:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:201:5: T201 `print` found
    |
199 |     print(f"   Performance Improvement: +{job_info['performance_improvement']}%")
200 |
201 |     print("\n4. Validation Results:")
    |     ^^^^^ T201
202 |     print("   Old Model Accuracy: 0.82")
203 |     print("   New Model Accuracy: 0.86 (+4.9%)")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:202:5: T201 `print` found
    |
201 |     print("\n4. Validation Results:")
202 |     print("   Old Model Accuracy: 0.82")
    |     ^^^^^ T201
203 |     print("   New Model Accuracy: 0.86 (+4.9%)")
204 |     print("   Validation: PASSED ✓")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:203:5: T201 `print` found
    |
201 |     print("\n4. Validation Results:")
202 |     print("   Old Model Accuracy: 0.82")
203 |     print("   New Model Accuracy: 0.86 (+4.9%)")
    |     ^^^^^ T201
204 |     print("   Validation: PASSED ✓")
205 |     print("   Action: New model promoted to staging")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:204:5: T201 `print` found
    |
202 |     print("   Old Model Accuracy: 0.82")
203 |     print("   New Model Accuracy: 0.86 (+4.9%)")
204 |     print("   Validation: PASSED ✓")
    |     ^^^^^ T201
205 |     print("   Action: New model promoted to staging")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:205:5: T201 `print` found
    |
203 |     print("   New Model Accuracy: 0.86 (+4.9%)")
204 |     print("   Validation: PASSED ✓")
205 |     print("   Action: New model promoted to staging")
    |     ^^^^^ T201
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:210:5: T201 `print` found
    |
208 | def show_integrated_workflow():
209 |     """Show how all components work together."""
210 |     print("\n\n=== Integrated Intelligence Layer Workflow ===\n")
    |     ^^^^^ T201
211 |
212 |     print("1. Continuous Model Monitoring:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:212:5: T201 `print` found
    |
210 |     print("\n\n=== Integrated Intelligence Layer Workflow ===\n")
211 |
212 |     print("1. Continuous Model Monitoring:")
    |     ^^^^^ T201
213 |     print("   - Every prediction is tracked")
214 |     print("   - Performance metrics updated hourly")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:213:5: T201 `print` found
    |
212 |     print("1. Continuous Model Monitoring:")
213 |     print("   - Every prediction is tracked")
    |     ^^^^^ T201
214 |     print("   - Performance metrics updated hourly")
215 |     print("   - Drift detection runs daily")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:214:5: T201 `print` found
    |
212 |     print("1. Continuous Model Monitoring:")
213 |     print("   - Every prediction is tracked")
214 |     print("   - Performance metrics updated hourly")
    |     ^^^^^ T201
215 |     print("   - Drift detection runs daily")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:215:5: T201 `print` found
    |
213 |     print("   - Every prediction is tracked")
214 |     print("   - Performance metrics updated hourly")
215 |     print("   - Drift detection runs daily")
    |     ^^^^^ T201
216 |
217 |     print("\n2. Adaptive Model Selection:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:217:5: T201 `print` found
    |
215 |     print("   - Drift detection runs daily")
216 |
217 |     print("\n2. Adaptive Model Selection:")
    |     ^^^^^ T201
218 |     print("   - A/B tests route traffic to best performers")
219 |     print("   - Epsilon-greedy exploration of new models")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:218:5: T201 `print` found
    |
217 |     print("\n2. Adaptive Model Selection:")
218 |     print("   - A/B tests route traffic to best performers")
    |     ^^^^^ T201
219 |     print("   - Epsilon-greedy exploration of new models")
220 |     print("   - Automatic winner promotion")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:219:5: T201 `print` found
    |
217 |     print("\n2. Adaptive Model Selection:")
218 |     print("   - A/B tests route traffic to best performers")
219 |     print("   - Epsilon-greedy exploration of new models")
    |     ^^^^^ T201
220 |     print("   - Automatic winner promotion")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:220:5: T201 `print` found
    |
218 |     print("   - A/B tests route traffic to best performers")
219 |     print("   - Epsilon-greedy exploration of new models")
220 |     print("   - Automatic winner promotion")
    |     ^^^^^ T201
221 |
222 |     print("\n3. Self-Healing Pipeline:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:222:5: T201 `print` found
    |
220 |     print("   - Automatic winner promotion")
221 |
222 |     print("\n3. Self-Healing Pipeline:")
    |     ^^^^^ T201
223 |     print("   - Drift detected → Retraining triggered")
224 |     print("   - New model trained → A/B test started")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:223:5: T201 `print` found
    |
222 |     print("\n3. Self-Healing Pipeline:")
223 |     print("   - Drift detected → Retraining triggered")
    |     ^^^^^ T201
224 |     print("   - New model trained → A/B test started")
225 |     print("   - Winner identified → Production updated")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:224:5: T201 `print` found
    |
222 |     print("\n3. Self-Healing Pipeline:")
223 |     print("   - Drift detected → Retraining triggered")
224 |     print("   - New model trained → A/B test started")
    |     ^^^^^ T201
225 |     print("   - Winner identified → Production updated")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:225:5: T201 `print` found
    |
223 |     print("   - Drift detected → Retraining triggered")
224 |     print("   - New model trained → A/B test started")
225 |     print("   - Winner identified → Production updated")
    |     ^^^^^ T201
226 |
227 |     print("\n4. Complete Lifecycle Example:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:227:5: T201 `print` found
    |
225 |     print("   - Winner identified → Production updated")
226 |
227 |     print("\n4. Complete Lifecycle Example:")
    |     ^^^^^ T201
228 |
229 |     lifecycle_events = [
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:244:9: T201 `print` found
    |
242 |                 "SUCCESS": "✅", "TESTING": "🧪", "COMPLETE": "📊",
243 |                 "DEPLOYED": "🚀", "CLEANUP": "🗑️"}.get(status, "•")
244 |         print(f"   {day}: {event} {icon}")
    |         ^^^^^ T201
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:249:5: T201 `print` found
    |
247 | def main():
248 |     """Run the demonstration."""
249 |     print("=" * 70)
    |     ^^^^^ T201
250 |     print("GAL-FRIDAY SPRINT 3 DEMONSTRATION")
251 |     print("Intelligence Layer: A/B Testing & Automated Retraining")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:250:5: T201 `print` found
    |
248 |     """Run the demonstration."""
249 |     print("=" * 70)
250 |     print("GAL-FRIDAY SPRINT 3 DEMONSTRATION")
    |     ^^^^^ T201
251 |     print("Intelligence Layer: A/B Testing & Automated Retraining")
252 |     print("=" * 70)
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:251:5: T201 `print` found
    |
249 |     print("=" * 70)
250 |     print("GAL-FRIDAY SPRINT 3 DEMONSTRATION")
251 |     print("Intelligence Layer: A/B Testing & Automated Retraining")
    |     ^^^^^ T201
252 |     print("=" * 70)
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:252:5: T201 `print` found
    |
250 |     print("GAL-FRIDAY SPRINT 3 DEMONSTRATION")
251 |     print("Intelligence Layer: A/B Testing & Automated Retraining")
252 |     print("=" * 70)
    |     ^^^^^ T201
253 |
254 |     demonstrate_model_prediction_flow()
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:260:5: T201 `print` found
    |
258 |     show_integrated_workflow()
259 |
260 |     print("\n" + "=" * 70)
    |     ^^^^^ T201
261 |     print("SPRINT 3 SUMMARY")
262 |     print("=" * 70)
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:261:5: T201 `print` found
    |
260 |     print("\n" + "=" * 70)
261 |     print("SPRINT 3 SUMMARY")
    |     ^^^^^ T201
262 |     print("=" * 70)
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:262:5: T201 `print` found
    |
260 |     print("\n" + "=" * 70)
261 |     print("SPRINT 3 SUMMARY")
262 |     print("=" * 70)
    |     ^^^^^ T201
263 |
264 |     print("\nWeek 5 - A/B Testing Framework ✅")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:264:5: T201 `print` found
    |
262 |     print("=" * 70)
263 |
264 |     print("\nWeek 5 - A/B Testing Framework ✅")
    |     ^^^^^ T201
265 |     print("- Experiment configuration and management")
266 |     print("- Multiple traffic routing strategies")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:265:5: T201 `print` found
    |
264 |     print("\nWeek 5 - A/B Testing Framework ✅")
265 |     print("- Experiment configuration and management")
    |     ^^^^^ T201
266 |     print("- Multiple traffic routing strategies")
267 |     print("- Statistical significance testing")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:266:5: T201 `print` found
    |
264 |     print("\nWeek 5 - A/B Testing Framework ✅")
265 |     print("- Experiment configuration and management")
266 |     print("- Multiple traffic routing strategies")
    |     ^^^^^ T201
267 |     print("- Statistical significance testing")
268 |     print("- Automated winner selection")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:267:5: T201 `print` found
    |
265 |     print("- Experiment configuration and management")
266 |     print("- Multiple traffic routing strategies")
267 |     print("- Statistical significance testing")
    |     ^^^^^ T201
268 |     print("- Automated winner selection")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:268:5: T201 `print` found
    |
266 |     print("- Multiple traffic routing strategies")
267 |     print("- Statistical significance testing")
268 |     print("- Automated winner selection")
    |     ^^^^^ T201
269 |
270 |     print("\nWeek 6 - Automated Retraining ✅")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:270:5: T201 `print` found
    |
268 |     print("- Automated winner selection")
269 |
270 |     print("\nWeek 6 - Automated Retraining ✅")
    |     ^^^^^ T201
271 |     print("- Multi-type drift detection")
272 |     print("- Triggered retraining pipeline")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:271:5: T201 `print` found
    |
270 |     print("\nWeek 6 - Automated Retraining ✅")
271 |     print("- Multi-type drift detection")
    |     ^^^^^ T201
272 |     print("- Triggered retraining pipeline")
273 |     print("- Model validation and comparison")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:272:5: T201 `print` found
    |
270 |     print("\nWeek 6 - Automated Retraining ✅")
271 |     print("- Multi-type drift detection")
272 |     print("- Triggered retraining pipeline")
    |     ^^^^^ T201
273 |     print("- Model validation and comparison")
274 |     print("- Seamless production updates")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:273:5: T201 `print` found
    |
271 |     print("- Multi-type drift detection")
272 |     print("- Triggered retraining pipeline")
273 |     print("- Model validation and comparison")
    |     ^^^^^ T201
274 |     print("- Seamless production updates")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:274:5: T201 `print` found
    |
272 |     print("- Triggered retraining pipeline")
273 |     print("- Model validation and comparison")
274 |     print("- Seamless production updates")
    |     ^^^^^ T201
275 |
276 |     print("\nKey Achievements:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:276:5: T201 `print` found
    |
274 |     print("- Seamless production updates")
275 |
276 |     print("\nKey Achievements:")
    |     ^^^^^ T201
277 |     print("✓ Models properly integrated with trading signals")
278 |     print("✓ A/B testing enables continuous improvement")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:277:5: T201 `print` found
    |
276 |     print("\nKey Achievements:")
277 |     print("✓ Models properly integrated with trading signals")
    |     ^^^^^ T201
278 |     print("✓ A/B testing enables continuous improvement")
279 |     print("✓ Drift detection prevents performance degradation")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:278:5: T201 `print` found
    |
276 |     print("\nKey Achievements:")
277 |     print("✓ Models properly integrated with trading signals")
278 |     print("✓ A/B testing enables continuous improvement")
    |     ^^^^^ T201
279 |     print("✓ Drift detection prevents performance degradation")
280 |     print("✓ Automated retraining ensures model freshness")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:279:5: T201 `print` found
    |
277 |     print("✓ Models properly integrated with trading signals")
278 |     print("✓ A/B testing enables continuous improvement")
279 |     print("✓ Drift detection prevents performance degradation")
    |     ^^^^^ T201
280 |     print("✓ Automated retraining ensures model freshness")
281 |     print("✓ Self-healing ML pipeline implemented")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:280:5: T201 `print` found
    |
278 |     print("✓ A/B testing enables continuous improvement")
279 |     print("✓ Drift detection prevents performance degradation")
280 |     print("✓ Automated retraining ensures model freshness")
    |     ^^^^^ T201
281 |     print("✓ Self-healing ML pipeline implemented")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:281:5: T201 `print` found
    |
279 |     print("✓ Drift detection prevents performance degradation")
280 |     print("✓ Automated retraining ensures model freshness")
281 |     print("✓ Self-healing ML pipeline implemented")
    |     ^^^^^ T201
282 |
283 |     print("\nProduction Benefits:")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:283:5: T201 `print` found
    |
281 |     print("✓ Self-healing ML pipeline implemented")
282 |
283 |     print("\nProduction Benefits:")
    |     ^^^^^ T201
284 |     print("- 25% reduction in model degradation incidents")
285 |     print("- 40% faster model improvement cycle")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:284:5: T201 `print` found
    |
283 |     print("\nProduction Benefits:")
284 |     print("- 25% reduction in model degradation incidents")
    |     ^^^^^ T201
285 |     print("- 40% faster model improvement cycle")
286 |     print("- 99.9% model availability with auto-recovery")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:285:5: T201 `print` found
    |
283 |     print("\nProduction Benefits:")
284 |     print("- 25% reduction in model degradation incidents")
285 |     print("- 40% faster model improvement cycle")
    |     ^^^^^ T201
286 |     print("- 99.9% model availability with auto-recovery")
287 |     print("- Zero-downtime model updates")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:286:5: T201 `print` found
    |
284 |     print("- 25% reduction in model degradation incidents")
285 |     print("- 40% faster model improvement cycle")
286 |     print("- 99.9% model availability with auto-recovery")
    |     ^^^^^ T201
287 |     print("- Zero-downtime model updates")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:287:5: T201 `print` found
    |
285 |     print("- 40% faster model improvement cycle")
286 |     print("- 99.9% model availability with auto-recovery")
287 |     print("- Zero-downtime model updates")
    |     ^^^^^ T201
288 |
289 |     print("\nNext Steps (Sprint 4):")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:289:5: T201 `print` found
    |
287 |     print("- Zero-downtime model updates")
288 |
289 |     print("\nNext Steps (Sprint 4):")
    |     ^^^^^ T201
290 |     print("- Production deployment preparation")
291 |     print("- Performance optimization")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:290:5: T201 `print` found
    |
289 |     print("\nNext Steps (Sprint 4):")
290 |     print("- Production deployment preparation")
    |     ^^^^^ T201
291 |     print("- Performance optimization")
292 |     print("- Integration testing")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:291:5: T201 `print` found
    |
289 |     print("\nNext Steps (Sprint 4):")
290 |     print("- Production deployment preparation")
291 |     print("- Performance optimization")
    |     ^^^^^ T201
292 |     print("- Integration testing")
293 |     print("- Documentation and training")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:292:5: T201 `print` found
    |
290 |     print("- Production deployment preparation")
291 |     print("- Performance optimization")
292 |     print("- Integration testing")
    |     ^^^^^ T201
293 |     print("- Documentation and training")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:293:5: T201 `print` found
    |
291 |     print("- Performance optimization")
292 |     print("- Integration testing")
293 |     print("- Documentation and training")
    |     ^^^^^ T201
294 |
295 |     print("\n✅ Sprint 3 Complete - Intelligence Layer Operational!")
    |
    = help: Remove `print`

tests/test_intelligence_layer_demo.py:295:5: T201 `print` found
    |
293 |     print("- Documentation and training")
294 |
295 |     print("\n✅ Sprint 3 Complete - Intelligence Layer Operational!")
    |     ^^^^^ T201
    |
    = help: Remove `print`

tests/test_model_registry.py:22:9: D107 Missing docstring in `__init__`
   |
20 | class MockConfig:
21 |     """Mock configuration for testing."""
22 |     def __init__(self):
   |         ^^^^^^^^ D107
23 |         self.config = {
24 |             "model_registry.storage_path": "./test_models",
   |

tests/test_model_registry.py:28:9: D102 Missing docstring in public method
   |
26 |         }
27 |
28 |     def get(self, key, default=None):
   |         ^^^ D102
29 |         return self.config.get(key, default)
   |

tests/test_model_registry.py:31:9: D102 Missing docstring in public method
   |
29 |         return self.config.get(key, default)
30 |
31 |     def get_bool(self, key, default=False):
   |         ^^^^^^^^ D102
32 |         return bool(self.config.get(key, default))
   |

tests/test_model_registry.py:37:9: D102 Missing docstring in public method
   |
35 | class MockLogger:
36 |     """Mock logger for testing."""
37 |     def info(self, msg, **kwargs):
   |         ^^^^ D102
38 |         print(f"INFO: {msg}")
   |

tests/test_model_registry.py:38:9: T201 `print` found
   |
36 |     """Mock logger for testing."""
37 |     def info(self, msg, **kwargs):
38 |         print(f"INFO: {msg}")
   |         ^^^^^ T201
39 |
40 |     def warning(self, msg, **kwargs):
   |
   = help: Remove `print`

tests/test_model_registry.py:40:9: D102 Missing docstring in public method
   |
38 |         print(f"INFO: {msg}")
39 |
40 |     def warning(self, msg, **kwargs):
   |         ^^^^^^^ D102
41 |         print(f"WARNING: {msg}")
   |

tests/test_model_registry.py:41:9: T201 `print` found
   |
40 |     def warning(self, msg, **kwargs):
41 |         print(f"WARNING: {msg}")
   |         ^^^^^ T201
42 |
43 |     def error(self, msg, **kwargs):
   |
   = help: Remove `print`

tests/test_model_registry.py:43:9: D102 Missing docstring in public method
   |
41 |         print(f"WARNING: {msg}")
42 |
43 |     def error(self, msg, **kwargs):
   |         ^^^^^ D102
44 |         print(f"ERROR: {msg}")
   |

tests/test_model_registry.py:44:9: T201 `print` found
   |
43 |     def error(self, msg, **kwargs):
44 |         print(f"ERROR: {msg}")
   |         ^^^^^ T201
45 |
46 |     def exception(self, msg, **kwargs):
   |
   = help: Remove `print`

tests/test_model_registry.py:46:9: D102 Missing docstring in public method
   |
44 |         print(f"ERROR: {msg}")
45 |
46 |     def exception(self, msg, **kwargs):
   |         ^^^^^^^^^ D102
47 |         print(f"EXCEPTION: {msg}")
   |

tests/test_model_registry.py:47:9: T201 `print` found
   |
46 |     def exception(self, msg, **kwargs):
47 |         print(f"EXCEPTION: {msg}")
   |         ^^^^^ T201
   |
   = help: Remove `print`

tests/test_model_registry.py:52:9: D107 Missing docstring in `__init__`
   |
50 | class MockModelRepo:
51 |     """Mock model repository for testing."""
52 |     def __init__(self):
   |         ^^^^^^^^ D107
53 |         self.models = {}
   |

tests/test_model_registry.py:55:15: D102 Missing docstring in public method
   |
53 |         self.models = {}
54 |
55 |     async def save_model(self, metadata):
   |               ^^^^^^^^^^ D102
56 |         self.models[metadata.model_id] = metadata
57 |         return metadata.model_id
   |

tests/test_model_registry.py:59:15: D102 Missing docstring in public method
   |
57 |         return metadata.model_id
58 |
59 |     async def get_model_by_id(self, model_id):
   |               ^^^^^^^^^^^^^^^ D102
60 |         return self.models.get(model_id)
   |

tests/test_model_registry.py:62:15: D102 Missing docstring in public method
   |
60 |         return self.models.get(model_id)
61 |
62 |     async def get_model_by_version(self, model_name, version):
   |               ^^^^^^^^^^^^^^^^^^^^ D102
63 |         for model in self.models.values():
64 |             if model.model_name == model_name and model.version == version:
   |

tests/test_model_registry.py:68:15: D102 Missing docstring in public method
   |
66 |         return None
67 |
68 |     async def get_model_by_stage(self, model_name, stage):
   |               ^^^^^^^^^^^^^^^^^^ D102
69 |         for model in self.models.values():
70 |             if model.model_name == model_name and model.stage == stage:
   |

tests/test_model_registry.py:74:15: D102 Missing docstring in public method
   |
72 |         return None
73 |
74 |     async def get_latest_model(self, model_name):
   |               ^^^^^^^^^^^^^^^^ D102
75 |         models = [m for m in self.models.values() if m.model_name == model_name]
76 |         if models:
   |

tests/test_model_registry.py:80:15: D102 Missing docstring in public method
   |
78 |         return None
79 |
80 |     async def list_models(self, model_name=None, stage=None):
   |               ^^^^^^^^^^^ D102
81 |         results = []
82 |         for model in self.models.values():
   |

tests/test_model_registry.py:90:15: D102 Missing docstring in public method
   |
88 |         return results
89 |
90 |     async def update_model_stage(self, model_id, new_stage, updated_by):
   |               ^^^^^^^^^^^^^^^^^^ D102
91 |         if model_id in self.models:
92 |             self.models[model_id].stage = new_stage
   |

tests/test_model_registry.py:119:5: N806 Variable `X_train` in function should be lowercase
    |
118 |     # Create a simple XGBoost model
119 |     X_train = np.random.rand(100, 5)
    |     ^^^^^^^ N806
120 |     y_train = np.random.rand(100)
    |

tests/test_model_registry.py:119:15: NPY002 Replace legacy `np.random.rand` call with `np.random.Generator`
    |
118 |     # Create a simple XGBoost model
119 |     X_train = np.random.rand(100, 5)
    |               ^^^^^^^^^^^^^^ NPY002
120 |     y_train = np.random.rand(100)
    |

tests/test_model_registry.py:120:15: NPY002 Replace legacy `np.random.rand` call with `np.random.Generator`
    |
118 |     # Create a simple XGBoost model
119 |     X_train = np.random.rand(100, 5)
120 |     y_train = np.random.rand(100)
    |               ^^^^^^^^^^^^^^ NPY002
121 |
122 |     model = xgb.XGBRegressor(n_estimators=10, max_depth=3)
    |

tests/test_model_registry.py:144:5: T201 `print` found
    |
143 |     # Test 1: Register model
144 |     print("Test 1: Registering model...")
    |     ^^^^^ T201
145 |     model_id = await registry.register_model(artifact, "price_predictor")
146 |     assert model_id is not None
    |
    = help: Remove `print`

tests/test_model_registry.py:147:5: T201 `print` found
    |
145 |     model_id = await registry.register_model(artifact, "price_predictor")
146 |     assert model_id is not None
147 |     print(f"✓ Model registered with ID: {model_id}")
    |     ^^^^^ T201
148 |
149 |     # Test 2: Get model by name
    |
    = help: Remove `print`

tests/test_model_registry.py:150:5: T201 `print` found
    |
149 |     # Test 2: Get model by name
150 |     print("\nTest 2: Retrieving model...")
    |     ^^^^^ T201
151 |     retrieved = await registry.get_model("price_predictor")
152 |     assert retrieved is not None
    |
    = help: Remove `print`

tests/test_model_registry.py:155:5: T201 `print` found
    |
153 |     assert retrieved.metadata.model_name == "price_predictor"
154 |     assert retrieved.metadata.version == "1.0.0"
155 |     print(f"✓ Model retrieved: {retrieved.metadata.model_name} v{retrieved.metadata.version}")
    |     ^^^^^ T201
156 |
157 |     # Test 3: Register another version
    |
    = help: Remove `print`

tests/test_model_registry.py:158:5: T201 `print` found
    |
157 |     # Test 3: Register another version
158 |     print("\nTest 3: Registering new version...")
    |     ^^^^^ T201
159 |     artifact2 = ModelArtifact(
160 |         model=model,
    |
    = help: Remove `print`

tests/test_model_registry.py:169:5: T201 `print` found
    |
167 |     retrieved2 = await registry.get_model("price_predictor")
168 |     assert retrieved2.metadata.version == "1.0.1"
169 |     print(f"✓ New version registered: v{retrieved2.metadata.version}")
    |     ^^^^^ T201
170 |
171 |     # Test 4: List models
    |
    = help: Remove `print`

tests/test_model_registry.py:172:5: T201 `print` found
    |
171 |     # Test 4: List models
172 |     print("\nTest 4: Listing models...")
    |     ^^^^^ T201
173 |     models = await registry.list_models("price_predictor")
174 |     assert len(models) == 2
    |
    = help: Remove `print`

tests/test_model_registry.py:174:27: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
172 |     print("\nTest 4: Listing models...")
173 |     models = await registry.list_models("price_predictor")
174 |     assert len(models) == 2
    |                           ^ PLR2004
175 |     print(f"✓ Found {len(models)} models")
    |

tests/test_model_registry.py:175:5: T201 `print` found
    |
173 |     models = await registry.list_models("price_predictor")
174 |     assert len(models) == 2
175 |     print(f"✓ Found {len(models)} models")
    |     ^^^^^ T201
176 |
177 |     # Test 5: Promote model
    |
    = help: Remove `print`

tests/test_model_registry.py:178:5: T201 `print` found
    |
177 |     # Test 5: Promote model
178 |     print("\nTest 5: Promoting model to production...")
    |     ^^^^^ T201
179 |     success = await registry.promote_model(model_id2, ModelStage.PRODUCTION)
180 |     assert success
    |
    = help: Remove `print`

tests/test_model_registry.py:185:5: T201 `print` found
    |
183 |     assert prod_model is not None
184 |     assert prod_model.metadata.stage == ModelStage.PRODUCTION
185 |     print(f"✓ Model promoted to {prod_model.metadata.stage.value}")
    |     ^^^^^ T201
186 |
187 |     # Clean up
    |
    = help: Remove `print`

tests/test_model_registry.py:189:5: T201 `print` found
    |
187 |     # Clean up
188 |     shutil.rmtree(test_path)
189 |     print("\n✅ All tests passed!")
    |     ^^^^^ T201
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:12:7: D101 Missing docstring in public class
   |
11 | # Simplified versions of the classes for demonstration
12 | class ModelStage:
   |       ^^^^^^^^^^ D101
13 |     DEVELOPMENT = "development"
14 |     STAGING = "staging"
   |

tests/test_model_registry_simple.py:18:7: D101 Missing docstring in public class
   |
16 |     ARCHIVED = "archived"
17 |
18 | class ModelStatus:
   |       ^^^^^^^^^^^ D101
19 |     TRAINING = "training"
20 |     READY = "ready"
   |

tests/test_model_registry_simple.py:23:7: D101 Missing docstring in public class
   |
21 |     DEPLOYED = "deployed"
22 |
23 | class ModelMetadata:
   |       ^^^^^^^^^^^^^ D101
24 |     def __init__(self):
25 |         self.model_id = str(uuid.uuid4())
   |

tests/test_model_registry_simple.py:24:9: D107 Missing docstring in `__init__`
   |
23 | class ModelMetadata:
24 |     def __init__(self):
   |         ^^^^^^^^ D107
25 |         self.model_id = str(uuid.uuid4())
26 |         self.model_name = ""
   |

tests/test_model_registry_simple.py:38:9: D102 Missing docstring in public method
   |
36 |         self.features = []
37 |
38 |     def to_dict(self):
   |         ^^^^^^^ D102
39 |         return {
40 |             "model_id": self.model_id,
   |

tests/test_model_registry_simple.py:56:9: D107 Missing docstring in `__init__`
   |
54 | class SimpleModel:
55 |     """A simple mock model for testing."""
56 |     def __init__(self, name):
   |         ^^^^^^^^ D107
57 |         self.name = name
58 |         self.params = {"learning_rate": 0.1, "n_estimators": 100}
   |

tests/test_model_registry_simple.py:60:9: D102 Missing docstring in public method
   |
58 |         self.params = {"learning_rate": 0.1, "n_estimators": 100}
59 |
60 |     def predict(self, X):
   |         ^^^^^^^ D102
61 |         return [0.5] * len(X)
   |

tests/test_model_registry_simple.py:60:23: N803 Argument name `X` should be lowercase
   |
58 |         self.params = {"learning_rate": 0.1, "n_estimators": 100}
59 |
60 |     def predict(self, X):
   |                       ^ N803
61 |         return [0.5] * len(X)
   |

tests/test_model_registry_simple.py:63:5: PLR0915 Too many statements (64 > 50)
   |
61 |         return [0.5] * len(X)
62 |
63 | def demonstrate_model_registry():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0915
64 |     """Demonstrate the Model Registry structure and workflow."""
65 |     print("=== Gal-Friday Model Registry Demonstration ===\n")
   |

tests/test_model_registry_simple.py:65:5: T201 `print` found
   |
63 | def demonstrate_model_registry():
64 |     """Demonstrate the Model Registry structure and workflow."""
65 |     print("=== Gal-Friday Model Registry Demonstration ===\n")
   |     ^^^^^ T201
66 |
67 |     # 1. Create storage directory
   |
   = help: Remove `print`

tests/test_model_registry_simple.py:98:10: PTH123 `open()` should be replaced by `Path.open()`
   |
97 |     # Save model
98 |     with open(artifact_path / "model.pkl", "wb") as f:
   |          ^^^^ PTH123
99 |         pickle.dump(model, f)
   |

tests/test_model_registry_simple.py:102:10: PTH123 `open()` should be replaced by `Path.open()`
    |
101 |     # Save metadata
102 |     with open(artifact_path / "metadata.json", "w") as f:
    |          ^^^^ PTH123
103 |         json.dump(metadata.to_dict(), f, indent=2)
    |

tests/test_model_registry_simple.py:106:10: PTH123 `open()` should be replaced by `Path.open()`
    |
105 |     # Save features
106 |     with open(artifact_path / "features.json", "w") as f:
    |          ^^^^ PTH123
107 |         json.dump(metadata.features, f)
    |

tests/test_model_registry_simple.py:111:5: T201 `print` found
    |
109 |     metadata.artifact_path = str(artifact_path)
110 |
111 |     print("✓ Model artifact saved to:", artifact_path)
    |     ^^^^^ T201
112 |     print(f"  - Model: {metadata.model_name} v{metadata.version}")
113 |     print(f"  - Type: {metadata.model_type}")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:112:5: T201 `print` found
    |
111 |     print("✓ Model artifact saved to:", artifact_path)
112 |     print(f"  - Model: {metadata.model_name} v{metadata.version}")
    |     ^^^^^ T201
113 |     print(f"  - Type: {metadata.model_type}")
114 |     print(f"  - Features: {len(metadata.features)}")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:113:5: T201 `print` found
    |
111 |     print("✓ Model artifact saved to:", artifact_path)
112 |     print(f"  - Model: {metadata.model_name} v{metadata.version}")
113 |     print(f"  - Type: {metadata.model_type}")
    |     ^^^^^ T201
114 |     print(f"  - Features: {len(metadata.features)}")
115 |     print(f"  - Metrics: {metadata.metrics}")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:114:5: T201 `print` found
    |
112 |     print(f"  - Model: {metadata.model_name} v{metadata.version}")
113 |     print(f"  - Type: {metadata.model_type}")
114 |     print(f"  - Features: {len(metadata.features)}")
    |     ^^^^^ T201
115 |     print(f"  - Metrics: {metadata.metrics}")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:115:5: T201 `print` found
    |
113 |     print(f"  - Type: {metadata.model_type}")
114 |     print(f"  - Features: {len(metadata.features)}")
115 |     print(f"  - Metrics: {metadata.metrics}")
    |     ^^^^^ T201
116 |
117 |     # 4. Demonstrate model promotion workflow
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:118:5: T201 `print` found
    |
117 |     # 4. Demonstrate model promotion workflow
118 |     print("\n=== Model Lifecycle Stages ===")
    |     ^^^^^ T201
119 |     print("1. Development: Model is being trained and evaluated")
120 |     print("2. Staging: Model passed tests and ready for A/B testing")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:119:5: T201 `print` found
    |
117 |     # 4. Demonstrate model promotion workflow
118 |     print("\n=== Model Lifecycle Stages ===")
119 |     print("1. Development: Model is being trained and evaluated")
    |     ^^^^^ T201
120 |     print("2. Staging: Model passed tests and ready for A/B testing")
121 |     print("3. Production: Model is serving live predictions")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:120:5: T201 `print` found
    |
118 |     print("\n=== Model Lifecycle Stages ===")
119 |     print("1. Development: Model is being trained and evaluated")
120 |     print("2. Staging: Model passed tests and ready for A/B testing")
    |     ^^^^^ T201
121 |     print("3. Production: Model is serving live predictions")
122 |     print("4. Archived: Model is retired but kept for reference")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:121:5: T201 `print` found
    |
119 |     print("1. Development: Model is being trained and evaluated")
120 |     print("2. Staging: Model passed tests and ready for A/B testing")
121 |     print("3. Production: Model is serving live predictions")
    |     ^^^^^ T201
122 |     print("4. Archived: Model is retired but kept for reference")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:122:5: T201 `print` found
    |
120 |     print("2. Staging: Model passed tests and ready for A/B testing")
121 |     print("3. Production: Model is serving live predictions")
122 |     print("4. Archived: Model is retired but kept for reference")
    |     ^^^^^ T201
123 |
124 |     print(f"\nCurrent stage: {metadata.stage}")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:124:5: T201 `print` found
    |
122 |     print("4. Archived: Model is retired but kept for reference")
123 |
124 |     print(f"\nCurrent stage: {metadata.stage}")
    |     ^^^^^ T201
125 |
126 |     # Simulate promotion
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:127:5: T201 `print` found
    |
126 |     # Simulate promotion
127 |     print("\n✓ Promoting model to STAGING...")
    |     ^^^^^ T201
128 |     metadata.stage = ModelStage.STAGING
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:130:5: T201 `print` found
    |
128 |     metadata.stage = ModelStage.STAGING
129 |
130 |     print("✓ Running A/B tests...")
    |     ^^^^^ T201
131 |     print("  - Control: price_predictor v0.9.0")
132 |     print("  - Treatment: price_predictor v1.0.0")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:131:5: T201 `print` found
    |
130 |     print("✓ Running A/B tests...")
131 |     print("  - Control: price_predictor v0.9.0")
    |     ^^^^^ T201
132 |     print("  - Treatment: price_predictor v1.0.0")
133 |     print("  - Result: +5% improvement in accuracy")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:132:5: T201 `print` found
    |
130 |     print("✓ Running A/B tests...")
131 |     print("  - Control: price_predictor v0.9.0")
132 |     print("  - Treatment: price_predictor v1.0.0")
    |     ^^^^^ T201
133 |     print("  - Result: +5% improvement in accuracy")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:133:5: T201 `print` found
    |
131 |     print("  - Control: price_predictor v0.9.0")
132 |     print("  - Treatment: price_predictor v1.0.0")
133 |     print("  - Result: +5% improvement in accuracy")
    |     ^^^^^ T201
134 |
135 |     print("\n✓ Promoting model to PRODUCTION...")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:135:5: T201 `print` found
    |
133 |     print("  - Result: +5% improvement in accuracy")
134 |
135 |     print("\n✓ Promoting model to PRODUCTION...")
    |     ^^^^^ T201
136 |     metadata.stage = ModelStage.PRODUCTION
137 |     metadata.status = ModelStatus.DEPLOYED
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:140:5: T201 `print` found
    |
139 |     # 5. Load model back
140 |     print("\n=== Loading Model from Registry ===")
    |     ^^^^^ T201
141 |
142 |     # Load model
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:143:10: PTH123 `open()` should be replaced by `Path.open()`
    |
142 |     # Load model
143 |     with open(artifact_path / "model.pkl", "rb") as f:
    |          ^^^^ PTH123
144 |         loaded_model = pickle.load(f)
    |

tests/test_model_registry_simple.py:144:24: S301 `pickle` and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue
    |
142 |     # Load model
143 |     with open(artifact_path / "model.pkl", "rb") as f:
144 |         loaded_model = pickle.load(f)
    |                        ^^^^^^^^^^^^^^ S301
145 |
146 |     # Load metadata
    |

tests/test_model_registry_simple.py:147:10: PTH123 `open()` should be replaced by `Path.open()`
    |
146 |     # Load metadata
147 |     with open(artifact_path / "metadata.json") as f:
    |          ^^^^ PTH123
148 |         loaded_metadata = json.load(f)
    |

tests/test_model_registry_simple.py:150:5: T201 `print` found
    |
148 |         loaded_metadata = json.load(f)
149 |
150 |     print(f"✓ Loaded model: {loaded_metadata['model_name']} v{loaded_metadata['version']}")
    |     ^^^^^ T201
151 |     print(f"  - Stage: {loaded_metadata['stage']}")
152 |     print(f"  - Status: {loaded_metadata['status']}")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:151:5: T201 `print` found
    |
150 |     print(f"✓ Loaded model: {loaded_metadata['model_name']} v{loaded_metadata['version']}")
151 |     print(f"  - Stage: {loaded_metadata['stage']}")
    |     ^^^^^ T201
152 |     print(f"  - Status: {loaded_metadata['status']}")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:152:5: T201 `print` found
    |
150 |     print(f"✓ Loaded model: {loaded_metadata['model_name']} v{loaded_metadata['version']}")
151 |     print(f"  - Stage: {loaded_metadata['stage']}")
152 |     print(f"  - Status: {loaded_metadata['status']}")
    |     ^^^^^ T201
153 |
154 |     # 6. Make prediction
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:155:5: T201 `print` found
    |
154 |     # 6. Make prediction
155 |     print("\n=== Making Predictions ===")
    |     ^^^^^ T201
156 |     test_data = [[0.5, 0.6, 1000, 45, 0.02]]  # Mock feature values
157 |     prediction = loaded_model.predict(test_data)
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:158:5: T201 `print` found
    |
156 |     test_data = [[0.5, 0.6, 1000, 45, 0.02]]  # Mock feature values
157 |     prediction = loaded_model.predict(test_data)
158 |     print(f"✓ Prediction for test data: {prediction[0]}")
    |     ^^^^^ T201
159 |
160 |     # Clean up
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:163:5: T201 `print` found
    |
161 |     shutil.rmtree(storage_path)
162 |
163 |     print("\n✅ Model Registry demonstration complete!")
    |     ^^^^^ T201
164 |
165 |     # Show benefits
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:166:5: T201 `print` found
    |
165 |     # Show benefits
166 |     print("\n=== Benefits of Model Registry ===")
    |     ^^^^^ T201
167 |     print("1. Version Control: Track all model versions with full history")
168 |     print("2. Metadata Tracking: Store metrics, parameters, and features")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:167:5: T201 `print` found
    |
165 |     # Show benefits
166 |     print("\n=== Benefits of Model Registry ===")
167 |     print("1. Version Control: Track all model versions with full history")
    |     ^^^^^ T201
168 |     print("2. Metadata Tracking: Store metrics, parameters, and features")
169 |     print("3. Lifecycle Management: Promote models through stages safely")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:168:5: T201 `print` found
    |
166 |     print("\n=== Benefits of Model Registry ===")
167 |     print("1. Version Control: Track all model versions with full history")
168 |     print("2. Metadata Tracking: Store metrics, parameters, and features")
    |     ^^^^^ T201
169 |     print("3. Lifecycle Management: Promote models through stages safely")
170 |     print("4. A/B Testing: Compare models before production deployment")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:169:5: T201 `print` found
    |
167 |     print("1. Version Control: Track all model versions with full history")
168 |     print("2. Metadata Tracking: Store metrics, parameters, and features")
169 |     print("3. Lifecycle Management: Promote models through stages safely")
    |     ^^^^^ T201
170 |     print("4. A/B Testing: Compare models before production deployment")
171 |     print("5. Rollback Capability: Quickly revert to previous versions")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:170:5: T201 `print` found
    |
168 |     print("2. Metadata Tracking: Store metrics, parameters, and features")
169 |     print("3. Lifecycle Management: Promote models through stages safely")
170 |     print("4. A/B Testing: Compare models before production deployment")
    |     ^^^^^ T201
171 |     print("5. Rollback Capability: Quickly revert to previous versions")
172 |     print("6. Audit Trail: Complete history of all model changes")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:171:5: T201 `print` found
    |
169 |     print("3. Lifecycle Management: Promote models through stages safely")
170 |     print("4. A/B Testing: Compare models before production deployment")
171 |     print("5. Rollback Capability: Quickly revert to previous versions")
    |     ^^^^^ T201
172 |     print("6. Audit Trail: Complete history of all model changes")
    |
    = help: Remove `print`

tests/test_model_registry_simple.py:172:5: T201 `print` found
    |
170 |     print("4. A/B Testing: Compare models before production deployment")
171 |     print("5. Rollback Capability: Quickly revert to previous versions")
172 |     print("6. Audit Trail: Complete history of all model changes")
    |     ^^^^^ T201
    |
    = help: Remove `print`

tests/test_performance.py:26:9: D107 Missing docstring in `__init__`
   |
24 |     """Run performance benchmarks on Gal-Friday components."""
25 |
26 |     def __init__(self):
   |         ^^^^^^^^ D107
27 |         self.results = {}
28 |         self.pubsub = PubSubManager()
   |

tests/test_performance.py:32:9: T201 `print` found
   |
30 |     async def test_event_throughput(self, duration_seconds: int = 10):
31 |         """Test event publishing throughput."""
32 |         print(f"\n=== Testing Event Throughput (duration: {duration_seconds}s) ===")
   |         ^^^^^ T201
33 |
34 |         events_published = 0
   |
   = help: Remove `print`

tests/test_performance.py:42:35: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   |
40 |                 timestamp=datetime.now(UTC),
41 |                 trading_pair="XRP/USD",
42 |                 price=Decimal(str(random.uniform(0.4, 0.6))),
   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ S311
43 |                 volume=Decimal(str(random.uniform(100000, 1000000))),
44 |             )
   |

tests/test_performance.py:43:36: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   |
41 |                 trading_pair="XRP/USD",
42 |                 price=Decimal(str(random.uniform(0.4, 0.6))),
43 |                 volume=Decimal(str(random.uniform(100000, 1000000))),
   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
44 |             )
   |

tests/test_performance.py:58:9: T201 `print` found
   |
56 |         }
57 |
58 |         print(f"Published {events_published:,} events in {elapsed:.2f}s")
   |         ^^^^^ T201
59 |         print(f"Throughput: {throughput:,.0f} events/second")
   |
   = help: Remove `print`

tests/test_performance.py:59:9: T201 `print` found
   |
58 |         print(f"Published {events_published:,} events in {elapsed:.2f}s")
59 |         print(f"Throughput: {throughput:,.0f} events/second")
   |         ^^^^^ T201
60 |
61 |     async def test_prediction_latency(self, num_predictions: int = 1000):
   |
   = help: Remove `print`

tests/test_performance.py:63:9: T201 `print` found
   |
61 |     async def test_prediction_latency(self, num_predictions: int = 1000):
62 |         """Test prediction generation latency."""
63 |         print(f"\n=== Testing Prediction Latency (n={num_predictions}) ===")
   |         ^^^^^ T201
64 |
65 |         latencies = []
   |
   = help: Remove `print`

tests/test_performance.py:69:33: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   |
67 |         for _ in range(num_predictions):
68 |             features = {
69 |                 f"feature_{i}": random.random()
   |                                 ^^^^^^^^^^^^^^^ S311
70 |                 for i in range(50)  # 50 features
71 |             }
   |

tests/test_performance.py:85:28: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   |
83 |                 trading_pair="XRP/USD",
84 |                 prediction_value=prediction_value,
85 |                 confidence=random.uniform(0.7, 0.95),
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^ S311
86 |                 associated_features=features,
87 |             )
   |

tests/test_performance.py:104:9: T201 `print` found
    |
102 |         }
103 |
104 |         print(f"Latency - Mean: {self.results['prediction_latency']['mean_ms']:.2f}ms")
    |         ^^^^^ T201
105 |         print(f"Latency - P95: {self.results['prediction_latency']['p95_ms']:.2f}ms")
106 |         print(f"Latency - P99: {self.results['prediction_latency']['p99_ms']:.2f}ms")
    |
    = help: Remove `print`

tests/test_performance.py:105:9: T201 `print` found
    |
104 |         print(f"Latency - Mean: {self.results['prediction_latency']['mean_ms']:.2f}ms")
105 |         print(f"Latency - P95: {self.results['prediction_latency']['p95_ms']:.2f}ms")
    |         ^^^^^ T201
106 |         print(f"Latency - P99: {self.results['prediction_latency']['p99_ms']:.2f}ms")
    |
    = help: Remove `print`

tests/test_performance.py:106:9: T201 `print` found
    |
104 |         print(f"Latency - Mean: {self.results['prediction_latency']['mean_ms']:.2f}ms")
105 |         print(f"Latency - P95: {self.results['prediction_latency']['p95_ms']:.2f}ms")
106 |         print(f"Latency - P99: {self.results['prediction_latency']['p99_ms']:.2f}ms")
    |         ^^^^^ T201
107 |
108 |     async def test_concurrent_load(self, num_workers: int = 10, duration_seconds: int = 30):
    |
    = help: Remove `print`

tests/test_performance.py:110:9: T201 `print` found
    |
108 |     async def test_concurrent_load(self, num_workers: int = 10, duration_seconds: int = 30):
109 |         """Test system under concurrent load."""
110 |         print(f"\n=== Testing Concurrent Load (workers={num_workers}, duration={duration_seconds}s) ===")
    |         ^^^^^ T201
111 |
112 |         async def worker(worker_id: int):
    |
    = help: Remove `print`

tests/test_performance.py:110:100: E501 Line too long (105 > 99)
    |
108 |     async def test_concurrent_load(self, num_workers: int = 10, duration_seconds: int = 30):
109 |         """Test system under concurrent load."""
110 |         print(f"\n=== Testing Concurrent Load (workers={num_workers}, duration={duration_seconds}s) ===")
    |                                                                                                    ^^^^^^ E501
111 |
112 |         async def worker(worker_id: int):
    |

tests/test_performance.py:120:33: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
118 |                 try:
119 |                     # Simulate various operations
120 |                     operation = random.choice(["market_data", "prediction", "signal"])
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
121 |
122 |                     if operation == "market_data":
    |

tests/test_performance.py:126:42: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
124 | …                     event_type=EventType.PRICE_UPDATE,
125 | …                     timestamp=datetime.now(UTC),
126 | …                     trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
127 | …                     price=Decimal(str(random.uniform(0.1, 1.0))),
128 | …                     volume=Decimal(str(random.uniform(10000, 100000))),
    |

tests/test_performance.py:127:47: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
125 |                             timestamp=datetime.now(UTC),
126 |                             trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
127 |                             price=Decimal(str(random.uniform(0.1, 1.0))),
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^ S311
128 |                             volume=Decimal(str(random.uniform(10000, 100000))),
129 |                         )
    |

tests/test_performance.py:128:48: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
126 |                             trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
127 |                             price=Decimal(str(random.uniform(0.1, 1.0))),
128 |                             volume=Decimal(str(random.uniform(10000, 100000))),
    |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
129 |                         )
130 |                         await self.pubsub.publish(EventType.PRICE_UPDATE, event)
    |

tests/test_performance.py:137:42: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
135 | …                     timestamp=datetime.now(UTC),
136 | …                     model_id=f"model_{worker_id}",
137 | …                     trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
138 | …                     prediction_value=random.random(),
139 | …                     confidence=random.uniform(0.5, 1.0),
    |

tests/test_performance.py:138:46: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
136 |                             model_id=f"model_{worker_id}",
137 |                             trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
138 |                             prediction_value=random.random(),
    |                                              ^^^^^^^^^^^^^^^ S311
139 |                             confidence=random.uniform(0.5, 1.0),
140 |                         )
    |

tests/test_performance.py:139:40: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
137 |                             trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
138 |                             prediction_value=random.random(),
139 |                             confidence=random.uniform(0.5, 1.0),
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^ S311
140 |                         )
141 |                         await self.pubsub.publish(EventType.PREDICTION_GENERATED, event)
    |

tests/test_performance.py:148:42: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
146 | …                     timestamp=datetime.now(UTC),
147 | …                     signal_id=f"signal_{worker_id}_{events_processed}",
148 | …                     trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
149 | …                     signal=random.choice(["BUY", "SELL", "HOLD"]),
150 | …                     entry_price=Decimal(str(random.uniform(0.1, 1.0))),
    |

tests/test_performance.py:149:36: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
147 | …                     signal_id=f"signal_{worker_id}_{events_processed}",
148 | …                     trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
149 | …                     signal=random.choice(["BUY", "SELL", "HOLD"]),
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
150 | …                     entry_price=Decimal(str(random.uniform(0.1, 1.0))),
151 | …                     quantity=Decimal(str(random.uniform(100, 1000))),
    |

tests/test_performance.py:150:53: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
148 |                             trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
149 |                             signal=random.choice(["BUY", "SELL", "HOLD"]),
150 |                             entry_price=Decimal(str(random.uniform(0.1, 1.0))),
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^ S311
151 |                             quantity=Decimal(str(random.uniform(100, 1000))),
152 |                         )
    |

tests/test_performance.py:151:50: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
149 |                             signal=random.choice(["BUY", "SELL", "HOLD"]),
150 |                             entry_price=Decimal(str(random.uniform(0.1, 1.0))),
151 |                             quantity=Decimal(str(random.uniform(100, 1000))),
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^ S311
152 |                         )
153 |                         await self.pubsub.publish(EventType.TRADE_SIGNAL_PROPOSED, event)
    |

tests/test_performance.py:183:9: T201 `print` found
    |
181 |         }
182 |
183 |         print(f"Processed {total_events:,} events with {num_workers} workers")
    |         ^^^^^ T201
184 |         print(f"Throughput: {total_events / elapsed:,.0f} events/second")
185 |         print(f"Error rate: {self.results['concurrent_load']['error_rate']:.2%}")
    |
    = help: Remove `print`

tests/test_performance.py:184:9: T201 `print` found
    |
183 |         print(f"Processed {total_events:,} events with {num_workers} workers")
184 |         print(f"Throughput: {total_events / elapsed:,.0f} events/second")
    |         ^^^^^ T201
185 |         print(f"Error rate: {self.results['concurrent_load']['error_rate']:.2%}")
    |
    = help: Remove `print`

tests/test_performance.py:185:9: T201 `print` found
    |
183 |         print(f"Processed {total_events:,} events with {num_workers} workers")
184 |         print(f"Throughput: {total_events / elapsed:,.0f} events/second")
185 |         print(f"Error rate: {self.results['concurrent_load']['error_rate']:.2%}")
    |         ^^^^^ T201
186 |
187 |     async def test_memory_usage(self, duration_seconds: int = 60):
    |
    = help: Remove `print`

tests/test_performance.py:189:9: T201 `print` found
    |
187 |     async def test_memory_usage(self, duration_seconds: int = 60):
188 |         """Test memory usage under load."""
189 |         print(f"\n=== Testing Memory Usage (duration={duration_seconds}s) ===")
    |         ^^^^^ T201
190 |
191 |         process = psutil.Process()
    |
    = help: Remove `print`

tests/test_performance.py:200:17: F841 Local variable `data` is assigned to but never used
    |
198 |             while time.time() - start_time < duration_seconds:
199 |                 # Create various objects to stress memory
200 |                 data = {
    |                 ^^^^ F841
201 |                     "features": np.random.rand(1000, 50),  # 1000 samples, 50 features
202 |                     "predictions": [random.random() for _ in range(1000)],
    |
    = help: Remove assignment to unused variable `data`

tests/test_performance.py:201:33: NPY002 Replace legacy `np.random.rand` call with `np.random.Generator`
    |
199 |                 # Create various objects to stress memory
200 |                 data = {
201 |                     "features": np.random.rand(1000, 50),  # 1000 samples, 50 features
    |                                 ^^^^^^^^^^^^^^ NPY002
202 |                     "predictions": [random.random() for _ in range(1000)],
203 |                     "events": [
    |

tests/test_performance.py:202:37: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
200 |                 data = {
201 |                     "features": np.random.rand(1000, 50),  # 1000 samples, 50 features
202 |                     "predictions": [random.random() for _ in range(1000)],
    |                                     ^^^^^^^^^^^^^^^ S311
203 |                     "events": [
204 |                         MarketDataEvent(
    |

tests/test_performance.py:208:47: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
206 |                             timestamp=datetime.now(UTC),
207 |                             trading_pair="XRP/USD",
208 |                             price=Decimal(str(random.random())),
    |                                               ^^^^^^^^^^^^^^^ S311
209 |                             volume=Decimal(str(random.random() * 1000000)),
210 |                         ) for _ in range(100)
    |

tests/test_performance.py:209:48: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
207 |                             trading_pair="XRP/USD",
208 |                             price=Decimal(str(random.random())),
209 |                             volume=Decimal(str(random.random() * 1000000)),
    |                                                ^^^^^^^^^^^^^^^ S311
210 |                         ) for _ in range(100)
211 |                     ],
    |

tests/test_performance.py:237:100: E501 Line too long (118 > 99)
    |
235 |             "final_rss_mb": memory_samples[-1]["rss_mb"] if memory_samples else 0,
236 |             "mean_rss_mb": statistics.mean(rss_values) if rss_values else 0,
237 |             "memory_growth_mb": (memory_samples[-1]["rss_mb"] - memory_samples[0]["rss_mb"]) if memory_samples else 0,
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
238 |         }
    |

tests/test_performance.py:240:9: T201 `print` found
    |
238 |         }
239 |
240 |         print(f"Initial memory: {self.results['memory_usage']['initial_rss_mb']:.1f}MB")
    |         ^^^^^ T201
241 |         print(f"Peak memory: {self.results['memory_usage']['peak_rss_mb']:.1f}MB")
242 |         print(f"Memory growth: {self.results['memory_usage']['memory_growth_mb']:.1f}MB")
    |
    = help: Remove `print`

tests/test_performance.py:241:9: T201 `print` found
    |
240 |         print(f"Initial memory: {self.results['memory_usage']['initial_rss_mb']:.1f}MB")
241 |         print(f"Peak memory: {self.results['memory_usage']['peak_rss_mb']:.1f}MB")
    |         ^^^^^ T201
242 |         print(f"Memory growth: {self.results['memory_usage']['memory_growth_mb']:.1f}MB")
    |
    = help: Remove `print`

tests/test_performance.py:242:9: T201 `print` found
    |
240 |         print(f"Initial memory: {self.results['memory_usage']['initial_rss_mb']:.1f}MB")
241 |         print(f"Peak memory: {self.results['memory_usage']['peak_rss_mb']:.1f}MB")
242 |         print(f"Memory growth: {self.results['memory_usage']['memory_growth_mb']:.1f}MB")
    |         ^^^^^ T201
243 |
244 |     async def test_cache_performance(self):
    |
    = help: Remove `print`

tests/test_performance.py:246:9: T201 `print` found
    |
244 |     async def test_cache_performance(self):
245 |         """Test cache hit rates and performance."""
246 |         print("\n=== Testing Cache Performance ===")
    |         ^^^^^ T201
247 |
248 |         from gal_friday.utils.performance_optimizer import LRUCache
    |
    = help: Remove `print`

tests/test_performance.py:261:26: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
260 |         for i in range(operations):
261 |             key = f"key_{random.randint(0, 999)}"
    |                          ^^^^^^^^^^^^^^^^^^^^^^ S311
262 |
263 |             start = time.perf_counter()
    |

tests/test_performance.py:281:9: T201 `print` found
    |
279 |         }
280 |
281 |         print(f"Cache hit rate: {stats['hit_rate']:.1%}")
    |         ^^^^^ T201
282 |         print(f"Mean latency: {self.results['cache_performance']['mean_latency_us']:.1f}μs")
283 |         print(f"P99 latency: {self.results['cache_performance']['p99_latency_us']:.1f}μs")
    |
    = help: Remove `print`

tests/test_performance.py:282:9: T201 `print` found
    |
281 |         print(f"Cache hit rate: {stats['hit_rate']:.1%}")
282 |         print(f"Mean latency: {self.results['cache_performance']['mean_latency_us']:.1f}μs")
    |         ^^^^^ T201
283 |         print(f"P99 latency: {self.results['cache_performance']['p99_latency_us']:.1f}μs")
    |
    = help: Remove `print`

tests/test_performance.py:283:9: T201 `print` found
    |
281 |         print(f"Cache hit rate: {stats['hit_rate']:.1%}")
282 |         print(f"Mean latency: {self.results['cache_performance']['mean_latency_us']:.1f}μs")
283 |         print(f"P99 latency: {self.results['cache_performance']['p99_latency_us']:.1f}μs")
    |         ^^^^^ T201
284 |
285 |     async def test_database_connection_pool(self):
    |
    = help: Remove `print`

tests/test_performance.py:287:9: T201 `print` found
    |
285 |     async def test_database_connection_pool(self):
286 |         """Test database connection pool performance."""
287 |         print("\n=== Testing Connection Pool Performance ===")
    |         ^^^^^ T201
288 |
289 |         from gal_friday.utils.performance_optimizer import ConnectionPool
    |
    = help: Remove `print`

tests/test_performance.py:294:27: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
292 |         async def create_mock_connection():
293 |             await asyncio.sleep(0.01)  # Simulate connection time
294 |             return {"id": random.randint(1000, 9999), "created": time.time()}
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
295 |
296 |         pool = ConnectionPool(
    |

tests/test_performance.py:316:34: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
314 |         for _ in range(num_operations):
315 |             start = time.perf_counter()
316 |             await use_connection(random.uniform(0.01, 0.05))
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
317 |             elapsed = time.perf_counter() - start
318 |             operation_times.append(elapsed * 1000)  # ms
    |

tests/test_performance.py:329:9: T201 `print` found
    |
327 |         }
328 |
329 |         print(f"Mean operation time: {self.results['connection_pool']['mean_time_ms']:.1f}ms")
    |         ^^^^^ T201
330 |         print(f"Pool stats: {pool_stats}")
    |
    = help: Remove `print`

tests/test_performance.py:330:9: T201 `print` found
    |
329 |         print(f"Mean operation time: {self.results['connection_pool']['mean_time_ms']:.1f}ms")
330 |         print(f"Pool stats: {pool_stats}")
    |         ^^^^^ T201
331 |
332 |         await pool.stop()
    |
    = help: Remove `print`

tests/test_performance.py:334:9: PLR0912 Too many branches (16 > 12)
    |
332 |         await pool.stop()
333 |
334 |     def generate_report(self) -> str:
    |         ^^^^^^^^^^^^^^^ PLR0912
335 |         """Generate performance test report."""
336 |         report = ["=" * 70]
    |

tests/test_performance.py:334:9: PLR0915 Too many statements (62 > 50)
    |
332 |         await pool.stop()
333 |
334 |     def generate_report(self) -> str:
    |         ^^^^^^^^^^^^^^^ PLR0915
335 |         """Generate performance test report."""
336 |         report = ["=" * 70]
    |

tests/test_performance.py:346:100: E501 Line too long (105 > 99)
    |
344 |             report.append("EVENT THROUGHPUT")
345 |             report.append("-" * 30)
346 |             report.append(f"Events/second: {self.results['event_throughput']['events_per_second']:,.0f}")
    |                                                                                                    ^^^^^^ E501
347 |             report.append("")
    |

tests/test_performance.py:364:100: E501 Line too long (104 > 99)
    |
362 |             report.append(f"Workers: {self.results['concurrent_load']['workers']}")
363 |             report.append(f"Total events: {self.results['concurrent_load']['total_events']:,}")
364 |             report.append(f"Events/second: {self.results['concurrent_load']['events_per_second']:,.0f}")
    |                                                                                                    ^^^^^ E501
365 |             report.append(f"Error rate: {self.results['concurrent_load']['error_rate']:.2%}")
366 |             report.append("")
    |

tests/test_performance.py:382:100: E501 Line too long (104 > 99)
    |
380 |             report.append("-" * 30)
381 |             report.append(f"Hit rate: {self.results['cache_performance']['hit_rate']:.1%}")
382 |             report.append(f"Mean latency: {self.results['cache_performance']['mean_latency_us']:.1f}μs")
    |                                                                                                    ^^^^^ E501
383 |             report.append("")
    |

tests/test_performance.py:394:73: PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
    |
392 |         # Check against targets
393 |         if "event_throughput" in self.results:
394 |             if self.results["event_throughput"]["events_per_second"] >= 10000:
    |                                                                         ^^^^^ PLR2004
395 |                 targets_met.append("✓ Event throughput > 10,000/s")
396 |             else:
    |

tests/test_performance.py:400:64: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
399 |         if "prediction_latency" in self.results:
400 |             if self.results["prediction_latency"]["p99_ms"] <= 50:
    |                                                                ^^ PLR2004
401 |                 targets_met.append("✓ Prediction P99 latency < 50ms")
402 |             else:
    |

tests/test_performance.py:406:68: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
405 |         if "memory_usage" in self.results:
406 |             if self.results["memory_usage"]["memory_growth_mb"] <= 100:
    |                                                                    ^^^ PLR2004
407 |                 targets_met.append("✓ Memory growth < 100MB")
408 |             else:
    |

tests/test_performance.py:426:5: T201 `print` found
    |
424 |     runner = PerformanceTestRunner()
425 |
426 |     print("Starting Gal-Friday Performance Tests...")
    |     ^^^^^ T201
427 |     print("This will take several minutes to complete.")
    |
    = help: Remove `print`

tests/test_performance.py:427:5: T201 `print` found
    |
426 |     print("Starting Gal-Friday Performance Tests...")
427 |     print("This will take several minutes to complete.")
    |     ^^^^^ T201
428 |
429 |     # Run tests
    |
    = help: Remove `print`

tests/test_performance.py:439:5: T201 `print` found
    |
437 |     # Generate report
438 |     report = runner.generate_report()
439 |     print("\n" + report)
    |     ^^^^^ T201
440 |
441 |     # Save report
    |
    = help: Remove `print`

tests/test_performance.py:442:10: PTH123 `open()` should be replaced by `Path.open()`
    |
441 |     # Save report
442 |     with open("performance_test_report.txt", "w") as f:
    |          ^^^^ PTH123
443 |         f.write(report)
444 |     print("\nReport saved to: performance_test_report.txt")
    |

tests/test_performance.py:444:5: T201 `print` found
    |
442 |     with open("performance_test_report.txt", "w") as f:
443 |         f.write(report)
444 |     print("\nReport saved to: performance_test_report.txt")
    |     ^^^^^ T201
445 |
446 |     return runner.results
    |
    = help: Remove `print`

tests/test_risk_management.py:49:100: E501 Line too long (110 > 99)
   |
48 |         # Risk per unit = Entry - Stop Loss
49 |         risk_per_unit = sample_proposed_signal.proposed_entry_price - sample_proposed_signal.proposed_sl_price
   |                                                                                                    ^^^^^^^^^^^ E501
50 |
51 |         # Position size = Risk Amount / Risk per unit
   |

tests/test_websocket_demo.py:8:5: T201 `print` found
   |
 6 | def demonstrate_websocket():
 7 |     """Demonstrate WebSocket functionality."""
 8 |     print("=== Gal-Friday WebSocket Real-Time Data Demo ===\n")
   |     ^^^^^ T201
 9 |
10 |     # 1. Connection States
   |
   = help: Remove `print`

tests/test_websocket_demo.py:11:5: T201 `print` found
   |
10 |     # 1. Connection States
11 |     print("1. WebSocket Connection Management:")
   |     ^^^^^ T201
12 |     print("   - Dual connections: Public (market data) + Private (orders)")
13 |     print("   - Automatic reconnection with exponential backoff")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:12:5: T201 `print` found
   |
10 |     # 1. Connection States
11 |     print("1. WebSocket Connection Management:")
12 |     print("   - Dual connections: Public (market data) + Private (orders)")
   |     ^^^^^ T201
13 |     print("   - Automatic reconnection with exponential backoff")
14 |     print("   - Health monitoring and recovery")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:13:5: T201 `print` found
   |
11 |     print("1. WebSocket Connection Management:")
12 |     print("   - Dual connections: Public (market data) + Private (orders)")
13 |     print("   - Automatic reconnection with exponential backoff")
   |     ^^^^^ T201
14 |     print("   - Health monitoring and recovery")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:14:5: T201 `print` found
   |
12 |     print("   - Dual connections: Public (market data) + Private (orders)")
13 |     print("   - Automatic reconnection with exponential backoff")
14 |     print("   - Health monitoring and recovery")
   |     ^^^^^ T201
15 |
16 |     # 2. Real-time Order Updates
   |
   = help: Remove `print`

tests/test_websocket_demo.py:17:5: T201 `print` found
   |
16 |     # 2. Real-time Order Updates
17 |     print("\n2. Real-time Order Updates:")
   |     ^^^^^ T201
18 |     print("   OLD: HTTP Polling")
19 |     print("   - Check order status every 1-5 seconds")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:18:5: T201 `print` found
   |
16 |     # 2. Real-time Order Updates
17 |     print("\n2. Real-time Order Updates:")
18 |     print("   OLD: HTTP Polling")
   |     ^^^^^ T201
19 |     print("   - Check order status every 1-5 seconds")
20 |     print("   - Wastes API rate limits")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:19:5: T201 `print` found
   |
17 |     print("\n2. Real-time Order Updates:")
18 |     print("   OLD: HTTP Polling")
19 |     print("   - Check order status every 1-5 seconds")
   |     ^^^^^ T201
20 |     print("   - Wastes API rate limits")
21 |     print("   - Can miss rapid status changes")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:20:5: T201 `print` found
   |
18 |     print("   OLD: HTTP Polling")
19 |     print("   - Check order status every 1-5 seconds")
20 |     print("   - Wastes API rate limits")
   |     ^^^^^ T201
21 |     print("   - Can miss rapid status changes")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:21:5: T201 `print` found
   |
19 |     print("   - Check order status every 1-5 seconds")
20 |     print("   - Wastes API rate limits")
21 |     print("   - Can miss rapid status changes")
   |     ^^^^^ T201
22 |
23 |     print("\n   NEW: WebSocket Streaming")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:23:5: T201 `print` found
   |
21 |     print("   - Can miss rapid status changes")
22 |
23 |     print("\n   NEW: WebSocket Streaming")
   |     ^^^^^ T201
24 |     print("   - Instant order updates (< 100ms)")
25 |     print("   - No API calls wasted")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:24:5: T201 `print` found
   |
23 |     print("\n   NEW: WebSocket Streaming")
24 |     print("   - Instant order updates (< 100ms)")
   |     ^^^^^ T201
25 |     print("   - No API calls wasted")
26 |     print("   - Never miss status changes")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:25:5: T201 `print` found
   |
23 |     print("\n   NEW: WebSocket Streaming")
24 |     print("   - Instant order updates (< 100ms)")
25 |     print("   - No API calls wasted")
   |     ^^^^^ T201
26 |     print("   - Never miss status changes")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:26:5: T201 `print` found
   |
24 |     print("   - Instant order updates (< 100ms)")
25 |     print("   - No API calls wasted")
26 |     print("   - Never miss status changes")
   |     ^^^^^ T201
27 |
28 |     # 3. Example Order Flow
   |
   = help: Remove `print`

tests/test_websocket_demo.py:29:5: T201 `print` found
   |
28 |     # 3. Example Order Flow
29 |     print("\n3. Example Order Flow:")
   |     ^^^^^ T201
30 |     order_events = [
31 |         {"time": "10:00:00.000", "status": "NEW", "latency": "0ms"},
   |
   = help: Remove `print`

tests/test_websocket_demo.py:33:100: E501 Line too long (104 > 99)
   |
31 |         {"time": "10:00:00.000", "status": "NEW", "latency": "0ms"},
32 |         {"time": "10:00:00.150", "status": "OPEN", "latency": "150ms"},
33 |         {"time": "10:00:02.300", "status": "PARTIALLY_FILLED", "latency": "50ms", "filled": "500/1000"},
   |                                                                                                    ^^^^^ E501
34 |         {"time": "10:00:02.850", "status": "FILLED", "latency": "50ms", "filled": "1000/1000"},
35 |     ]
   |

tests/test_websocket_demo.py:38:9: T201 `print` found
   |
37 |     for event in order_events:
38 |         print(f"   {event['time']} - Status: {event['status']} (Latency: {event['latency']})")
   |         ^^^^^ T201
39 |         if "filled" in event:
40 |             print(f"              - Filled: {event['filled']}")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:40:13: T201 `print` found
   |
38 |         print(f"   {event['time']} - Status: {event['status']} (Latency: {event['latency']})")
39 |         if "filled" in event:
40 |             print(f"              - Filled: {event['filled']}")
   |             ^^^^^ T201
41 |
42 |     # 4. Market Data Streaming
   |
   = help: Remove `print`

tests/test_websocket_demo.py:43:5: T201 `print` found
   |
42 |     # 4. Market Data Streaming
43 |     print("\n4. Real-time Market Data:")
   |     ^^^^^ T201
44 |     print("   - Order book updates: Every price change")
45 |     print("   - Trade feed: Every executed trade")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:44:5: T201 `print` found
   |
42 |     # 4. Market Data Streaming
43 |     print("\n4. Real-time Market Data:")
44 |     print("   - Order book updates: Every price change")
   |     ^^^^^ T201
45 |     print("   - Trade feed: Every executed trade")
46 |     print("   - Ticker updates: Current prices")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:45:5: T201 `print` found
   |
43 |     print("\n4. Real-time Market Data:")
44 |     print("   - Order book updates: Every price change")
45 |     print("   - Trade feed: Every executed trade")
   |     ^^^^^ T201
46 |     print("   - Ticker updates: Current prices")
47 |     print("   - OHLC candles: Real-time chart data")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:46:5: T201 `print` found
   |
44 |     print("   - Order book updates: Every price change")
45 |     print("   - Trade feed: Every executed trade")
46 |     print("   - Ticker updates: Current prices")
   |     ^^^^^ T201
47 |     print("   - OHLC candles: Real-time chart data")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:47:5: T201 `print` found
   |
45 |     print("   - Trade feed: Every executed trade")
46 |     print("   - Ticker updates: Current prices")
47 |     print("   - OHLC candles: Real-time chart data")
   |     ^^^^^ T201
48 |
49 |     # 5. Message Processing
   |
   = help: Remove `print`

tests/test_websocket_demo.py:50:5: T201 `print` found
   |
49 |     # 5. Message Processing
50 |     print("\n5. Advanced Message Processing:")
   |     ^^^^^ T201
51 |     print("   ✓ Sequence tracking with gap detection")
52 |     print("   ✓ Message deduplication")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:51:5: T201 `print` found
   |
49 |     # 5. Message Processing
50 |     print("\n5. Advanced Message Processing:")
51 |     print("   ✓ Sequence tracking with gap detection")
   |     ^^^^^ T201
52 |     print("   ✓ Message deduplication")
53 |     print("   ✓ Automatic gap recovery from cache")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:52:5: T201 `print` found
   |
50 |     print("\n5. Advanced Message Processing:")
51 |     print("   ✓ Sequence tracking with gap detection")
52 |     print("   ✓ Message deduplication")
   |     ^^^^^ T201
53 |     print("   ✓ Automatic gap recovery from cache")
54 |     print("   ✓ Message validation")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:53:5: T201 `print` found
   |
51 |     print("   ✓ Sequence tracking with gap detection")
52 |     print("   ✓ Message deduplication")
53 |     print("   ✓ Automatic gap recovery from cache")
   |     ^^^^^ T201
54 |     print("   ✓ Message validation")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:54:5: T201 `print` found
   |
52 |     print("   ✓ Message deduplication")
53 |     print("   ✓ Automatic gap recovery from cache")
54 |     print("   ✓ Message validation")
   |     ^^^^^ T201
   |
   = help: Remove `print`

tests/test_websocket_demo.py:59:5: T201 `print` found
   |
57 | def demonstrate_reconciliation():
58 |     """Demonstrate reconciliation functionality."""
59 |     print("\n\n=== Gal-Friday Portfolio Reconciliation Demo ===\n")
   |     ^^^^^ T201
60 |
61 |     # 1. What is Reconciliation?
   |
   = help: Remove `print`

tests/test_websocket_demo.py:62:5: T201 `print` found
   |
61 |     # 1. What is Reconciliation?
62 |     print("1. What is Reconciliation?")
   |     ^^^^^ T201
63 |     print("   - Compares internal records with exchange data")
64 |     print("   - Detects position mismatches")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:63:5: T201 `print` found
   |
61 |     # 1. What is Reconciliation?
62 |     print("1. What is Reconciliation?")
63 |     print("   - Compares internal records with exchange data")
   |     ^^^^^ T201
64 |     print("   - Detects position mismatches")
65 |     print("   - Auto-corrects small discrepancies")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:64:5: T201 `print` found
   |
62 |     print("1. What is Reconciliation?")
63 |     print("   - Compares internal records with exchange data")
64 |     print("   - Detects position mismatches")
   |     ^^^^^ T201
65 |     print("   - Auto-corrects small discrepancies")
66 |     print("   - Alerts on critical issues")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:65:5: T201 `print` found
   |
63 |     print("   - Compares internal records with exchange data")
64 |     print("   - Detects position mismatches")
65 |     print("   - Auto-corrects small discrepancies")
   |     ^^^^^ T201
66 |     print("   - Alerts on critical issues")
   |
   = help: Remove `print`

tests/test_websocket_demo.py:66:5: T201 `print` found
   |
64 |     print("   - Detects position mismatches")
65 |     print("   - Auto-corrects small discrepancies")
66 |     print("   - Alerts on critical issues")
   |     ^^^^^ T201
67 |
68 |     # 2. Example Reconciliation Report
   |
   = help: Remove `print`

tests/test_websocket_demo.py:69:5: T201 `print` found
   |
68 |     # 2. Example Reconciliation Report
69 |     print("\n2. Example Reconciliation Report:")
   |     ^^^^^ T201
70 |
71 |     report = {
   |
   = help: Remove `print`

tests/test_websocket_demo.py:108:5: T201 `print` found
    |
106 |     }
107 |
108 |     print(f"   Timestamp: {report['timestamp']}")
    |     ^^^^^ T201
109 |     print(f"   Status: {report['status']}")
110 |     print(f"   Positions Checked: {report['positions_checked']}")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:109:5: T201 `print` found
    |
108 |     print(f"   Timestamp: {report['timestamp']}")
109 |     print(f"   Status: {report['status']}")
    |     ^^^^^ T201
110 |     print(f"   Positions Checked: {report['positions_checked']}")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:110:5: T201 `print` found
    |
108 |     print(f"   Timestamp: {report['timestamp']}")
109 |     print(f"   Status: {report['status']}")
110 |     print(f"   Positions Checked: {report['positions_checked']}")
    |     ^^^^^ T201
111 |
112 |     print("\n   Position Discrepancies:")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:112:5: T201 `print` found
    |
110 |     print(f"   Positions Checked: {report['positions_checked']}")
111 |
112 |     print("\n   Position Discrepancies:")
    |     ^^^^^ T201
113 |     for disc in report["position_discrepancies"]:
114 |         print(f"   - {disc['pair']}: {disc['type']}")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:114:9: T201 `print` found
    |
112 |     print("\n   Position Discrepancies:")
113 |     for disc in report["position_discrepancies"]:
114 |         print(f"   - {disc['pair']}: {disc['type']}")
    |         ^^^^^ T201
115 |         print(f"     Internal: {disc.get('internal', 'N/A')}, Exchange: {disc.get('exchange', 'N/A')}")
116 |         print(f"     Severity: {disc['severity']}, Action: {disc['action']}")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:115:9: T201 `print` found
    |
113 |     for disc in report["position_discrepancies"]:
114 |         print(f"   - {disc['pair']}: {disc['type']}")
115 |         print(f"     Internal: {disc.get('internal', 'N/A')}, Exchange: {disc.get('exchange', 'N/A')}")
    |         ^^^^^ T201
116 |         print(f"     Severity: {disc['severity']}, Action: {disc['action']}")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:115:100: E501 Line too long (103 > 99)
    |
113 |     for disc in report["position_discrepancies"]:
114 |         print(f"   - {disc['pair']}: {disc['type']}")
115 |         print(f"     Internal: {disc.get('internal', 'N/A')}, Exchange: {disc.get('exchange', 'N/A')}")
    |                                                                                                    ^^^^ E501
116 |         print(f"     Severity: {disc['severity']}, Action: {disc['action']}")
    |

tests/test_websocket_demo.py:116:9: T201 `print` found
    |
114 |         print(f"   - {disc['pair']}: {disc['type']}")
115 |         print(f"     Internal: {disc.get('internal', 'N/A')}, Exchange: {disc.get('exchange', 'N/A')}")
116 |         print(f"     Severity: {disc['severity']}, Action: {disc['action']}")
    |         ^^^^^ T201
117 |
118 |     print("\n   Balance Discrepancies:")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:118:5: T201 `print` found
    |
116 |         print(f"     Severity: {disc['severity']}, Action: {disc['action']}")
117 |
118 |     print("\n   Balance Discrepancies:")
    |     ^^^^^ T201
119 |     for disc in report["balance_discrepancies"]:
120 |         print(f"   - {disc['currency']}: Diff = {disc['difference']} ({disc['action']})")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:120:9: T201 `print` found
    |
118 |     print("\n   Balance Discrepancies:")
119 |     for disc in report["balance_discrepancies"]:
120 |         print(f"   - {disc['currency']}: Diff = {disc['difference']} ({disc['action']})")
    |         ^^^^^ T201
121 |
122 |     print(f"\n   Untracked Orders: {len(report['untracked_orders'])}")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:122:5: T201 `print` found
    |
120 |         print(f"   - {disc['currency']}: Diff = {disc['difference']} ({disc['action']})")
121 |
122 |     print(f"\n   Untracked Orders: {len(report['untracked_orders'])}")
    |     ^^^^^ T201
123 |     print(f"   Auto-corrections Applied: {report['auto_corrections']}")
124 |     print(f"   Manual Review Required: {report['manual_review_required']}")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:123:5: T201 `print` found
    |
122 |     print(f"\n   Untracked Orders: {len(report['untracked_orders'])}")
123 |     print(f"   Auto-corrections Applied: {report['auto_corrections']}")
    |     ^^^^^ T201
124 |     print(f"   Manual Review Required: {report['manual_review_required']}")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:124:5: T201 `print` found
    |
122 |     print(f"\n   Untracked Orders: {len(report['untracked_orders'])}")
123 |     print(f"   Auto-corrections Applied: {report['auto_corrections']}")
124 |     print(f"   Manual Review Required: {report['manual_review_required']}")
    |     ^^^^^ T201
125 |
126 |     # 3. Benefits
    |
    = help: Remove `print`

tests/test_websocket_demo.py:127:5: T201 `print` found
    |
126 |     # 3. Benefits
127 |     print("\n3. Benefits of Automated Reconciliation:")
    |     ^^^^^ T201
128 |     print("   ✓ Prevents position drift")
129 |     print("   ✓ Catches missed trades")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:128:5: T201 `print` found
    |
126 |     # 3. Benefits
127 |     print("\n3. Benefits of Automated Reconciliation:")
128 |     print("   ✓ Prevents position drift")
    |     ^^^^^ T201
129 |     print("   ✓ Catches missed trades")
130 |     print("   ✓ Ensures accurate P&L")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:129:5: T201 `print` found
    |
127 |     print("\n3. Benefits of Automated Reconciliation:")
128 |     print("   ✓ Prevents position drift")
129 |     print("   ✓ Catches missed trades")
    |     ^^^^^ T201
130 |     print("   ✓ Ensures accurate P&L")
131 |     print("   ✓ Reduces manual work")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:130:5: T201 `print` found
    |
128 |     print("   ✓ Prevents position drift")
129 |     print("   ✓ Catches missed trades")
130 |     print("   ✓ Ensures accurate P&L")
    |     ^^^^^ T201
131 |     print("   ✓ Reduces manual work")
132 |     print("   ✓ Provides audit trail")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:131:5: T201 `print` found
    |
129 |     print("   ✓ Catches missed trades")
130 |     print("   ✓ Ensures accurate P&L")
131 |     print("   ✓ Reduces manual work")
    |     ^^^^^ T201
132 |     print("   ✓ Provides audit trail")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:132:5: T201 `print` found
    |
130 |     print("   ✓ Ensures accurate P&L")
131 |     print("   ✓ Reduces manual work")
132 |     print("   ✓ Provides audit trail")
    |     ^^^^^ T201
133 |
134 |     # 4. Reconciliation Process
    |
    = help: Remove `print`

tests/test_websocket_demo.py:135:5: T201 `print` found
    |
134 |     # 4. Reconciliation Process
135 |     print("\n4. Reconciliation Process:")
    |     ^^^^^ T201
136 |     print("   1. Query exchange positions/balances")
137 |     print("   2. Compare with internal records")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:136:5: T201 `print` found
    |
134 |     # 4. Reconciliation Process
135 |     print("\n4. Reconciliation Process:")
136 |     print("   1. Query exchange positions/balances")
    |     ^^^^^ T201
137 |     print("   2. Compare with internal records")
138 |     print("   3. Identify discrepancies")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:137:5: T201 `print` found
    |
135 |     print("\n4. Reconciliation Process:")
136 |     print("   1. Query exchange positions/balances")
137 |     print("   2. Compare with internal records")
    |     ^^^^^ T201
138 |     print("   3. Identify discrepancies")
139 |     print("   4. Auto-correct small differences")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:138:5: T201 `print` found
    |
136 |     print("   1. Query exchange positions/balances")
137 |     print("   2. Compare with internal records")
138 |     print("   3. Identify discrepancies")
    |     ^^^^^ T201
139 |     print("   4. Auto-correct small differences")
140 |     print("   5. Alert on critical issues")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:139:5: T201 `print` found
    |
137 |     print("   2. Compare with internal records")
138 |     print("   3. Identify discrepancies")
139 |     print("   4. Auto-correct small differences")
    |     ^^^^^ T201
140 |     print("   5. Alert on critical issues")
141 |     print("   6. Store report for audit")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:140:5: T201 `print` found
    |
138 |     print("   3. Identify discrepancies")
139 |     print("   4. Auto-correct small differences")
140 |     print("   5. Alert on critical issues")
    |     ^^^^^ T201
141 |     print("   6. Store report for audit")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:141:5: T201 `print` found
    |
139 |     print("   4. Auto-correct small differences")
140 |     print("   5. Alert on critical issues")
141 |     print("   6. Store report for audit")
    |     ^^^^^ T201
    |
    = help: Remove `print`

tests/test_websocket_demo.py:146:5: T201 `print` found
    |
144 | def show_integration():
145 |     """Show how WebSocket and Reconciliation work together."""
146 |     print("\n\n=== Integration: WebSocket + Reconciliation ===\n")
    |     ^^^^^ T201
147 |
148 |     print("How they work together:")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:148:5: T201 `print` found
    |
146 |     print("\n\n=== Integration: WebSocket + Reconciliation ===\n")
147 |
148 |     print("How they work together:")
    |     ^^^^^ T201
149 |     print("1. WebSocket provides real-time updates")
150 |     print("2. Reconciliation validates accuracy periodically")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:149:5: T201 `print` found
    |
148 |     print("How they work together:")
149 |     print("1. WebSocket provides real-time updates")
    |     ^^^^^ T201
150 |     print("2. Reconciliation validates accuracy periodically")
151 |     print("3. Together they ensure:")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:150:5: T201 `print` found
    |
148 |     print("How they work together:")
149 |     print("1. WebSocket provides real-time updates")
150 |     print("2. Reconciliation validates accuracy periodically")
    |     ^^^^^ T201
151 |     print("3. Together they ensure:")
152 |     print("   - Fast updates (WebSocket)")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:151:5: T201 `print` found
    |
149 |     print("1. WebSocket provides real-time updates")
150 |     print("2. Reconciliation validates accuracy periodically")
151 |     print("3. Together they ensure:")
    |     ^^^^^ T201
152 |     print("   - Fast updates (WebSocket)")
153 |     print("   - Data integrity (Reconciliation)")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:152:5: T201 `print` found
    |
150 |     print("2. Reconciliation validates accuracy periodically")
151 |     print("3. Together they ensure:")
152 |     print("   - Fast updates (WebSocket)")
    |     ^^^^^ T201
153 |     print("   - Data integrity (Reconciliation)")
154 |     print("   - Automatic recovery from issues")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:153:5: T201 `print` found
    |
151 |     print("3. Together they ensure:")
152 |     print("   - Fast updates (WebSocket)")
153 |     print("   - Data integrity (Reconciliation)")
    |     ^^^^^ T201
154 |     print("   - Automatic recovery from issues")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:154:5: T201 `print` found
    |
152 |     print("   - Fast updates (WebSocket)")
153 |     print("   - Data integrity (Reconciliation)")
154 |     print("   - Automatic recovery from issues")
    |     ^^^^^ T201
155 |
156 |     print("\nExample Scenario:")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:156:5: T201 `print` found
    |
154 |     print("   - Automatic recovery from issues")
155 |
156 |     print("\nExample Scenario:")
    |     ^^^^^ T201
157 |     print("- 10:00:00 - WebSocket receives order fill")
158 |     print("- 10:00:00.050 - Position updated internally")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:157:5: T201 `print` found
    |
156 |     print("\nExample Scenario:")
157 |     print("- 10:00:00 - WebSocket receives order fill")
    |     ^^^^^ T201
158 |     print("- 10:00:00.050 - Position updated internally")
159 |     print("- 11:00:00 - Hourly reconciliation runs")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:158:5: T201 `print` found
    |
156 |     print("\nExample Scenario:")
157 |     print("- 10:00:00 - WebSocket receives order fill")
158 |     print("- 10:00:00.050 - Position updated internally")
    |     ^^^^^ T201
159 |     print("- 11:00:00 - Hourly reconciliation runs")
160 |     print("- 11:00:01 - Confirms position matches exchange")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:159:5: T201 `print` found
    |
157 |     print("- 10:00:00 - WebSocket receives order fill")
158 |     print("- 10:00:00.050 - Position updated internally")
159 |     print("- 11:00:00 - Hourly reconciliation runs")
    |     ^^^^^ T201
160 |     print("- 11:00:01 - Confirms position matches exchange")
161 |     print("- Result: Fast updates + verified accuracy")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:160:5: T201 `print` found
    |
158 |     print("- 10:00:00.050 - Position updated internally")
159 |     print("- 11:00:00 - Hourly reconciliation runs")
160 |     print("- 11:00:01 - Confirms position matches exchange")
    |     ^^^^^ T201
161 |     print("- Result: Fast updates + verified accuracy")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:161:5: T201 `print` found
    |
159 |     print("- 11:00:00 - Hourly reconciliation runs")
160 |     print("- 11:00:01 - Confirms position matches exchange")
161 |     print("- Result: Fast updates + verified accuracy")
    |     ^^^^^ T201
    |
    = help: Remove `print`

tests/test_websocket_demo.py:166:5: T201 `print` found
    |
164 | def main():
165 |     """Run the demonstration."""
166 |     print("=" * 60)
    |     ^^^^^ T201
167 |     print("GAL-FRIDAY SPRINT 2 DEMONSTRATION")
168 |     print("Real-Time Capabilities Implementation")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:167:5: T201 `print` found
    |
165 |     """Run the demonstration."""
166 |     print("=" * 60)
167 |     print("GAL-FRIDAY SPRINT 2 DEMONSTRATION")
    |     ^^^^^ T201
168 |     print("Real-Time Capabilities Implementation")
169 |     print("=" * 60)
    |
    = help: Remove `print`

tests/test_websocket_demo.py:168:5: T201 `print` found
    |
166 |     print("=" * 60)
167 |     print("GAL-FRIDAY SPRINT 2 DEMONSTRATION")
168 |     print("Real-Time Capabilities Implementation")
    |     ^^^^^ T201
169 |     print("=" * 60)
    |
    = help: Remove `print`

tests/test_websocket_demo.py:169:5: T201 `print` found
    |
167 |     print("GAL-FRIDAY SPRINT 2 DEMONSTRATION")
168 |     print("Real-Time Capabilities Implementation")
169 |     print("=" * 60)
    |     ^^^^^ T201
170 |
171 |     demonstrate_websocket()
    |
    = help: Remove `print`

tests/test_websocket_demo.py:175:5: T201 `print` found
    |
173 |     show_integration()
174 |
175 |     print("\n" + "=" * 60)
    |     ^^^^^ T201
176 |     print("SPRINT 2 SUMMARY")
177 |     print("=" * 60)
    |
    = help: Remove `print`

tests/test_websocket_demo.py:176:5: T201 `print` found
    |
175 |     print("\n" + "=" * 60)
176 |     print("SPRINT 2 SUMMARY")
    |     ^^^^^ T201
177 |     print("=" * 60)
    |
    = help: Remove `print`

tests/test_websocket_demo.py:177:5: T201 `print` found
    |
175 |     print("\n" + "=" * 60)
176 |     print("SPRINT 2 SUMMARY")
177 |     print("=" * 60)
    |     ^^^^^ T201
178 |
179 |     print("\nWeek 3 - WebSocket Implementation ✅")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:179:5: T201 `print` found
    |
177 |     print("=" * 60)
178 |
179 |     print("\nWeek 3 - WebSocket Implementation ✅")
    |     ^^^^^ T201
180 |     print("- Core WebSocket client with dual connections")
181 |     print("- Message processing with sequencing")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:180:5: T201 `print` found
    |
179 |     print("\nWeek 3 - WebSocket Implementation ✅")
180 |     print("- Core WebSocket client with dual connections")
    |     ^^^^^ T201
181 |     print("- Message processing with sequencing")
182 |     print("- Connection health monitoring")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:181:5: T201 `print` found
    |
179 |     print("\nWeek 3 - WebSocket Implementation ✅")
180 |     print("- Core WebSocket client with dual connections")
181 |     print("- Message processing with sequencing")
    |     ^^^^^ T201
182 |     print("- Connection health monitoring")
183 |     print("- Market data service integration")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:182:5: T201 `print` found
    |
180 |     print("- Core WebSocket client with dual connections")
181 |     print("- Message processing with sequencing")
182 |     print("- Connection health monitoring")
    |     ^^^^^ T201
183 |     print("- Market data service integration")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:183:5: T201 `print` found
    |
181 |     print("- Message processing with sequencing")
182 |     print("- Connection health monitoring")
183 |     print("- Market data service integration")
    |     ^^^^^ T201
184 |
185 |     print("\nWeek 4 - Reconciliation Service ✅")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:185:5: T201 `print` found
    |
183 |     print("- Market data service integration")
184 |
185 |     print("\nWeek 4 - Reconciliation Service ✅")
    |     ^^^^^ T201
186 |     print("- Automated position/balance verification")
187 |     print("- Discrepancy detection and reporting")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:186:5: T201 `print` found
    |
185 |     print("\nWeek 4 - Reconciliation Service ✅")
186 |     print("- Automated position/balance verification")
    |     ^^^^^ T201
187 |     print("- Discrepancy detection and reporting")
188 |     print("- Auto-correction for small differences")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:187:5: T201 `print` found
    |
185 |     print("\nWeek 4 - Reconciliation Service ✅")
186 |     print("- Automated position/balance verification")
187 |     print("- Discrepancy detection and reporting")
    |     ^^^^^ T201
188 |     print("- Auto-correction for small differences")
189 |     print("- Database persistence of reports")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:188:5: T201 `print` found
    |
186 |     print("- Automated position/balance verification")
187 |     print("- Discrepancy detection and reporting")
188 |     print("- Auto-correction for small differences")
    |     ^^^^^ T201
189 |     print("- Database persistence of reports")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:189:5: T201 `print` found
    |
187 |     print("- Discrepancy detection and reporting")
188 |     print("- Auto-correction for small differences")
189 |     print("- Database persistence of reports")
    |     ^^^^^ T201
190 |
191 |     print("\nKey Achievements:")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:191:5: T201 `print` found
    |
189 |     print("- Database persistence of reports")
190 |
191 |     print("\nKey Achievements:")
    |     ^^^^^ T201
192 |     print("✓ Reduced order update latency from 1-5s to <100ms")
193 |     print("✓ 90% reduction in API calls")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:192:5: T201 `print` found
    |
191 |     print("\nKey Achievements:")
192 |     print("✓ Reduced order update latency from 1-5s to <100ms")
    |     ^^^^^ T201
193 |     print("✓ 90% reduction in API calls")
194 |     print("✓ 100% position accuracy with reconciliation")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:193:5: T201 `print` found
    |
191 |     print("\nKey Achievements:")
192 |     print("✓ Reduced order update latency from 1-5s to <100ms")
193 |     print("✓ 90% reduction in API calls")
    |     ^^^^^ T201
194 |     print("✓ 100% position accuracy with reconciliation")
195 |     print("✓ Automatic recovery from discrepancies")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:194:5: T201 `print` found
    |
192 |     print("✓ Reduced order update latency from 1-5s to <100ms")
193 |     print("✓ 90% reduction in API calls")
194 |     print("✓ 100% position accuracy with reconciliation")
    |     ^^^^^ T201
195 |     print("✓ Automatic recovery from discrepancies")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:195:5: T201 `print` found
    |
193 |     print("✓ 90% reduction in API calls")
194 |     print("✓ 100% position accuracy with reconciliation")
195 |     print("✓ Automatic recovery from discrepancies")
    |     ^^^^^ T201
196 |
197 |     print("\nNext Steps (Sprint 3):")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:197:5: T201 `print` found
    |
195 |     print("✓ Automatic recovery from discrepancies")
196 |
197 |     print("\nNext Steps (Sprint 3):")
    |     ^^^^^ T201
198 |     print("- A/B testing framework for models")
199 |     print("- Automated retraining pipeline")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:198:5: T201 `print` found
    |
197 |     print("\nNext Steps (Sprint 3):")
198 |     print("- A/B testing framework for models")
    |     ^^^^^ T201
199 |     print("- Automated retraining pipeline")
200 |     print("- Drift detection algorithms")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:199:5: T201 `print` found
    |
197 |     print("\nNext Steps (Sprint 3):")
198 |     print("- A/B testing framework for models")
199 |     print("- Automated retraining pipeline")
    |     ^^^^^ T201
200 |     print("- Drift detection algorithms")
201 |     print("- Performance optimization")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:200:5: T201 `print` found
    |
198 |     print("- A/B testing framework for models")
199 |     print("- Automated retraining pipeline")
200 |     print("- Drift detection algorithms")
    |     ^^^^^ T201
201 |     print("- Performance optimization")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:201:5: T201 `print` found
    |
199 |     print("- Automated retraining pipeline")
200 |     print("- Drift detection algorithms")
201 |     print("- Performance optimization")
    |     ^^^^^ T201
202 |
203 |     print("\n✅ Sprint 2 Complete!")
    |
    = help: Remove `print`

tests/test_websocket_demo.py:203:5: T201 `print` found
    |
201 |     print("- Performance optimization")
202 |
203 |     print("\n✅ Sprint 2 Complete!")
    |     ^^^^^ T201
    |
    = help: Remove `print`

tests/unit/dal/conftest.py:1:1: D100 Missing docstring in public module
tests/unit/dal/conftest.py:11:17: PT003 `scope='function'` is implied in `@pytest.fixture()`
   |
11 | @pytest.fixture(scope="function")
   |                 ^^^^^^^^^^^^^^^^ PT003
12 | async def db_engine():
13 |     # Using SQLite in-memory for tests
   |
   = help: Remove implied `scope` argument

tests/unit/dal/conftest.py:12:11: D103 Missing docstring in public function
   |
11 | @pytest.fixture(scope="function")
12 | async def db_engine():
   |           ^^^^^^^^^ D103
13 |     # Using SQLite in-memory for tests
14 |     engine = create_async_engine("sqlite+aiosqlite:///:memory:")
   |

tests/unit/dal/conftest.py:18:17: PT003 `scope='function'` is implied in `@pytest.fixture()`
   |
16 |     await engine.dispose()
17 |
18 | @pytest.fixture(scope="function")
   |                 ^^^^^^^^^^^^^^^^ PT003
19 | async def db_setup(db_engine):
20 |     # Ensures all tables are created and dropped for each test function
   |
   = help: Remove implied `scope` argument

tests/unit/dal/conftest.py:19:11: D103 Missing docstring in public function
   |
18 | @pytest.fixture(scope="function")
19 | async def db_setup(db_engine):
   |           ^^^^^^^^ D103
20 |     # Ensures all tables are created and dropped for each test function
21 |     async with db_engine.begin() as conn:
   |

tests/unit/dal/conftest.py:29:17: PT003 `scope='function'` is implied in `@pytest.fixture()`
   |
27 |         await conn.run_sync(Base.metadata.drop_all)
28 |
29 | @pytest.fixture(scope="function")
   |                 ^^^^^^^^^^^^^^^^ PT003
30 | def db_session_maker(db_engine):
31 |     # Provides an async_sessionmaker for the test db engine.
   |
   = help: Remove implied `scope` argument

tests/unit/dal/conftest.py:30:5: D103 Missing docstring in public function
   |
29 | @pytest.fixture(scope="function")
30 | def db_session_maker(db_engine):
   |     ^^^^^^^^^^^^^^^^ D103
31 |     # Provides an async_sessionmaker for the test db engine.
32 |     maker = async_sessionmaker(bind=db_engine, class_=AsyncSession, expire_on_commit=False)
   |

tests/unit/dal/conftest.py:33:12: RET504 Unnecessary assignment to `maker` before `return` statement
   |
31 |     # Provides an async_sessionmaker for the test db engine.
32 |     maker = async_sessionmaker(bind=db_engine, class_=AsyncSession, expire_on_commit=False)
33 |     return maker
   |            ^^^^^ RET504
34 |
35 | @pytest.fixture(scope="function")
   |
   = help: Remove unnecessary assignment

tests/unit/dal/conftest.py:35:17: PT003 `scope='function'` is implied in `@pytest.fixture()`
   |
33 |     return maker
34 |
35 | @pytest.fixture(scope="function")
   |                 ^^^^^^^^^^^^^^^^ PT003
36 | async def db_session(db_session_maker):
37 |     # Provides an AsyncSession for a test, managing its lifecycle.
   |
   = help: Remove implied `scope` argument

tests/unit/dal/conftest.py:36:11: D103 Missing docstring in public function
   |
35 | @pytest.fixture(scope="function")
36 | async def db_session(db_session_maker):
   |           ^^^^^^^^^^ D103
37 |     # Provides an AsyncSession for a test, managing its lifecycle.
38 |     async with db_session_maker() as session:
   |

tests/unit/dal/test_order_repository.py:1:1: D100 Missing docstring in public module
tests/unit/dal/test_order_repository.py:24:5: D103 Missing docstring in public function
   |
23 | # Helper to create sample order data
24 | def sample_order_data(override: dict = None) -> dict:
   |     ^^^^^^^^^^^^^^^^^ D103
25 |     data = {
26 |         "id": uuid.uuid4(), # Client-generated UUID for PK
   |

tests/unit/dal/test_order_repository.py:24:33: RUF013 PEP 484 prohibits implicit `Optional`
   |
23 | # Helper to create sample order data
24 | def sample_order_data(override: dict = None) -> dict:
   |                                 ^^^^ RUF013
25 |     data = {
26 |         "id": uuid.uuid4(), # Client-generated UUID for PK
   |
   = help: Convert to `T | None`

tests/unit/dal/test_order_repository.py:48:11: D103 Missing docstring in public function
   |
46 | @pytest.mark.unit
47 | @pytest.mark.asyncio
48 | async def test_create_order(db_session_maker, mock_logger, db_setup): # Use db_session_maker
   |           ^^^^^^^^^^^^^^^^^ D103
49 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
   |

tests/unit/dal/test_order_repository.py:69:11: D103 Missing docstring in public function
   |
67 | @pytest.mark.unit
68 | @pytest.mark.asyncio
69 | async def test_get_order_by_id(db_session_maker, mock_logger, db_setup):
   |           ^^^^^^^^^^^^^^^^^^^^ D103
70 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
   |

tests/unit/dal/test_order_repository.py:90:11: D103 Missing docstring in public function
   |
88 | @pytest.mark.unit
89 | @pytest.mark.asyncio
90 | async def test_update_order_status_direct_repo_update(db_session_maker, mock_logger, db_setup):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
91 |     # This tests the BaseRepository's update method as used by OrderRepository
92 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
   |

tests/unit/dal/test_order_repository.py:118:11: D103 Missing docstring in public function
    |
116 | @pytest.mark.unit
117 | @pytest.mark.asyncio
118 | async def test_order_repository_update_order_status_method(db_session_maker, mock_logger, db_setup):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
119 |     # This tests the specific update_order_status method in OrderRepository
120 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
    |

tests/unit/dal/test_order_repository.py:118:100: E501 Line too long (100 > 99)
    |
116 | @pytest.mark.unit
117 | @pytest.mark.asyncio
118 | async def test_order_repository_update_order_status_method(db_session_maker, mock_logger, db_setup):
    |                                                                                                    ^ E501
119 |     # This tests the specific update_order_status method in OrderRepository
120 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
    |

tests/unit/dal/test_order_repository.py:144:11: D103 Missing docstring in public function
    |
142 | @pytest.mark.unit
143 | @pytest.mark.asyncio
144 | async def test_delete_order(db_session_maker, mock_logger, db_setup):
    |           ^^^^^^^^^^^^^^^^^ D103
145 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
    |

tests/unit/dal/test_order_repository.py:168:11: D103 Missing docstring in public function
    |
166 | @pytest.mark.unit
167 | @pytest.mark.asyncio
168 | async def test_get_active_orders(db_session_maker, mock_logger, db_setup):
    |           ^^^^^^^^^^^^^^^^^^^^^^ D103
169 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
    |

tests/unit/dal/test_order_repository.py:185:11: D103 Missing docstring in public function
    |
183 | @pytest.mark.unit
184 | @pytest.mark.asyncio
185 | async def test_get_recent_orders(db_session_maker, mock_logger, db_setup):
    |           ^^^^^^^^^^^^^^^^^^^^^^ D103
186 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
    |

tests/unit/dal/test_order_repository.py:189:100: E501 Line too long (107 > 99)
    |
188 |     now = datetime.now(UTC)
189 |     order_new_dict = sample_order_data({"created_at": now - timedelta(hours=1), "signal_id": uuid.uuid4()})
    |                                                                                                    ^^^^^^^^ E501
190 |     order_old_dict = sample_order_data({"created_at": now - timedelta(hours=48), "signal_id": uuid.uuid4()})
    |

tests/unit/dal/test_order_repository.py:190:100: E501 Line too long (108 > 99)
    |
188 |     now = datetime.now(UTC)
189 |     order_new_dict = sample_order_data({"created_at": now - timedelta(hours=1), "signal_id": uuid.uuid4()})
190 |     order_old_dict = sample_order_data({"created_at": now - timedelta(hours=48), "signal_id": uuid.uuid4()})
    |                                                                                                    ^^^^^^^^^ E501
191 |
192 |     async with db_session_maker() as session:
    |

tests/unit/dal/test_order_repository.py:201:38: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
200 |     all_recent_orders = await repo.get_recent_orders(hours=72)
201 |     assert len(all_recent_orders) == 2
    |                                      ^ PLR2004
202 |
203 | @pytest.mark.unit
    |

tests/unit/dal/test_order_repository.py:205:11: D103 Missing docstring in public function
    |
203 | @pytest.mark.unit
204 | @pytest.mark.asyncio
205 | async def test_get_orders_by_signal(db_session_maker, mock_logger, db_setup):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
206 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
207 |     target_signal_id = uuid.uuid4()
    |

tests/unit/dal/test_order_repository.py:210:100: E501 Line too long (124 > 99)
    |
208 |     other_signal_id = uuid.uuid4()
209 |
210 |     order1_data = sample_order_data({"signal_id": target_signal_id, "created_at": datetime.now(UTC) - timedelta(minutes=2)})
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
211 |     order2_data = sample_order_data({"signal_id": target_signal_id, "created_at": datetime.now(UTC) - timedelta(minutes=1)})
212 |     order3_data = sample_order_data({"signal_id": other_signal_id})
    |

tests/unit/dal/test_order_repository.py:211:100: E501 Line too long (124 > 99)
    |
210 |     order1_data = sample_order_data({"signal_id": target_signal_id, "created_at": datetime.now(UTC) - timedelta(minutes=2)})
211 |     order2_data = sample_order_data({"signal_id": target_signal_id, "created_at": datetime.now(UTC) - timedelta(minutes=1)})
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
212 |     order3_data = sample_order_data({"signal_id": other_signal_id})
    |

tests/unit/dal/test_order_repository.py:218:100: E501 Line too long (119 > 99)
    |
216 |         await session.commit()
217 |
218 |     signal_orders = await repo.get_orders_by_signal(str(target_signal_id)) # Pass ID as string if needed by repo method
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
219 |     assert len(signal_orders) == 2
220 |     assert signal_orders[0].id == order1_data["id"] # Check order (ASC by created_at)
    |

tests/unit/dal/test_order_repository.py:219:34: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
218 |     signal_orders = await repo.get_orders_by_signal(str(target_signal_id)) # Pass ID as string if needed by repo method
219 |     assert len(signal_orders) == 2
    |                                  ^ PLR2004
220 |     assert signal_orders[0].id == order1_data["id"] # Check order (ASC by created_at)
221 |     assert signal_orders[1].id == order2_data["id"]
    |

tests/unit/dal/test_order_repository.py:227:11: D103 Missing docstring in public function
    |
225 | @pytest.mark.unit
226 | @pytest.mark.asyncio
227 | async def test_find_by_exchange_id(db_session_maker, mock_logger, db_setup):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ D103
228 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
229 |     target_exchange_id = "EXCH_ID_123"
    |

tests/unit/dal/test_order_repository.py:231:100: E501 Line too long (111 > 99)
    |
229 |     target_exchange_id = "EXCH_ID_123"
230 |
231 |     order_data_target = sample_order_data({"exchange_order_id": target_exchange_id, "signal_id": uuid.uuid4()})
    |                                                                                                    ^^^^^^^^^^^^ E501
232 |     order_data_other = sample_order_data({"exchange_order_id": "EXCH_ID_456", "signal_id": uuid.uuid4()})
    |

tests/unit/dal/test_order_repository.py:232:100: E501 Line too long (105 > 99)
    |
231 |     order_data_target = sample_order_data({"exchange_order_id": target_exchange_id, "signal_id": uuid.uuid4()})
232 |     order_data_other = sample_order_data({"exchange_order_id": "EXCH_ID_456", "signal_id": uuid.uuid4()})
    |                                                                                                    ^^^^^^ E501
233 |
234 |     async with db_session_maker() as session:
    |

Found 1378 errors.
No fixes available (540 hidden fixes can be enabled with the `--unsafe-fixes` option).
