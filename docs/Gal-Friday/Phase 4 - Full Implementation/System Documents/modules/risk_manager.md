# RiskManager Module Documentation

## Module Overview

The `gal_friday.risk_manager.py` module is a critical component of the Gal-Friday trading system, acting as the primary gatekeeper for trade execution. Its core purpose is to assess `TradeSignalProposedEvent`s generated by strategy modules against a comprehensive set of pre-defined risk parameters and the current state of the portfolio. Based on this assessment, the RiskManager either approves the signal, allowing it to proceed to execution, or rejects it. It also monitors overall portfolio risk, such as drawdown limits, and can trigger system-wide halts by publishing `PotentialHaltTriggerEvent` if critical risk thresholds are breached.

## Key Features

-   **Consumes Proposed Trade Signals:** Subscribes to `TradeSignalProposedEvent`s from the `PubSubManager`.
-   **Multi-Stage Validation Pipeline:** Employs a sequential, multi-stage validation process to check proposed trades against various criteria before approval.
-   **Comprehensive Configurable Risk Limits:** Supports a wide array of configurable risk parameters:
    -   Drawdown Limits: Maximum total, daily, and weekly drawdown percentages.
    -   Loss Limits: Maximum number of consecutive losses.
    -   Exposure Limits: Maximum exposure per individual asset and total portfolio exposure (as percentages of equity).
    -   Order Size Limits: Maximum absolute order size in USD (or valuation currency).
    -   Risk Per Trade: Maximum percentage of current equity to risk on a single trade.
    -   Stop-Loss Constraints: Minimum distance (percentage) required for a stop-loss from the entry/market price.
    -   Price Sanity Checks: "Fat-finger" check to prevent trades at prices significantly deviating from current market prices.
-   **Position Sizing:** Calculates the appropriate position size for a trade based on the configured `risk_per_trade_pct` and the distance to the stop-loss.
-   **Exchange-Specific Adjustments:**
    -   Rounds proposed entry, stop-loss, and take-profit prices to conform to the specific tick sizes of the trading pair on the exchange, using `ExchangeInfoService`.
    -   Adjusts the calculated trade quantity (base amount) to meet the exchange's lot size or step size requirements.
-   **Position Scaling Logic:** Handles scenarios where a new trade signal might affect an existing open position (e.g., adding to, partially closing, fully closing, or reversing a position).
-   **Available Balance Check:** Ensures sufficient funds are available in the quote currency before approving a trade.
-   **Dynamic Risk Adjustment:** Optionally adjusts the `risk_per_trade_pct` based on current market volatility relative to a calibrated "normal" volatility level for the trading pair.
-   **Periodic Risk Monitoring:** Includes background tasks to periodically check drawdown limits and log overall risk metrics.
-   **Event Publishing:**
    -   Publishes `TradeSignalApprovedEvent` for signals that pass all risk checks.
    -   Publishes `TradeSignalRejectedEvent` for signals that fail validation, including the reason for rejection.
    -   Publishes `PotentialHaltTriggerEvent` if critical risk limits (like max drawdown) are breached.

## Custom Exceptions

-   **`RiskManagerError(Exception)`**: Base class for all errors originating from the RiskManager.
-   **`SignalValidationStageError(RiskManagerError)`**: Raised when a proposed trade signal fails a specific validation stage in the pipeline. It typically includes the stage name and reason for failure.

## Internal Data Classes (Context Objects)

To pass data BrÃ©silthe various stages of the validation pipeline, the RiskManager uses internal data classes (often implemented as simple classes or `dataclasses`). These are not exposed externally but are crucial for the internal workflow:

-   **`Stage1Context`**: Holds initial data for Stage 1, including the proposed event and current portfolio state.
-   **`Stage2Context`**: Carries data from Stage 1 (e.g., rounded prices) into Stage 2 for market-dependent checks.
-   **`Stage3Context`**: Carries data from Stage 2 into Stage 3 for position sizing and portfolio-level checks.
-   **`FinalValidationDataContext`**: Aggregates all necessary data for the final set of pre-trade validations.
-   **`PriceValidationContext`**: Specifically for validating price-related aspects like fat-finger and SL distance.
-   **`PositionScalingContext`**: Contains information needed to evaluate how a new trade impacts existing positions.
-   **`PriceRoundingContext`**: Holds prices that need rounding and exchange information.
-   **`SizingResult`**: Encapsulates the result of position sizing calculations (e.g., calculated quantity, cost).

*Their primary role is to provide a structured way to pass an evolving set of parameters through the sequential validation steps, allowing each stage to access necessary inputs and contribute its outputs to the next stage.*

## Class `RiskManager`

### Initialization (`__init__`)

-   **Parameters:**
    -   `config (dict)`: A dictionary containing the configuration specific to the RiskManager, typically from `app_config["risk_manager"]`.
    -   `pubsub_manager (PubSubManager)`: An instance of `PubSubManager` for event communication.
    -   `portfolio_manager (PortfolioManager)`: An instance of `PortfolioManager` to access current portfolio state (equity, positions, funds).
    -   `logger_service (LoggerService)`: An instance of `LoggerService` for structured logging.
    -   `market_price_service (MarketPriceService)`: An instance of `MarketPriceService` to fetch current market prices.
    -   `exchange_info_service (ExchangeInfoService)`: An instance of `ExchangeInfoService` to get exchange-specific details like tick sizes and lot sizes.
-   **Actions:**
    -   Stores references to all provided services.
    -   Calls `_load_config()` to load risk parameters from the `config` dictionary.
    -   Calls `_validate_config()` to ensure the loaded parameters are valid.
    -   Initializes internal state, including consecutive loss counter, last P&L tracking, and data structures for dynamic risk adjustment.
    -   Sets up `asyncio.Event` for managing background task lifecycles.

### Configuration

-   **`_load_config() -> None`**:
    -   Loads all risk parameters from the `risk_manager` section of the application configuration. This includes limits (drawdown, exposure, order size, etc.), sizing parameters (`risk_per_trade_pct`), check intervals, and dynamic risk adjustment settings.
    -   Stores these parameters as internal attributes (e.g., `_max_total_drawdown_pct`, `_risk_per_trade_pct`).
    -   Converts percentage values to `Decimal` for precision.

-   **`_validate_config() -> None`**:
    -   Performs validation checks on the loaded risk parameters to ensure they are sensible (e.g., percentages are within valid ranges, thresholds are logical).
    -   Raises `ValueError` or logs errors if configurations are invalid.

### Service Lifecycle

-   **`async start() -> None`**:
    -   Subscribes `_handle_trade_signal_proposed` to `TradeSignalProposedEvent`.
    -   Subscribes `_handle_execution_report_for_losses` to `ExecutionReportEvent` (for tracking consecutive losses).
    -   If dynamic risk adjustment is enabled, calls `_calibrate_normal_volatility()` and starts the `_dynamic_risk_adjustment_loop()` background task.
    -   Starts the `_periodic_risk_check_loop()` for monitoring drawdown limits.
    -   Optionally starts `_risk_metrics_loop()` if configured.
    -   Logs that the RiskManager service has started.

-   **`async stop() -> None`**:
    -   Unsubscribes from all events.
    -   Signals and awaits completion of all background tasks (`_dynamic_risk_adjustment_loop`, `_periodic_risk_check_loop`, `_risk_metrics_loop`).
    -   Logs that the RiskManager service is stopping.

### Event Handling

-   **`async _handle_trade_signal_proposed(event: TradeSignalProposedEvent) -> None`**:
    -   The main entry point for processing a proposed trade signal.
    -   Fetches the current portfolio state from `_portfolio_manager.get_current_state()`.
    -   Initiates the multi-stage validation pipeline by creating an initial context object (`Stage1Context`) and calling the first stage (`_stage1_initial_validation_and_price_rounding`).
    -   If all stages pass, the final stage will call `_approve_signal()`.
    -   If any stage fails (raises `SignalValidationStageError`), it calls `_reject_signal()` with the error details.
    -   Handles any other unexpected exceptions by rejecting the signal.

-   **`async _handle_execution_report_for_losses(event: ExecutionReportEvent) -> None`**:
    -   Processes `ExecutionReportEvent`s, specifically looking for realized P&L from filled trades.
    -   If a trade results in a loss, increments `_consecutive_losses_count`.
    -   If a trade results in a profit, resets `_consecutive_losses_count` to zero.
    -   Checks if `_consecutive_losses_count` exceeds `_max_consecutive_losses`. If so, logs a warning and potentially could trigger other actions (e.g., temporarily halting new trades for the pair, though this specific action might be part of a more advanced policy).
    -   *Note: The actual calculation of realized P&L from an `ExecutionReportEvent` can be complex and might rely on `PortfolioManager` to have fully processed the trade and updated position P&L.*

### Validation Pipeline Stages (Private Methods)

These methods represent sequential checks. Each typically takes a context object from the previous stage and returns a new context object for the next, or raises `SignalValidationStageError`.

-   **`async _stage1_initial_validation_and_price_rounding(ctx: Stage1Context) -> Stage2Context`**:
    -   Performs initial validation of the proposed signal's data (e.g., valid pair, side, order type).
    -   Calls `_calculate_and_validate_prices()` to round entry, SL, and TP prices to exchange tick sizes and calculate default SL/TP if necessary.
    -   Constructs and returns `Stage2Context`.

-   **`async _stage2_market_price_dependent_checks(ctx: Stage2Context) -> Stage3Context`**:
    -   Fetches the current market price using `_get_current_market_price()`.
    -   Calls `_validate_prices_fat_finger_and_sl_distance()` to perform fat-finger checks (proposed entry vs. market) and ensure SL distance is adequate.
    -   Constructs and returns `Stage3Context`.

-   **`async _stage3_position_sizing_and_portfolio_checks(ctx: Stage3Context) -> FinalValidationDataContext`**:
    -   Calls `_calculate_and_validate_position_size()` to determine the trade quantity based on risk per trade, SL distance, and equity. This also checks against max order size.
    -   Calls `_check_position_scaling()` to handle interactions with existing positions (add to, reduce, close). This might adjust the calculated quantity.
    -   Adjusts the final quantity to meet exchange lot/step sizes using `_calculate_lot_size_with_fallback()`.
    -   Constructs and returns `FinalValidationDataContext`.

-   **`async _perform_final_pre_trade_validations(ctx: FinalValidationDataContext) -> None`**: (This method's outcome is approval or rejection directly)
    -   Performs final checks:
        -   Total portfolio exposure and exposure per asset against limits.
        -   Sufficient available balance in `_portfolio_manager` for the trade cost.
        -   Current portfolio drawdown against `_max_total_drawdown_pct`, `_max_daily_drawdown_pct`, `_max_weekly_drawdown_pct` using `_check_drawdown_limits(is_pre_trade_check=True)`.
    -   If all checks pass, calls `_approve_signal()`. Otherwise, raises `SignalValidationStageError`.

-   **`_validate_and_raise_if_error(validation_passed: bool, stage_name: str, reason: str, signal_event: TradeSignalProposedEvent) -> None`**:
    -   A utility method. If `validation_passed` is `False`, it logs the error and raises a `SignalValidationStageError` with the given details.

### Core Risk Logic (Private Methods)

-   **`async _calculate_and_validate_prices(ctx: PriceRoundingContext) -> PriceRoundingContext`**: (Modifies context in place or returns new)
    -   Rounds `proposed_entry_price`, `stop_loss_price`, `take_profit_price` using `_round_price_to_tick_size()`.
    -   If SL or TP are not provided in the signal, calculates default ones based on `risk_per_trade_pct` and `default_tp_rr_ratio` or entry price and percentages.

-   **`async _validate_prices_fat_finger_and_sl_distance(ctx: PriceValidationContext) -> None`**: (Raises on failure)
    -   For limit orders, checks if `proposed_entry_price` deviates from `current_market_price` by more than `_fat_finger_max_deviation_pct`.
    -   Checks if `stop_loss_price` is at least `_min_sl_distance_pct` away from `proposed_entry_price` (or `current_market_price` for market orders).

-   **`async _calculate_and_validate_position_size(equity: Decimal, risk_per_trade_pct: Decimal, sl_distance_pct: Decimal, entry_price: Decimal, trading_pair: str, max_order_size_usd: Decimal, max_single_pos_pct: Decimal) -> SizingResult`**:
    -   Calculates `risk_amount_usd = equity * risk_per_trade_pct`.
    -   Calculates `position_size_base_ccy = risk_amount_usd / (sl_distance_abs_price_change * quote_to_usd_conversion_rate)`.
    -   Converts this to `position_size_usd = position_size_base_ccy * entry_price`.
    -   Checks if `position_size_usd` exceeds `max_order_size_usd`.
    -   Checks if `position_size_usd` (plus existing position value if any) exceeds `max_single_position_pct` of equity.
    -   Returns a `SizingResult` object with calculated quantity, cost, etc. Raises on failure.

-   **`async _check_position_scaling(ctx: PositionScalingContext) -> PositionScalingContext`**: (Modifies context)
    -   Checks if an open position exists for the `trading_pair`.
    -   If sides match (e.g., proposed BUY, existing LONG): Allows adding to position if within limits.
    -   If sides differ (e.g., proposed BUY, existing SHORT):
        -   If proposed size > existing size: Close existing, open new in proposed direction (net size).
        -   If proposed size <= existing size: Reduce size of existing position.
    -   Adjusts `calculated_quantity` in the context based on this logic.

-   **`_check_drawdown_limits(portfolio_state: dict, is_pre_trade_check: bool = False) -> Tuple[bool, str]`**:
    -   Retrieves current drawdown figures (daily, weekly, total) from `portfolio_state`.
    -   Compares them against configured `_max_daily_drawdown_pct`, `_max_weekly_drawdown_pct`, `_max_total_drawdown_pct`.
    -   Returns `(passed: bool, reason: str)`. If `is_pre_trade_check` is `False` and a limit is breached, also publishes `PotentialHaltTriggerEvent`.

-   **`_check_single_drawdown_limit(current_drawdown: Decimal, max_drawdown: Decimal, period_name: str) -> Tuple[bool, str]`**:
    -   Helper to check one specific drawdown period (e.g., daily). Returns pass/fail and reason.

### Dynamic Risk Adjustment

-   **`async _dynamic_risk_adjustment_loop() -> None`**:
    -   A background task that runs periodically if `_enable_dynamic_risk_adjustment` is true.
    -   Sleeps for `_risk_adjustment_interval_s`.
    -   Fetches current market volatility (e.g., ATR over `_volatility_window_size`) for relevant trading pairs.
    -   Calls `_update_risk_parameters_based_on_volatility()` for each pair.

-   **`async _calibrate_normal_volatility() -> None`**:
    -   Called at startup if dynamic adjustment is enabled.
    -   Fetches historical price data for configured trading pairs.
    -   Calculates a "normal" or baseline daily volatility (e.g., average ATR over a longer period like 30-60 days) for each pair.
    -   Stores this `_normal_volatility_map[trading_pair]`.

-   **`_update_risk_parameters_based_on_volatility(trading_pair: str, current_volatility: Decimal) -> None`**:
    -   Compares `current_volatility` to `_normal_volatility_map[trading_pair]`.
    -   If current volatility is significantly higher than normal, it might reduce the effective `_risk_per_trade_pct` for that pair (e.g., scale it down proportionally or by fixed steps).
    -   If current volatility is significantly lower, it might revert `_risk_per_trade_pct` to its configured default or slightly increase it (up to a cap).
    -   This adjusted risk percentage is then used in `_calculate_and_validate_position_size`.

### Metrics & Utilities

-   **`async _periodic_risk_check_loop() -> None`**:
    -   Background task that runs every `_check_interval_s`.
    -   Fetches current portfolio state.
    -   Calls `_check_drawdown_limits(is_pre_trade_check=False)` to monitor overall portfolio drawdown and trigger halts if necessary.

-   **`async _risk_metrics_loop() -> None`**: (Optional, if `_risk_metrics_interval_s` is set)
    -   Background task to periodically calculate and log detailed risk metrics.
    -   Calls `_calculate_risk_metrics()`.

-   **`_calculate_risk_metrics(portfolio_state: dict) -> dict`**:
    -   Computes various risk metrics such as Sortino ratio, Sharpe ratio (if historical returns are tracked), current exposure details, VaR (Value at Risk) if models are available for it.
    -   Returns a dictionary of these metrics for logging.

-   **`_calculate_lot_size_with_fallback(trading_pair: str, base_amount: Decimal) -> Decimal`**:
    -   Uses `_exchange_info_service.get_instrument_details(trading_pair)` to get `step_size` or `lot_size`.
    -   Adjusts `base_amount` to be a valid multiple of the step/lot size (typically rounding down to be conservative).

-   **`_round_price_to_tick_size(price: Decimal, trading_pair: str) -> Decimal`**:
    -   Uses `_exchange_info_service.get_instrument_details(trading_pair)` to get `tick_size`.
    -   Rounds the given `price` to the nearest valid multiple of `tick_size`.

-   **`async _get_current_market_price(trading_pair: str) -> Optional[Decimal]`**:
    -   Fetches the latest market price (e.g., last trade price or mid-price) for `trading_pair` from `_market_price_service`.

-   **`_extract_relevant_portfolio_values(portfolio_state: dict) -> dict`**:
    -   Utility to safely extract and convert values like `total_equity`, `available_funds` from the potentially complex `portfolio_state` dictionary to `Decimal`, providing defaults if keys are missing.

### Signal Outcome

-   **`async _approve_signal(approved_event_data: dict, original_signal: TradeSignalProposedEvent) -> None`**:
    -   Constructs a `TradeSignalApprovedEvent` using `approved_event_data` (which includes the final rounded prices, calculated quantity, etc.).
    -   Publishes this event via `_pubsub_manager`.
    -   Logs the approved signal details.

-   **`async _reject_signal(reason: str, stage: str, signal_event: TradeSignalProposedEvent, rejection_code: int = 0) -> None`**:
    -   Constructs a `TradeSignalRejectedEvent` including the `reason`, `stage` of failure, `rejection_code`, and details of the original `signal_event`.
    -   Publishes this event via `_pubsub_manager`.
    -   Logs the rejected signal details.

## Dependencies

-   **`asyncio`**: For asynchronous operations and background tasks.
-   **`math`**: For numerical calculations (e.g., `floor`, `ceil` for lot/tick sizing).
-   **`statistics`**: Potentially for volatility calculations (e.g., `stdev`).
-   **`uuid`**: For generating unique event IDs.
-   **`datetime`**: For timestamping.
-   **`decimal.Decimal`**: For precise financial calculations.
-   **`gal_friday.core.events`**: Definitions for `TradeSignalProposedEvent`, `TradeSignalApprovedEvent`, `TradeSignalRejectedEvent`, `ExecutionReportEvent`, `PotentialHaltTriggerEvent`.
-   **`gal_friday.core.pubsub.PubSubManager`**: For event communication.
-   **`gal_friday.logger_service.LoggerService`**: For structured logging.
-   **`gal_friday.portfolio_manager.PortfolioManager`**: To access current portfolio state.
-   **`gal_friday.market_price_service.MarketPriceService`**: To fetch current market prices.
-   **`gal_friday.exchange_info_service.ExchangeInfoService`**: To get exchange-specific instrument details (tick size, lot size).

## Configuration (Key options from `risk_manager` section of app config)

-   **`limits` (dict)**:
    -   `max_total_drawdown_pct (Decimal)`: Max overall portfolio drawdown.
    -   `max_daily_drawdown_pct (Decimal)`: Max drawdown within a single day.
    -   `max_weekly_drawdown_pct (Decimal)`: Max drawdown within a single week.
    -   `max_consecutive_losses (int)`: Max number of consecutive losing trades.
    -   `max_exposure_per_asset_pct (Decimal)`: Max percentage of equity exposed to a single asset/pair.
    -   `max_total_exposure_pct (Decimal)`: Max total percentage of equity exposed across all assets.
    -   `max_order_size_usd (Decimal)`: Max value of a single order in the portfolio valuation currency.
-   **`sizing` (dict)**:
    -   `risk_per_trade_pct (Decimal)`: Percentage of equity to risk on a single trade. This can be dynamically adjusted.
    -   `default_tp_rr_ratio (Decimal, optional)`: Default reward/risk ratio for take profit if not explicitly set by `tp_pct` in signal.
-   **`check_interval_s (int)`**: Interval in seconds for periodic risk checks (e.g., drawdown).
-   **`min_sl_distance_pct (Decimal)`**: Minimum percentage distance stop-loss must be from entry/market price.
-   **`max_single_position_pct (Decimal)`**: Maximum percentage of equity that can be allocated to a single position.
-   **`fat_finger_max_deviation_pct (Decimal)`**: Maximum allowed deviation of a limit order price from the current market price.
-   **`exchange.taker_fee_pct (Decimal)`**: Exchange taker fee, used for more precise cost estimation (though often handled by PortfolioManager post-fill).
-   **`portfolio_valuation_currency (str)`**: The main currency for portfolio valuation (e.g., "USD").
-   **`enable_dynamic_risk_adjustment (bool)`**: Whether to enable volatility-based dynamic risk adjustment.
-   **`risk_adjustment_interval_s (int)`**: Interval for the dynamic risk adjustment loop.
-   **`volatility_window_size (int)`**: Window size (e.g., number of periods) for calculating current volatility (e.g., ATR).
-   **`risk_metrics_interval_s (int, optional)`**: Interval for calculating and logging detailed risk metrics.

## Adherence to Standards

This documentation aims to align with best practices for software documentation, drawing inspiration from principles found in standards such as:

-   **ISO/IEC/IEEE 26512:2018** (Acquirers and suppliers of information for users)
-   **ISO/IEC/IEEE 12207** (Software life cycle processes)
-   **ISO/IEC/IEEE 15288** (System life cycle processes)

The documentation endeavors to provide clear, comprehensive, and accurate information to facilitate the development, use, and maintenance of the `RiskManager` module.
