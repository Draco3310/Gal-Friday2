gal_friday/core/halt_coordinator.py:32:100: E501 Line too long (105 > 99)
   |
31 |     def __init__(
32 |         self, config_manager: ConfigManager, pubsub_manager: PubSubManager, logger_service: LoggerService
   |                                                                                                    ^^^^^^ E501
33 |     ) -> None:
34 |         """Initialize HaltCoordinator."""
   |

gal_friday/core/halt_coordinator.py:32:106: COM812 [*] Trailing comma missing
   |
31 |     def __init__(
32 |         self, config_manager: ConfigManager, pubsub_manager: PubSubManager, logger_service: LoggerService
   |                                                                                                          ^ COM812
33 |     ) -> None:
34 |         """Initialize HaltCoordinator."""
   |
   = help: Add trailing comma

gal_friday/core/halt_coordinator.py:93:90: COM812 [*] Trailing comma missing
   |
92 |     def register_condition(
93 |         self, condition_id: str, name: str, threshold: int | float | Decimal | str | bool
   |                                                                                          ^ COM812
94 |     ) -> None:
95 |         """Register a new HALT condition."""
   |
   = help: Add trailing comma

gal_friday/core/halt_coordinator.py:105:100: E501 Line too long (109 > 99)
    |
103 |         )
104 |
105 |     def update_condition(self, condition_id: str, current_value: int | float | Decimal | str | bool) -> bool:
    |                                                                                                    ^^^^^^^^^^ E501
106 |         """Update a condition's current value and check if triggered.
    |

gal_friday/core/halt_coordinator.py:126:49: COM812 [*] Trailing comma missing
    |
125 |         if isinstance(condition.threshold, int | float | Decimal) and isinstance(
126 |             current_value, int | float | Decimal
    |                                                 ^ COM812
127 |         ):
128 |             # Numeric comparison - both values must be numeric
    |
    = help: Add trailing comma

gal_friday/core/types.py:25:100: E501 Line too long (100 > 99)
   |
23 | T = TypeVar("T")
24 | T_co = TypeVar("T_co", covariant=True)
25 | PredictionOutput_co = TypeVar("PredictionOutput_co", covariant=True) # For PredictionServiceProtocol
   |                                                                                                    ^ E501
   |

gal_friday/dal/alembic_env/env.py:4:8: F401 [*] `os` imported but unused
  |
2 | import asyncio
3 | import logging
4 | import os
  |        ^^ F401
5 | import sys
6 | from logging.config import fileConfig
  |
  = help: Remove unused import: `os`

gal_friday/dal/alembic_env/env.py:15:16: F821 Undefined name `Path`
   |
13 | # PTH118: `os.path.join()` should be replaced by `Path` with `/` operator
14 | # PTH100: `os.path.abspath()` should be replaced by `Path.resolve()`
15 | APP_ROOT_DIR = Path(__file__).resolve().parent.parent.parent
   |                ^^^^ F821
16 | sys.path.insert(0, str(APP_ROOT_DIR))
   |

gal_friday/dal/alembic_env/env.py:19:1: E402 Module level import not at top of file
   |
18 | # Imports for Alembic hook type hints
19 | from typing import Any, Literal, cast
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
20 |
21 | # Application imports moved for E402 compliance
   |

gal_friday/dal/alembic_env/env.py:19:1: I001 [*] Import block is un-sorted or un-formatted
   |
18 |   # Imports for Alembic hook type hints
19 | / from typing import Any, Literal, cast
20 | |
21 | | # Application imports moved for E402 compliance
22 | | from gal_friday.config_manager import ConfigManager
23 | | # from gal_friday.logger_service import LoggerService # Not strictly used here
24 | | from gal_friday.dal.models import Base  # Import Base from your models package
25 | |
26 | | from alembic.autogenerate.api import (  # type: ignore[import-not-found]
27 | |     AutogenContext,
28 | |     CompareTypeContext,
29 | | )
30 | | from alembic.runtime.migration import MigrationContext  # type: ignore[import-not-found]
31 | | from sqlalchemy import Column as SAColumn  # Alias to avoid clash
32 | | from sqlalchemy.sql.schema import SchemaItem
   | |____________________________________________^ I001
33 |
34 |   # this is the Alembic Config object, which provides
   |
   = help: Organize imports

gal_friday/dal/alembic_env/env.py:22:1: E402 Module level import not at top of file
   |
21 | # Application imports moved for E402 compliance
22 | from gal_friday.config_manager import ConfigManager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
23 | # from gal_friday.logger_service import LoggerService # Not strictly used here
24 | from gal_friday.dal.models import Base  # Import Base from your models package
   |

gal_friday/dal/alembic_env/env.py:24:1: E402 Module level import not at top of file
   |
22 | from gal_friday.config_manager import ConfigManager
23 | # from gal_friday.logger_service import LoggerService # Not strictly used here
24 | from gal_friday.dal.models import Base  # Import Base from your models package
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
25 |
26 | from alembic.autogenerate.api import (  # type: ignore[import-not-found]
   |

gal_friday/dal/alembic_env/env.py:26:1: E402 Module level import not at top of file
   |
24 |   from gal_friday.dal.models import Base  # Import Base from your models package
25 |
26 | / from alembic.autogenerate.api import (  # type: ignore[import-not-found]
27 | |     AutogenContext,
28 | |     CompareTypeContext,
29 | | )
   | |_^ E402
30 |   from alembic.runtime.migration import MigrationContext  # type: ignore[import-not-found]
31 |   from sqlalchemy import Column as SAColumn  # Alias to avoid clash
   |

gal_friday/dal/alembic_env/env.py:30:1: E402 Module level import not at top of file
   |
28 |     CompareTypeContext,
29 | )
30 | from alembic.runtime.migration import MigrationContext  # type: ignore[import-not-found]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
31 | from sqlalchemy import Column as SAColumn  # Alias to avoid clash
32 | from sqlalchemy.sql.schema import SchemaItem
   |

gal_friday/dal/alembic_env/env.py:31:1: E402 Module level import not at top of file
   |
29 | )
30 | from alembic.runtime.migration import MigrationContext  # type: ignore[import-not-found]
31 | from sqlalchemy import Column as SAColumn  # Alias to avoid clash
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
32 | from sqlalchemy.sql.schema import SchemaItem
   |

gal_friday/dal/alembic_env/env.py:32:1: E402 Module level import not at top of file
   |
30 | from alembic.runtime.migration import MigrationContext  # type: ignore[import-not-found]
31 | from sqlalchemy import Column as SAColumn  # Alias to avoid clash
32 | from sqlalchemy.sql.schema import SchemaItem
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
33 |
34 | # this is the Alembic Config object, which provides
   |

gal_friday/dal/alembic_env/env.py:59:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `obj`
   |
58 | def render_item(
59 |     type_: str, obj: Any, autogen_context: AutogenContext,  # type: ignore[arg-type]
   |                      ^^^ ANN401
60 | ) -> str | Literal[False] | None:
61 |     """Render an item for Alembic."""
   |

gal_friday/dal/alembic_env/env.py:66:84: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `compare_to`
   |
65 | def include_object(
66 |     object: SchemaItem, name: str | None, type_: str, reflected: bool, compare_to: Any | None,  # type: ignore[arg-type]
   |                                                                                    ^^^^^^^^^^ ANN401
67 | ) -> bool:
68 |     """Determine if an object should be included in the migration."""
   |

gal_friday/dal/alembic_env/env.py:89:47: COM812 [*] Trailing comma missing
   |
87 |     logger.debug(
88 |         f"Checking include_symbol for {symbol_type} {symbol_name} "
89 |         f"in table {schema_name}.{table_name}"
   |                                               ^ COM812
90 |     )
91 |     return True
   |
   = help: Add trailing comma

gal_friday/dal/alembic_env/env.py:97:21: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `inspected_type`
   |
95 |     inspected_column: dict[str, Any],
96 |     metadata_column: SAColumn,
97 |     inspected_type: Any,  # type: ignore[arg-type]
   |                     ^^^ ANN401
98 |     metadata_type: Any,  # type: ignore[arg-type]
99 | ) -> bool | None:
   |

gal_friday/dal/alembic_env/env.py:98:20: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `metadata_type`
    |
 96 |     metadata_column: SAColumn,
 97 |     inspected_type: Any,  # type: ignore[arg-type]
 98 |     metadata_type: Any,  # type: ignore[arg-type]
    |                    ^^^ ANN401
 99 | ) -> bool | None:
100 |     """Compare database and metadata types."""
    |

gal_friday/dal/alembic_env/env.py:103:55: COM812 [*] Trailing comma missing
    |
101 |     logger.debug(
102 |         f"Comparing type for column {metadata_column.name}: "
103 |         f"DB {inspected_type} vs Meta {metadata_type}"
    |                                                       ^ COM812
104 |     )
105 |     return None
    |
    = help: Add trailing comma

gal_friday/dal/alembic_env/env.py:119:94: COM812 [*] Trailing comma missing
    |
117 |             db_url = config.get_main_option("sqlalchemy.url")
118 |             logger.warning(
119 |                 f"DB URL from ConfigManager empty, falling back to alembic.ini URL: {db_url}"
    |                                                                                              ^ COM812
120 |             )
121 |         else:
    |
    = help: Add trailing comma

gal_friday/dal/alembic_env/env.py:185:98: COM812 [*] Trailing comma missing
    |
183 |     db_url = get_db_url()
184 |     logger.info(
185 |         "Configuring context for metadata-only autogeneration (no actual DB connection attempt)."
    |                                                                                                  ^ COM812
186 |     )
187 |     connectable = create_async_engine(db_url, poolclass=pool.NullPool)
    |
    = help: Add trailing comma

gal_friday/dal/alembic_env/env.py:187:5: F841 Local variable `connectable` is assigned to but never used
    |
185 |         "Configuring context for metadata-only autogeneration (no actual DB connection attempt)."
186 |     )
187 |     connectable = create_async_engine(db_url, poolclass=pool.NullPool)
    |     ^^^^^^^^^^^ F841
188 |
189 |     context.configure(
    |
    = help: Remove assignment to unused variable `connectable`

gal_friday/dal/alembic_env/env.py:187:19: F821 Undefined name `create_async_engine`
    |
185 |         "Configuring context for metadata-only autogeneration (no actual DB connection attempt)."
186 |     )
187 |     connectable = create_async_engine(db_url, poolclass=pool.NullPool)
    |                   ^^^^^^^^^^^^^^^^^^^ F821
188 |
189 |     context.configure(
    |

gal_friday/dal/alembic_env/env.py:187:57: F821 Undefined name `pool`
    |
185 |         "Configuring context for metadata-only autogeneration (no actual DB connection attempt)."
186 |     )
187 |     connectable = create_async_engine(db_url, poolclass=pool.NullPool)
    |                                                         ^^^^ F821
188 |
189 |     context.configure(
    |

gal_friday/dal/base.py:11:5: I001 [*] Import block is un-sorted or un-formatted
   |
10 |   if TYPE_CHECKING:
11 | /     from gal_friday.dal.models import Base
12 | |     from gal_friday.logger_service import LoggerService
13 | |     # TC001: Ensure Base is imported within TYPE_CHECKING for type hinting T
14 | |     from gal_friday.dal.models import Base as _BaseForTypeVar
   | |_____________________________________________________________^ I001
15 |   else:
16 |       # This path is taken at runtime. Base might be imported here if not strictly for typing.
   |
   = help: Organize imports

gal_friday/dal/base.py:14:47: F401 [*] `gal_friday.dal.models.Base` imported but unused
   |
12 |     from gal_friday.logger_service import LoggerService
13 |     # TC001: Ensure Base is imported within TYPE_CHECKING for type hinting T
14 |     from gal_friday.dal.models import Base as _BaseForTypeVar
   |                                               ^^^^^^^^^^^^^^^ F401
15 | else:
16 |     # This path is taken at runtime. Base might be imported here if not strictly for typing.
   |
   = help: Remove unused import: `gal_friday.dal.models.Base`

gal_friday/dal/base.py:92:42: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `entity_id`
   |
90 |             raise
91 |
92 |     async def get_by_id(self, entity_id: Any) -> T | None:  # type: ignore[arg-type]
   |                                          ^^^ ANN401
93 |         """Get an entity by its primary key.
   |

gal_friday/dal/base.py:125:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `entity_id`
    |
123 |             raise
124 |
125 |     async def update(self, entity_id: Any, updates: dict[str, Any]) -> T | None:  # type: ignore[arg-type]
    |                                       ^^^ ANN401
126 |         """Update an existing entity.
    |

gal_friday/dal/base.py:162:25: B010 [*] Do not call `setattr` with a constant attribute value. It is not any safer than normal property access.
    |
160 |                     if hasattr(entity, "updated_at"):
161 |                         # Assuming updated_at is a standard datetime field
162 |                         setattr(entity, "updated_at", datetime.now(UTC))
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B010
    |
    = help: Replace `setattr` with assignment

gal_friday/dal/base.py:230:98: COM812 [*] Trailing comma missing
    |
228 |                     if not hasattr(self.model_class, col_name):
229 |                         raise ValueError(
230 |                             f"Invalid order_by column: {col_name} on {self.model_class.__name__}" # E501
    |                                                                                                  ^ COM812
231 |                         )
    |
    = help: Add trailing comma

gal_friday/dal/base.py:230:100: E501 Line too long (104 > 99)
    |
228 |                     if not hasattr(self.model_class, col_name):
229 |                         raise ValueError(
230 |                             f"Invalid order_by column: {col_name} on {self.model_class.__name__}" # E501
    |                                                                                                    ^^^^^ E501
231 |                         )
    |

gal_friday/dal/base.py:264:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `entity_id`
    |
262 |             raise
263 |
264 |     async def delete(self, entity_id: Any) -> bool:  # type: ignore[arg-type]
    |                                       ^^^ ANN401
265 |         """Delete entity by ID.
    |

gal_friday/dal/connection_pool.py:66:100: E501 Line too long (109 > 99)
   |
64 |                         pool_size=min_pool_size,  # SQLAlchemy uses pool_size
65 |                         max_overflow=max_pool_size - min_pool_size,  # max_overflow
66 |                         pool_recycle=pool_recycle_seconds,  # Corresponds to max_inactive_connection_lifetime
   |                                                                                                    ^^^^^^^^^^ E501
67 |                         pool_timeout=pool_timeout_seconds,  # Corresponds to command_timeout
68 |                         echo=echo_sql,  # Optional: log SQL
   |

gal_friday/dal/migrations/migration_manager.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Database migration management system using Alembic."""
 2 |
 3 | / import os
 4 | | import io # For capturing stdout
 5 | | import re # For parsing revision output
 6 | | from pathlib import Path # For PTH compliance
 7 | | from contextlib import redirect_stdout # For capturing stdout
 8 | | from collections.abc import Sequence
 9 | |
10 | | from alembic import command  # type: ignore[import-not-found]
11 | | from alembic.config import Config  # type: ignore[import-not-found]
12 | | # ScriptDirectory was unused after F841 fix, so removing if not needed.
13 | | # from alembic.script import ScriptDirectory  # type: ignore[import-not-found]
14 | |
15 | | from gal_friday.logger_service import LoggerService
   | |___________________________________________________^ I001
   |
   = help: Organize imports

gal_friday/dal/migrations/migration_manager.py:3:8: F401 [*] `os` imported but unused
  |
1 | """Database migration management system using Alembic."""
2 |
3 | import os
  |        ^^ F401
4 | import io # For capturing stdout
5 | import re # For parsing revision output
  |
  = help: Remove unused import: `os`

gal_friday/dal/migrations/migration_manager.py:49:46: COM812 [*] Trailing comma missing
   |
47 |         self.logger.info(
48 |             "Attempting to upgrade database to head...",
49 |             source_module=self._source_module
   |                                              ^ COM812
50 |         )
51 |         try:
   |
   = help: Add trailing comma

gal_friday/dal/migrations/migration_manager.py:56:50: COM812 [*] Trailing comma missing
   |
54 |             self.logger.info(
55 |                 "Database upgrade to head completed successfully.",
56 |                 source_module=self._source_module
   |                                                  ^ COM812
57 |             )
58 |         except Exception as e:
   |
   = help: Add trailing comma

gal_friday/dal/migrations/migration_manager.py:89:46: COM812 [*] Trailing comma missing
   |
87 |         self.logger.debug(
88 |             "Fetching current database revision(s)...",
89 |             source_module=self._source_module
   |                                              ^ COM812
90 |         )
91 |         try:
   |
   = help: Add trailing comma

gal_friday/dal/migrations/migration_manager.py:93:1: W293 [*] Blank line contains whitespace
   |
91 |         try:
92 |             alembic_cfg = self._get_alembic_config()
93 |             
   | ^^^^^^^^^^^^ W293
94 |             s = io.StringIO()
95 |             with redirect_stdout(s):
   |
   = help: Remove whitespace from blank line

gal_friday/dal/migrations/migration_manager.py:101:87: COM812 [*] Trailing comma missing
    |
 99 |             if not output or "no migration detected" in output:
100 |                 self.logger.info(
101 |                     "No current revision detected.", source_module=self._source_module
    |                                                                                       ^ COM812
102 |                 )
103 |                 return tuple()
    |
    = help: Add trailing comma

gal_friday/dal/migrations/migration_manager.py:110:50: COM812 [*] Trailing comma missing
    |
108 |             self.logger.info(
109 |                 f"Current database revision(s): {revisions}",
110 |                 source_module=self._source_module
    |                                                  ^ COM812
111 |             )
112 |             return tuple(revisions)
    |
    = help: Add trailing comma

gal_friday/dal/migrations/migration_manager.py:125:46: COM812 [*] Trailing comma missing
    |
123 |         self.logger.info(
124 |             f"Stamping database with revision: {revision}",
125 |             source_module=self._source_module
    |                                              ^ COM812
126 |         )
127 |         try:
    |
    = help: Add trailing comma

gal_friday/dal/migrations/migration_manager.py:142:86: COM812 [*] Trailing comma missing
    |
141 |     def generate_revision(
142 |         self, message: str, autogenerate: bool = True, revision_id: str | None = None
    |                                                                                      ^ COM812
143 |     ) -> None:
144 |         """Generate a new revision file."""
    |
    = help: Add trailing comma

gal_friday/dal/models/drift_detection_event.py:36:47: COM812 Trailing comma missing
   |
34 |     )
35 |     drift_type: Mapped[str] = mapped_column(
36 |         String(50), nullable=False, index=True
   |                                               ^ COM812
37 |     )  # Added index
38 |     metric_name: Mapped[str] = mapped_column(String(100), nullable=False)
   |
   = help: Add trailing comma

gal_friday/dal/models/drift_detection_event.py:41:52: COM812 Trailing comma missing
   |
39 |     drift_score: Mapped[Decimal] = mapped_column(Numeric(10, 6), nullable=False)
40 |     is_significant: Mapped[bool | None] = mapped_column(
41 |         Boolean, server_default="false", index=True
   |                                                    ^ COM812
42 |     )  # Added index
43 |     details: Mapped[dict | None] = mapped_column(JSONB, nullable=True)
   |
   = help: Add trailing comma

gal_friday/dal/models/drift_detection_event.py:45:45: COM812 Trailing comma missing
   |
43 |     details: Mapped[dict | None] = mapped_column(JSONB, nullable=True)
44 |     detected_at: Mapped[datetime] = mapped_column(
45 |         DateTime, nullable=False, index=True
   |                                             ^ COM812
46 |     )  # Added index
   |
   = help: Add trailing comma

gal_friday/dal/models/drift_detection_event.py:56:6: SyntaxError: Expected ')', found newline
   |
54 |         Index("idx_drift_detected", "detected_at"),
55 |         Index("idx_drift_significant", "is_significant"),
56 |     )
   |      ^
57 |
58 |     def __repr__(self) -> str:
59 |         """Return a string representation of the DriftDetectionEvent."""
   |

gal_friday/dal/models/event_log.py:5:52: F401 [*] `sqlalchemy.dialects.postgresql.UUID` imported but unused
  |
4 | from sqlalchemy import JSON, Column, DateTime, Index, String
5 | from sqlalchemy.dialects.postgresql import UUID as POSTGRES_UUID
  |                                                    ^^^^^^^^^^^^^ F401
6 |
7 | from gal_friday.dal.models.models_base import Base
  |
  = help: Remove unused import: `sqlalchemy.dialects.postgresql.UUID`

gal_friday/dal/models/event_log.py:15:23: F821 Undefined name `PostgresUUID`
   |
13 |     __tablename__ = "event_logs"
14 |
15 |     event_id = Column(PostgresUUID(as_uuid=True), primary_key=True)
   |                       ^^^^^^^^^^^^ F821
16 |     event_type = Column(String(100), nullable=False)
17 |     source_module = Column(String(100), nullable=False)
   |

gal_friday/dal/models/experiment_assignment.py:21:45: COM812 [*] Trailing comma missing
   |
19 |     )
20 |     event_id: Mapped[UUID] = mapped_column(
21 |         UUID(as_uuid=True), primary_key=True
   |                                             ^ COM812
22 |     )  # Assuming this is a generic UUID for an event
23 |     variant: Mapped[str] = mapped_column(String(20), nullable=False)
   |
   = help: Add trailing comma

gal_friday/dal/models/experiment_assignment.py:25:45: COM812 [*] Trailing comma missing
   |
23 |     variant: Mapped[str] = mapped_column(String(20), nullable=False)
24 |     assigned_at: Mapped[datetime] = mapped_column(
25 |         DateTime, nullable=False, index=True
   |                                             ^ COM812
26 |     )  # Added index
   |
   = help: Add trailing comma

gal_friday/dal/models/experiment_assignment.py:29:100: E501 Line too long (103 > 99)
   |
28 |     # Relationship to Experiment
29 |     experiment = relationship("Experiment")  # Add back_populates="assignments" to Experiment if needed
   |                                                                                                    ^^^^ E501
30 |
31 |     __table_args__ = (
   |

gal_friday/dal/models/experiment_outcome.py:36:47: COM812 [*] Trailing comma missing
   |
34 |     event_id: Mapped[UUID] = mapped_column(UUID(as_uuid=True), nullable=False)
35 |     variant: Mapped[str] = mapped_column(
36 |         String(20), nullable=False, index=True
   |                                               ^ COM812
37 |     )  # Added index based on schema
38 |     outcome_data: Mapped[dict] = mapped_column(JSONB, nullable=False)
   |
   = help: Add trailing comma

gal_friday/dal/models/experiment_outcome.py:43:45: COM812 [*] Trailing comma missing
   |
41 |     trade_return: Mapped[Decimal | None] = mapped_column(Numeric(10, 4), nullable=True)
42 |     recorded_at: Mapped[datetime] = mapped_column(
43 |         DateTime, nullable=False, index=True
   |                                             ^ COM812
44 |     )  # Added index
   |
   = help: Add trailing comma

gal_friday/dal/models/experiment_outcome.py:47:100: E501 Line too long (100 > 99)
   |
46 |     # Relationship to Experiment
47 |     experiment = relationship("Experiment")  # Add back_populates="outcomes" to Experiment if needed
   |                                                                                                    ^ E501
48 |
49 |     __table_args__ = (
   |

gal_friday/dal/models/log.py:31:29: COM812 [*] Trailing comma missing
   |
29 |     func_name: Mapped[str | None] = mapped_column(String(255), nullable=True)
30 |     context_json: Mapped[dict | None] = mapped_column(
31 |         JSONB, nullable=True
   |                             ^ COM812
32 |     )  # Stored as dict, maps to JSONB
33 |     exception_text: Mapped[str | None] = mapped_column(Text, nullable=True)
   |
   = help: Add trailing comma

gal_friday/dal/models/model_deployment.py:28:33: COM812 Trailing comma missing
   |
26 |     )
27 |     deployed_at: Mapped[datetime] = mapped_column(
28 |         DateTime, nullable=False
   |                                 ^ COM812
29 |     )  # No server_default in schema
30 |     deployed_by: Mapped[str | None] = mapped_column(String(255), nullable=True)
   |
   = help: Add trailing comma

gal_friday/dal/models/model_deployment.py:33:51: COM812 Trailing comma missing
   |
31 |     deployment_config: Mapped[dict | None] = mapped_column(JSONB, nullable=True)
32 |     is_active: Mapped[bool | None] = mapped_column(
33 |         Boolean, server_default="true", index=True
   |                                                   ^ COM812
34 |     )  # Added index
   |
   = help: Add trailing comma

gal_friday/dal/models/model_deployment.py:42:6: SyntaxError: Expected ')', found newline
   |
40 |         Index("idx_deployments_model", "model_id"),
41 |         Index("idx_deployments_active", "is_active"),
42 |     )
   |      ^
43 |
44 |     def __repr__(self) -> str:
45 |         """Return a string representation of the ModelDeployment."""
   |

gal_friday/dal/models/model_version.py:22:48: COM812 [*] Trailing comma missing
   |
20 |     model_id: Mapped[UUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
21 |     model_name: Mapped[str] = mapped_column(
22 |         String(255), nullable=False, index=True
   |                                                ^ COM812
23 |     )  # Added index based on schema
24 |     version: Mapped[str] = mapped_column(String(50), nullable=False)
   |
   = help: Add trailing comma

gal_friday/dal/models/model_version.py:26:33: COM812 [*] Trailing comma missing
   |
24 |     version: Mapped[str] = mapped_column(String(50), nullable=False)
25 |     created_at: Mapped[datetime] = mapped_column(
26 |         DateTime, nullable=False
   |                                 ^ COM812
27 |     )  # No server_default in schema
28 |     training_completed_at: Mapped[datetime | None] = mapped_column(
   |
   = help: Add trailing comma

gal_friday/dal/models/model_version.py:29:32: COM812 [*] Trailing comma missing
   |
27 |     )  # No server_default in schema
28 |     training_completed_at: Mapped[datetime | None] = mapped_column(
29 |         DateTime, nullable=True
   |                                ^ COM812
30 |     )
31 |     stage: Mapped[str | None] = mapped_column(
   |
   = help: Add trailing comma

gal_friday/dal/models/model_version.py:32:61: COM812 [*] Trailing comma missing
   |
30 |     )
31 |     stage: Mapped[str | None] = mapped_column(
32 |         String(50), server_default="development", index=True
   |                                                             ^ COM812
33 |     )  # Added index based on schema
34 |     metrics: Mapped[dict | None] = mapped_column(JSONB, nullable=True)
   |
   = help: Add trailing comma

gal_friday/dal/models/position.py:25:47: COM812 [*] Trailing comma missing
   |
23 |     )
24 |     trading_pair: Mapped[str] = mapped_column(
25 |         String(20), nullable=False, index=True
   |                                               ^ COM812
26 |     )  # Added index based on schema
27 |     side: Mapped[str] = mapped_column(String(10), nullable=False)
   |
   = help: Add trailing comma

gal_friday/dal/models/position_adjustment.py:31:35: COM812 [*] Trailing comma missing
   |
29 |     )
30 |     trading_pair: Mapped[str] = mapped_column(
31 |         String(20), nullable=False
   |                                   ^ COM812
32 |     )  # From 003, added index
33 |     adjustment_type: Mapped[str] = mapped_column(
   |
   = help: Add trailing comma

gal_friday/dal/models/position_adjustment.py:34:35: COM812 [*] Trailing comma missing
   |
32 |     )  # From 003, added index
33 |     adjustment_type: Mapped[str] = mapped_column(
34 |         String(50), nullable=False
   |                                   ^ COM812
35 |     )  # From 003
36 |     old_value: Mapped[Decimal | None] = mapped_column(Numeric(20, 8), nullable=True)
   |
   = help: Add trailing comma

gal_friday/dal/models/reconciliation_event.py:24:45: COM812 [*] Trailing comma missing
   |
22 |     reconciliation_id: Mapped[UUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
23 |     timestamp: Mapped[datetime] = mapped_column(
24 |         DateTime, nullable=False, index=True
   |                                             ^ COM812
25 |     )  # Added index based on schema
26 |     reconciliation_type: Mapped[str] = mapped_column(
   |
   = help: Add trailing comma

gal_friday/dal/models/reconciliation_event.py:27:35: COM812 [*] Trailing comma missing
   |
25 |     )  # Added index based on schema
26 |     reconciliation_type: Mapped[str] = mapped_column(
27 |         String(50), nullable=False
   |                                   ^ COM812
28 |     )  # From 003
29 |     status: Mapped[str] = mapped_column(
   |
   = help: Add trailing comma

gal_friday/dal/models/reconciliation_event.py:30:47: COM812 [*] Trailing comma missing
   |
28 |     )  # From 003
29 |     status: Mapped[str] = mapped_column(
30 |         String(50), nullable=False, index=True
   |                                               ^ COM812
31 |     )  # From 003, added index
32 |     discrepancies_found: Mapped[int | None] = mapped_column(
   |
   = help: Add trailing comma

gal_friday/dal/models/reconciliation_event.py:33:36: COM812 [*] Trailing comma missing
   |
31 |     )  # From 003, added index
32 |     discrepancies_found: Mapped[int | None] = mapped_column(
33 |         Integer, server_default="0"
   |                                    ^ COM812
34 |     )
35 |     auto_corrected: Mapped[int | None] = mapped_column(Integer, server_default="0")
   |
   = help: Add trailing comma

gal_friday/dal/models/reconciliation_event.py:37:36: COM812 [*] Trailing comma missing
   |
35 |     auto_corrected: Mapped[int | None] = mapped_column(Integer, server_default="0")
36 |     manual_review_required: Mapped[int | None] = mapped_column(
37 |         Integer, server_default="0"
   |                                    ^ COM812
38 |     )
39 |     report: Mapped[dict] = mapped_column(JSONB, nullable=False)  # From 003
   |
   = help: Add trailing comma

gal_friday/dal/models/reconciliation_event.py:41:38: COM812 [*] Trailing comma missing
   |
39 |     report: Mapped[dict] = mapped_column(JSONB, nullable=False)  # From 003
40 |     duration_seconds: Mapped[Decimal | None] = mapped_column(
41 |         Numeric(10, 3), nullable=True
   |                                      ^ COM812
42 |     )  # Precision from 003
43 |     created_at: Mapped[datetime | None] = mapped_column(
   |
   = help: Add trailing comma

gal_friday/dal/models/reconciliation_event.py:44:58: COM812 [*] Trailing comma missing
   |
42 |     )  # Precision from 003
43 |     created_at: Mapped[datetime | None] = mapped_column(
44 |         DateTime, server_default=func.current_timestamp()
   |                                                          ^ COM812
45 |     )
   |
   = help: Add trailing comma

gal_friday/dal/models/trade_signal.py:30:47: COM812 [*] Trailing comma missing
   |
28 |     confidence: Mapped[Decimal | None] = mapped_column(Numeric(5, 4), nullable=True)
29 |     status: Mapped[str] = mapped_column(
30 |         String(20), nullable=False, index=True
   |                                               ^ COM812
31 |     )  # Added index based on schema
32 |     created_at: Mapped[datetime] = mapped_column(
   |
   = help: Add trailing comma

gal_friday/dal/repositories/experiment_repository.py:101:100: E501 Line too long (103 > 99)
    |
 99 |                 .where(
100 |                     Experiment.status.in_(["created", "running"]),
101 |                     (Experiment.end_time.is_(None)) | (Experiment.end_time > datetime.now(UTC)), # E711
    |                                                                                                    ^^^^ E501
102 |                 )
103 |                 .order_by(Experiment.start_time.desc())
    |

gal_friday/dal/repositories/experiment_repository.py:129:82: COM812 [*] Trailing comma missing
    |
127 |         stmt = stmt.on_conflict_do_nothing(
128 |             index_elements=[
129 |                 ExperimentAssignment.experiment_id, ExperimentAssignment.event_id
    |                                                                                  ^ COM812
130 |             ],
131 |         )
    |
    = help: Add trailing comma

gal_friday/dal/repositories/experiment_repository.py:140:80: COM812 [*] Trailing comma missing
    |
138 |             return await session.get(
139 |                 ExperimentAssignment,
140 |                 (assignment_data["experiment_id"], assignment_data["event_id"])
    |                                                                                ^ COM812
141 |             )
    |
    = help: Add trailing comma

gal_friday/dal/repositories/experiment_repository.py:187:72: COM812 [*] Trailing comma missing
    |
185 |                 func.count().label("sample_count"),
186 |                 func.sum(
187 |                     cast(ExperimentOutcome.correct_prediction, Integer)
    |                                                                        ^ COM812
188 |                 ).label("correct_predictions"),
189 |                 func.sum(
    |
    = help: Add trailing comma

gal_friday/dal/repositories/experiment_repository.py:190:70: COM812 [*] Trailing comma missing
    |
188 |                 ).label("correct_predictions"),
189 |                 func.sum(
190 |                     cast(ExperimentOutcome.signal_generated, Integer)
    |                                                                      ^ COM812
191 |                 ).label("signals_generated"),
192 |                 func.sum(ExperimentOutcome.trade_return).label("total_return"),
    |
    = help: Add trailing comma

gal_friday/dal/repositories/experiment_repository.py:194:72: COM812 [*] Trailing comma missing
    |
192 |                 func.sum(ExperimentOutcome.trade_return).label("total_return"),
193 |                 func.avg(
194 |                     cast(ExperimentOutcome.correct_prediction, Numeric)
    |                                                                        ^ COM812
195 |                 ).label("accuracy"),
196 |             )
    |
    = help: Add trailing comma

gal_friday/dal/repositories/experiment_repository.py:214:69: COM812 [*] Trailing comma missing
    |
213 |     async def save_results(
214 |         self, experiment_id: uuid.UUID, results_data: dict[str, Any]
    |                                                                     ^ COM812
215 |     ) -> Experiment | None:
216 |         """Save final experiment results by updating the Experiment model."""
    |
    = help: Add trailing comma

gal_friday/dal/repositories/model_repository.py:100:77: COM812 [*] Trailing comma missing
    |
 98 |             filters["stage"] = stage
 99 |         return await self.find_all(
100 |             filters=filters if filters else None, order_by="created_at DESC"
    |                                                                             ^ COM812
101 |         )
    |
    = help: Add trailing comma

gal_friday/dal/repositories/model_repository.py:132:100: E501 Line too long (108 > 99)
    |
130 |         deployment_config: dict | None = None,
131 |     ) -> ModelDeployment:
132 |         """Internal helper to create a deployment record and deactivate old ones for the same model name."""
    |                                                                                                    ^^^^^^^^^ E501
133 |         async with self.session_maker() as session:
134 |             # Deactivate previous active deployments for this model_name
    |

gal_friday/dal/repositories/model_repository.py:142:72: COM812 [*] Trailing comma missing
    |
140 |                     ModelDeployment.model_id.in_(
141 |                 select(ModelVersion.model_id).where(
142 |                     ModelVersion.model_name == model_version.model_name
    |                                                                        ^ COM812
143 |                 ),
144 |                     ),
    |
    = help: Add trailing comma

gal_friday/dal/repositories/model_repository.py:146:100: E501 Line too long (112 > 99)
    |
144 |                     ),
145 |             ModelDeployment.is_active,  # E712
146 |             ModelDeployment.model_id != model_version.model_id,  # Don't deactivate if re-deploying same version
    |                                                                                                    ^^^^^^^^^^^^^ E501
147 |                 )
148 |                 .values(is_active=False)
    |

gal_friday/dal/repositories/model_repository.py:185:54: COM812 [*] Trailing comma missing
    |
183 |                 self.logger.debug(
184 |                     f"Found active deployment for model {model_name}",
185 |                     source_module=self._source_module
    |                                                      ^ COM812
186 |                 )
187 |             else:
    |
    = help: Add trailing comma

gal_friday/dal/repositories/model_repository.py:190:54: COM812 [*] Trailing comma missing
    |
188 |                 self.logger.debug(
189 |                     f"No active deployment found for model {model_name}",
190 |                     source_module=self._source_module
    |                                                      ^ COM812
191 |                 )
192 |             return deployment
    |
    = help: Add trailing comma

gal_friday/dal/repositories/model_repository.py:195:34: COM812 [*] Trailing comma missing
    |
194 |     async def get_deployments_for_model_version(
195 |         self, model_id: uuid.UUID
    |                                  ^ COM812
196 |     ) -> Sequence[ModelDeployment]:
197 |         """Get all deployment records for a specific model version ID."""
    |
    = help: Add trailing comma

gal_friday/dal/repositories/model_repository.py:208:50: COM812 [*] Trailing comma missing
    |
206 |             self.logger.debug(
207 |                 f"Found {len(deployments)} deployments for model_id {model_id}",
208 |                 source_module=self._source_module
    |                                                  ^ COM812
209 |             )
210 |             return deployments
    |
    = help: Add trailing comma

gal_friday/dal/repositories/position_repository.py:76:100: E501 Line too long (104 > 99)
   |
74 |             async with self.session_maker() as session:
75 |                 stmt = select(
76 |                     func.count(Position.id).filter(Position.is_active).label("active_positions"), # E712
   |                                                                                                    ^^^^^ E501
77 |                     func.count(Position.id).filter(not_(Position.is_active)).label("closed_positions"), # E712
78 |                     func.sum(cast(Position.realized_pnl, Numeric)).label("total_realized_pnl"),
   |

gal_friday/dal/repositories/position_repository.py:77:52: F821 Undefined name `not_`
   |
75 |                 stmt = select(
76 |                     func.count(Position.id).filter(Position.is_active).label("active_positions"), # E712
77 |                     func.count(Position.id).filter(not_(Position.is_active)).label("closed_positions"), # E712
   |                                                    ^^^^ F821
78 |                     func.sum(cast(Position.realized_pnl, Numeric)).label("total_realized_pnl"),
79 |                     func.sum(cast(Position.unrealized_pnl, Numeric)).filter(Position.is_active).label("total_unrealized_pnl"), # E712
   |

gal_friday/dal/repositories/position_repository.py:77:100: E501 Line too long (110 > 99)
   |
75 |                 stmt = select(
76 |                     func.count(Position.id).filter(Position.is_active).label("active_positions"), # E712
77 |                     func.count(Position.id).filter(not_(Position.is_active)).label("closed_positions"), # E712
   |                                                                                                    ^^^^^^^^^^^ E501
78 |                     func.sum(cast(Position.realized_pnl, Numeric)).label("total_realized_pnl"),
79 |                     func.sum(cast(Position.unrealized_pnl, Numeric)).filter(Position.is_active).label("total_unrealized_pnl"), # E712
   |

gal_friday/dal/repositories/position_repository.py:79:100: E501 Line too long (133 > 99)
   |
77 |                     func.count(Position.id).filter(not_(Position.is_active)).label("closed_positions"), # E712
78 |                     func.sum(cast(Position.realized_pnl, Numeric)).label("total_realized_pnl"),
79 |                     func.sum(cast(Position.unrealized_pnl, Numeric)).filter(Position.is_active).label("total_unrealized_pnl"), # E712
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
80 |                 )
81 |                 result = await session.execute(stmt)
   |

gal_friday/dal/repositories/position_repository.py:86:89: COM812 [*] Trailing comma missing
   |
84 |                 if summary:
85 |                     self.logger.debug(
86 |                         "Retrieved position summary.", source_module=self._source_module
   |                                                                                         ^ COM812
87 |                     )
88 |                     # Convert Row to dict, handling None for sums if necessary
   |
   = help: Add trailing comma

gal_friday/dal/repositories/position_repository.py:101:54: COM812 [*] Trailing comma missing
    |
 99 |                 self.logger.warning(
100 |                     "Position summary query returned no rows or null sums.",
101 |                     source_module=self._source_module
    |                                                      ^ COM812
102 |                 )
103 |                 return {
    |
    = help: Add trailing comma

gal_friday/dal/repositories/reconciliation_repository.py:49:9: SIM102 Use a single `if` statement instead of nested `if` statements
   |
47 |           if "reconciliation_id" not in event_data:  # Ensure ID is present if not auto-gen by DB
48 |               event_data["reconciliation_id"] = event_data.get("reconciliation_id", uuid.uuid4())
49 | /         if "timestamp" in event_data and isinstance(event_data["timestamp"], datetime):
50 | |             if event_data["timestamp"].tzinfo is None:
   | |______________________________________________________^ SIM102
51 |                    event_data["timestamp"] = event_data["timestamp"].replace(tzinfo=UTC)
   |
   = help: Combine `if` statements using `and`

gal_friday/dal/repositories/reconciliation_repository.py:83:50: COM812 [*] Trailing comma missing
   |
81 |             self.logger.debug(
82 |                 f"Found {len(events)} reconciliation events from last {days} days.",
83 |                 source_module=self._source_module
   |                                                  ^ COM812
84 |             )
85 |             return events
   |
   = help: Add trailing comma

gal_friday/dal/repositories/reconciliation_repository.py:101:50: COM812 [*] Trailing comma missing
    |
 99 |             self.logger.error(
100 |                 "Cannot save PositionAdjustment without reconciliation_id.",
101 |                 source_module=self._source_module
    |                                                  ^ COM812
102 |             )
103 |             raise ValueError("reconciliation_id is required to save a PositionAdjustment.")
    |
    = help: Add trailing comma

gal_friday/dal/repositories/reconciliation_repository.py:115:50: COM812 [*] Trailing comma missing
    |
113 |             self.logger.debug(
114 |                 f"Saved new PositionAdjustment with ID {instance.adjustment_id}",
115 |                 source_module=self._source_module
    |                                                  ^ COM812
116 |             )
117 |             return instance
    |
    = help: Add trailing comma

gal_friday/dal/repositories/reconciliation_repository.py:136:50: COM812 [*] Trailing comma missing
    |
134 |             self.logger.debug(
135 |                 f"Found {len(adjustments)} adjustments for event {reconciliation_id}",
136 |                 source_module=self._source_module
    |                                                  ^ COM812
137 |             )
138 |             return adjustments
    |
    = help: Add trailing comma

gal_friday/dal/repositories/reconciliation_repository.py:155:50: COM812 [*] Trailing comma missing
    |
153 |             self.logger.debug(
154 |                 f"Retrieved adjustment history for last {days} days.",
155 |                 source_module=self._source_module
    |                                                  ^ COM812
156 |             )
157 |             return adjustments
    |
    = help: Add trailing comma

gal_friday/dal/repositories/retraining_repository.py:64:57: COM812 [*] Trailing comma missing
   |
63 |     async def update_job_status(
64 |         self, job_id: uuid.UUID, updates: dict[str, Any]
   |                                                         ^ COM812
65 |     ) -> RetrainingJob | None:
66 |         """Update job status and results."""
   |
   = help: Add trailing comma

gal_friday/dal/repositories/retraining_repository.py:105:71: COM812 [*] Trailing comma missing
    |
103 |         """Get all retraining jobs for a model."""
104 |         return await self.find_all(
105 |             filters={"model_id": model_id}, order_by="created_at DESC"
    |                                                                       ^ COM812
106 |         )
    |
    = help: Add trailing comma

gal_friday/dal/repositories/retraining_repository.py:166:22: S608 Possible SQL injection vector through string-based query construction
    |
164 |           # date string generated internally. For user-supplied input,
165 |           # parameterization would be essential using SQLAlchemy's bindparam.
166 |           query = text(f"""
    |  ______________________^
167 | |             WITH job_stats AS (
168 | |                 SELECT
169 | |                     COUNT(*) as total_jobs,
170 | |                     COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_jobs,
171 | |                     COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_jobs,
172 | |                     COUNT(CASE WHEN status = 'running' THEN 1 END) as running_jobs,
173 | |                     AVG(EXTRACT(EPOCH FROM (end_time - start_time))) as avg_duration_seconds
174 | |                 FROM retraining_jobs
175 | |                 WHERE created_at > '{thirty_days_ago}'
176 | |             ),
177 | |             trigger_stats AS (
178 | |                 SELECT
179 | |                     trigger,
180 | |                     COUNT(*) as count
181 | |                 FROM retraining_jobs
182 | |                 WHERE created_at > '{thirty_days_ago}'
183 | |                 GROUP BY trigger
184 | |             ),
185 | |             drift_stats AS (
186 | |                 SELECT
187 | |                     drift_type,
188 | |                     COUNT(*) as detections,
189 | |                     COUNT(CASE WHEN is_significant THEN 1 END) as significant_detections
190 | |                 FROM drift_detection_events
191 | |                 WHERE detected_at > '{thirty_days_ago}'
192 | |                 GROUP BY drift_type
193 | |             )
194 | |             SELECT
195 | |                 (SELECT row_to_json(js) FROM job_stats js) as job_statistics,
196 | |                 (SELECT json_agg(ts) FROM trigger_stats ts) as trigger_distribution,
197 | |                 (SELECT json_agg(ds) FROM drift_stats ds) as drift_statistics
198 | |         """)
    | |___________^ S608
199 |
200 |           async with self.session_maker() as session:
    |

gal_friday/data_ingestion/gap_detector.py:152:52: COM812 [*] Trailing comma missing
    |
150 |             "total_duration": total_duration,
151 |             "average_duration": timedelta(
152 |                 seconds=float(avg_duration_seconds)
    |                                                    ^ COM812
153 |             ),  # Explicit float cast
154 |             "max_duration": max((g.duration for g in gaps), default=timedelta()),
    |
    = help: Add trailing comma

gal_friday/data_ingestion/gap_detector.py:258:30: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
256 |     def _detect_interval(self, timestamps: pd.Series) -> timedelta:
257 |         """Auto-detect the expected interval between timestamps."""
258 |         if len(timestamps) < 2:
    |                              ^ PLR2004
259 |             return timedelta(minutes=1)  # Default for insufficient data
    |

gal_friday/data_ingestion/gap_detector.py:298:29: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
    |
297 |         # Map to pandas frequency
298 |         if median_seconds < 60:
    |                             ^^ PLR2004
299 |             return f"{int(median_seconds)}S"
300 |         if median_seconds < 3600:
    |

gal_friday/data_ingestion/gap_detector.py:300:29: PLR2004 Magic value used in comparison, consider replacing `3600` with a constant variable
    |
298 |         if median_seconds < 60:
299 |             return f"{int(median_seconds)}S"
300 |         if median_seconds < 3600:
    |                             ^^^^ PLR2004
301 |             return f"{int(median_seconds/60)}T"
302 |         if median_seconds < 86400:
    |

gal_friday/data_ingestion/gap_detector.py:302:29: PLR2004 Magic value used in comparison, consider replacing `86400` with a constant variable
    |
300 |         if median_seconds < 3600:
301 |             return f"{int(median_seconds/60)}T"
302 |         if median_seconds < 86400:
    |                             ^^^^^ PLR2004
303 |             return f"{int(median_seconds/3600)}H"
304 |         return f"{int(median_seconds/86400)}D"
    |

gal_friday/data_ingestion/gap_detector.py:330:25: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
328 |         # If certain hours have multiple gaps
329 |         for hour, count in hour_counts.items():
330 |             if count >= 3:  # At least 3 occurrences
    |                         ^ PLR2004
331 |                 patterns.append({
332 |                     "type": "time_of_day",
    |

gal_friday/data_ingestion/gap_detector.py:346:25: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
345 |         for day, count in day_counts.items():
346 |             if count >= 2:  # At least 2 occurrences
    |                         ^ PLR2004
347 |                 patterns.append({
348 |                     "type": "day_of_week",
    |

gal_friday/data_ingestor.py:159:84: COM812 [*] Trailing comma missing
    |
157 |         self._websocket_url = data_config.get(
158 |             "kraken_ws_url",
159 |             kraken_config.get("websocket", {}).get("url", "wss://ws.kraken.com/v2")
    |                                                                                    ^ COM812
160 |         )
161 |         self._connection_timeout = data_config.get("connection_timeout_s", 15)
    |
    = help: Add trailing comma

gal_friday/data_ingestor.py:171:43: COM812 [*] Trailing comma missing
    |
169 |         self._ohlc_intervals = data_config.get("ohlc_intervals", [1, 5, 15, 60])
170 |         self._expected_ohlc_item_length = data_config.get(
171 |             "expected_ohlc_item_length", 7
    |                                           ^ COM812
172 |         )
173 |         self._min_qty_threshold = data_config.get("min_qty_threshold", 1e-12)
    |
    = help: Add trailing comma

gal_friday/data_ingestor.py:569:79: COM812 [*] Trailing comma missing
    |
567 |         self.logger.info(monitor_msg, source_module=self.__class__.__name__)
568 |         check_interval = max(
569 |             1, min(self._connection_timeout, self._max_heartbeat_interval) / 2
    |                                                                               ^ COM812
570 |         )
    |
    = help: Add trailing comma

gal_friday/data_ingestor.py:646:51: COM812 [*] Trailing comma missing
    |
644 |                     # Use create_task to avoid blocking the monitor loop
645 |                     self._cleanup_connection_task = asyncio.create_task(
646 |                         self._cleanup_connection()
    |                                                   ^ COM812
647 |                     )
648 |                 break  # Exit monitor loop, main loop will handle reconnect
    |
    = help: Add trailing comma

gal_friday/data_ingestor.py:1753:28: COM812 [*] Trailing comma missing
     |
1751 |             *args,
1752 |             source_module=source_module,
1753 |             context=context
     |                            ^ COM812
1754 |         )
     |
     = help: Add trailing comma

gal_friday/data_ingestor.py:1769:28: COM812 [*] Trailing comma missing
     |
1767 |             *args,
1768 |             source_module=source_module,
1769 |             context=context
     |                            ^ COM812
1770 |         )
     |
     = help: Add trailing comma

gal_friday/data_ingestor.py:1785:28: COM812 [*] Trailing comma missing
     |
1783 |             *args,
1784 |             source_module=source_module,
1785 |             context=context
     |                            ^ COM812
1786 |         )
     |
     = help: Add trailing comma

gal_friday/data_ingestor.py:1803:30: COM812 [*] Trailing comma missing
     |
1801 |             source_module=source_module,
1802 |             context=context,
1803 |             exc_info=exc_info
     |                              ^ COM812
1804 |         )
     |
     = help: Add trailing comma

gal_friday/data_ingestor.py:1821:30: COM812 [*] Trailing comma missing
     |
1819 |             source_module=source_module,
1820 |             context=context,
1821 |             exc_info=exc_info
     |                              ^ COM812
1822 |         )
     |
     = help: Add trailing comma

gal_friday/database.py:10:1: W293 Blank line contains whitespace
   |
 8 | def get_database_connection_string() -> str:
 9 |     """Get the database connection string.
10 |     
   | ^^^^ W293
11 |     In a real application, this would fetch from config/config.yaml.
12 |     For now, using a placeholder value.
   |
   = help: Remove whitespace from blank line

gal_friday/exceptions.py:71:35: COM812 [*] Trailing comma missing
   |
69 |         trading_pair: str | None = None,
70 |         position_id: str | None = None,
71 |         message: str | None = None
   |                                   ^ COM812
72 |     ) -> None:
73 |         """Initialize PositionNotFoundError."""
   |
   = help: Add trailing comma

gal_friday/execution/websocket_client.py:684:100: E501 Line too long (102 > 99)
    |
682 |                     interval_val_str = channel_name.split("-")[1]
683 |                 except IndexError:
684 |                     self.logger.warning(f"Could not parse interval from OHLC channel: {channel_name}")
    |                                                                                                    ^^^ E501
685 |             # Use INTERVAL_MAP to get the string representation
686 |             interval_minutes = int(interval_val_str) # Kraken uses integer minutes
    |

gal_friday/execution/websocket_client.py:778:84: COM812 Trailing comma missing
    |
776 |                 f"Could not definitively map Kraken pair: {kraken_pair} to standard format.",
777 |                 source_module=self._source_module,
778 |                 context={"original_pair": kraken_pair, "mapped_attempt": temp_pair}
    |                                                                                    ^ COM812
779 |             )
780 |         return temp_pair if "/" in temp_pair else kraken_pair
    |
    = help: Add trailing comma

gal_friday/execution/websocket_client.py:849:6: SyntaxError: Expected ',', found name
    |
847 |         )
848 |
849 | [end of gal_friday/execution/websocket_client.py]
    |      ^
    |

gal_friday/execution/websocket_client.py:849:9: SyntaxError: Expected ',', found name
    |
847 |         )
848 |
849 | [end of gal_friday/execution/websocket_client.py]
    |         ^
    |

gal_friday/execution_handler.py:8:29: TC003 Move standard library import `collections.abc.Callable` into a type-checking block
   |
 6 | import secrets
 7 | import time
 8 | from collections.abc import Callable, Coroutine
   |                             ^^^^^^^^ TC003
 9 | from dataclasses import dataclass
10 | from datetime import UTC, datetime
   |
   = help: Move into type-checking block

gal_friday/execution_handler.py:8:39: TC003 Move standard library import `collections.abc.Coroutine` into a type-checking block
   |
 6 | import secrets
 7 | import time
 8 | from collections.abc import Callable, Coroutine
   |                                       ^^^^^^^^^ TC003
 9 | from dataclasses import dataclass
10 | from datetime import UTC, datetime
   |
   = help: Move into type-checking block

gal_friday/execution_handler.py:17:39: TC001 Move application import `gal_friday.config_manager.ConfigManager` into a type-checking block
   |
15 | import aiohttp
16 |
17 | from gal_friday.config_manager import ConfigManager
   |                                       ^^^^^^^^^^^^^ TC001
18 |
19 | # Removed incorrect import: from gal_friday.core.errors import ExecutionHandlerAuthenticationError
   |
   = help: Move into type-checking block

gal_friday/execution_handler.py:26:36: TC001 Move application import `gal_friday.core.pubsub.PubSubManager` into a type-checking block
   |
24 |     TradeSignalApprovedEvent,
25 | )
26 | from gal_friday.core.pubsub import PubSubManager
   |                                    ^^^^^^^^^^^^^ TC001
27 | from gal_friday.logger_service import LoggerService
28 | from gal_friday.monitoring_service import MonitoringService
   |
   = help: Move into type-checking block

gal_friday/execution_handler.py:27:39: TC001 Move application import `gal_friday.logger_service.LoggerService` into a type-checking block
   |
25 | )
26 | from gal_friday.core.pubsub import PubSubManager
27 | from gal_friday.logger_service import LoggerService
   |                                       ^^^^^^^^^^^^^ TC001
28 | from gal_friday.monitoring_service import MonitoringService
29 | from gal_friday.utils.kraken_api import generate_kraken_signature
   |
   = help: Move into type-checking block

gal_friday/execution_handler.py:28:43: TC001 Move application import `gal_friday.monitoring_service.MonitoringService` into a type-checking block
   |
26 | from gal_friday.core.pubsub import PubSubManager
27 | from gal_friday.logger_service import LoggerService
28 | from gal_friday.monitoring_service import MonitoringService
   |                                           ^^^^^^^^^^^^^^^^^ TC001
29 | from gal_friday.utils.kraken_api import generate_kraken_signature
   |
   = help: Move into type-checking block

gal_friday/execution_handler.py:1618:1: W293 Blank line contains whitespace
     |
1616 |     ) -> TradeSignalApprovedEvent | None:
1617 |         """Retrieve the original signal event that led to an order.
1618 |         
     | ^^^^^^^^ W293
1619 |         Uses the event store to fetch historical events.
1620 |         """
     |
     = help: Remove whitespace from blank line

gal_friday/feature_engine.py:81:7: D101 Missing docstring in public class
   |
79 | # Define InternalFeatureSpec
80 | @dataclass
81 | class InternalFeatureSpec:
   |       ^^^^^^^^^^^^^^^^^^^ D101
82 |     key: str  # Unique key for the feature. Used for activation via app config and as a base for published feature names.
83 |     calculator_type: str # Defines the core calculation logic (e.g., "rsi", "macd"). Maps to a `_pipeline_compute_{calculator_type}` m
   |

gal_friday/feature_engine.py:82:100: E501 Line too long (121 > 99)
   |
80 | @dataclass
81 | class InternalFeatureSpec:
82 |     key: str  # Unique key for the feature. Used for activation via app config and as a base for published feature names.
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
83 |     calculator_type: str # Defines the core calculation logic (e.g., "rsi", "macd"). Maps to a `_pipeline_compute_{calculator_type}` m
84 |     input_type: str # Specifies the type of input data required by the calculator (e.g., 'close_series', 'ohlcv_df', 'l2_book_series').
   |

gal_friday/feature_engine.py:83:100: E501 Line too long (140 > 99)
   |
81 | 
82 | ivation via app config and as a base for published feature names.
83 | logic (e.g., "rsi", "macd"). Maps to a `_pipeline_compute_{calculator_type}` method.
   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
84 | equired by the calculator (e.g., 'close_series', 'ohlcv_df', 'l2_book_series').
85 | L # Categorizes the feature (e.g., TECHNICAL, L2_ORDER_BOOK, TRADE_DATA).
   |

gal_friday/feature_engine.py:84:100: E501 Line too long (135 > 99)
   |
82 | activation via app config and as a base for published feature names.
83 | on logic (e.g., "rsi", "macd"). Maps to a `_pipeline_compute_{calculator_type}` method.
84 | a required by the calculator (e.g., 'close_series', 'ohlcv_df', 'l2_book_series').
   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
85 | ICAL # Categorizes the feature (e.g., TECHNICAL, L2_ORDER_BOOK, TRADE_DATA).
86 | y=dict) # Dictionary of parameters passed to the feature calculator function.
   |

gal_friday/feature_engine.py:85:100: E501 Line too long (129 > 99)
   |
83 | ation logic (e.g., "rsi", "macd"). Maps to a `_pipeline_compute_{calculator_type}` method.
84 | data required by the calculator (e.g., 'close_series', 'ohlcv_df', 'l2_book_series').
85 | CHNICAL # Categorizes the feature (e.g., TECHNICAL, L2_ORDER_BOOK, TRADE_DATA).
   |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
86 | tory=dict) # Dictionary of parameters passed to the feature calculator function.
87 |  # Configuration for the output imputation step in the pipeline (e.g., `{"strategy": "constant", "fill_value": 0.0}`). Applied as a f
   |

gal_friday/feature_engine.py:86:100: E501 Line too long (130 > 99)
   |
84 | ata required by the calculator (e.g., 'close_series', 'ohlcv_df', 'l2_book_series').
85 | HNICAL # Categorizes the feature (e.g., TECHNICAL, L2_ORDER_BOOK, TRADE_DATA).
86 | ory=dict) # Dictionary of parameters passed to the feature calculator function.
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
87 | # Configuration for the output imputation step in the pipeline (e.g., `{"strategy": "constant", "fill_value": 0.0}`). Applied as a fi
88 | # Configuration for the output scaling step (e.g., `{"method": "standard"}`). Applied by FeatureEngine.
   |

gal_friday/feature_engine.py:87:100: E501 Line too long (197 > 99)
   |
85 | (e.g., TECHNICAL, L2_ORDER_BOOK, TRADE_DATA).
86 | ers passed to the feature calculator function.
87 | putation step in the pipeline (e.g., `{"strategy": "constant", "fill_value": 0.0}`). Applied as a final fallback.
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
88 | aling step (e.g., `{"method": "standard"}`). Applied by FeatureEngine.
89 | uration.
   |

gal_friday/feature_engine.py:88:100: E501 Line too long (154 > 99)
   |
86 | Dictionary of parameters passed to the feature calculator function.
87 | ion for the output imputation step in the pipeline (e.g., `{"strategy": "constant", "fill_value": 0.0}`). Applied as a final fallback.
88 | ion for the output scaling step (e.g., `{"method": "standard"}`). Applied by FeatureEngine.
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
89 | eature and its configuration.
90 |  definition, loaded from the registry.
   |

gal_friday/feature_engine.py:90:100: E501 Line too long (101 > 99)
   |
88 |     scaling: dict[str, Any] | str | None = None    # Configuration for the output scaling step (e.g., `{"method": "standard"}`). Appli
89 |     description: str = "" # Human-readable description of the feature and its configuration.
90 |     version: str | None = None # Version string for the feature definition, loaded from the registry.
   |                                                                                                    ^^ E501
91 |     output_properties: dict[str, Any] = field(default_factory=dict) # Dictionary describing expected output characteristics (e.g., `{"
92 |     # TODO: Add other fields from FeatureSpec as deemed useful, e.g. output_names for multi-output features
   |

gal_friday/feature_engine.py:91:100: E501 Line too long (175 > 99)
   |
89 |  its configuration.
90 | n, loaded from the registry.
91 | tionary describing expected output characteristics (e.g., `{"value_type": "float", "range": [0, 1]}`).
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
92 | ut_names for multi-output features
93 |  produces multiple unnamed outputs
   |

gal_friday/feature_engine.py:92:100: E501 Line too long (107 > 99)
   |
90 |     version: str | None = None # Version string for the feature definition, loaded from the registry.
91 |     output_properties: dict[str, Any] = field(default_factory=dict) # Dictionary describing expected output characteristics (e.g., `{"
92 |     # TODO: Add other fields from FeatureSpec as deemed useful, e.g. output_names for multi-output features
   |                                                                                                    ^^^^^^^^ E501
93 |     # TODO: Consider adding 'output_column_names' if a feature calculator produces multiple unnamed outputs
94 |     #       that need specific naming beyond what pandas-ta might provide.
   |

gal_friday/feature_engine.py:93:100: E501 Line too long (107 > 99)
   |
91 |     output_properties: dict[str, Any] = field(default_factory=dict) # Dictionary describing expected output characteristics (e.g., `{"
92 |     # TODO: Add other fields from FeatureSpec as deemed useful, e.g. output_names for multi-output features
93 |     # TODO: Consider adding 'output_column_names' if a feature calculator produces multiple unnamed outputs
   |                                                                                                    ^^^^^^^^ E501
94 |     #       that need specific naming beyond what pandas-ta might provide.
   |

gal_friday/feature_engine.py:100:1: W293 Blank line contains whitespace
    |
 98 | class PandasScalerTransformer:
 99 |     """A wrapper around sklearn scalers that preserves pandas Series/DataFrame structure.
100 |     
    | ^^^^ W293
101 |     This transformer wraps any sklearn scaler (StandardScaler, MinMaxScaler, etc.)
102 |     and ensures that the output maintains the same pandas structure as the input,
    |
    = help: Remove whitespace from blank line

gal_friday/feature_engine.py:106:32: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `scaler`
    |
104 |     """
105 |
106 |     def __init__(self, scaler: Any) -> None:
    |                                ^^^ ANN401
107 |         """Initialize with an sklearn scaler instance."""
108 |         self.scaler = scaler
    |

gal_friday/feature_engine.py:112:19: N803 Argument name `X` should be lowercase
    |
110 |         self._index: Any = None
111 |
112 |     def fit(self, X: Any, y: Any = None) -> PandasScalerTransformer:
    |                   ^^^^^^ N803
113 |         """Fit the scaler and store structure information."""
114 |         if isinstance(X, pd.DataFrame):
    |

gal_friday/feature_engine.py:112:22: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `X`
    |
110 |         self._index: Any = None
111 |
112 |     def fit(self, X: Any, y: Any = None) -> PandasScalerTransformer:
    |                      ^^^ ANN401
113 |         """Fit the scaler and store structure information."""
114 |         if isinstance(X, pd.DataFrame):
    |

gal_friday/feature_engine.py:112:30: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `y`
    |
110 |         self._index: Any = None
111 |
112 |     def fit(self, X: Any, y: Any = None) -> PandasScalerTransformer:
    |                              ^^^ ANN401
113 |         """Fit the scaler and store structure information."""
114 |         if isinstance(X, pd.DataFrame):
    |

gal_friday/feature_engine.py:126:25: N803 Argument name `X` should be lowercase
    |
124 |         return self
125 |
126 |     def transform(self, X: Any) -> Any:
    |                         ^^^^^^ N803
127 |         """Transform the data and restore pandas structure."""
128 |         if isinstance(X, pd.DataFrame):
    |

gal_friday/feature_engine.py:126:28: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `X`
    |
124 |         return self
125 |
126 |     def transform(self, X: Any) -> Any:
    |                            ^^^ ANN401
127 |         """Transform the data and restore pandas structure."""
128 |         if isinstance(X, pd.DataFrame):
    |

gal_friday/feature_engine.py:126:36: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `transform`
    |
124 |         return self
125 |
126 |     def transform(self, X: Any) -> Any:
    |                                    ^^^ ANN401
127 |         """Transform the data and restore pandas structure."""
128 |         if isinstance(X, pd.DataFrame):
    |

gal_friday/feature_engine.py:130:100: E501 Line too long (101 > 99)
    |
128 |         if isinstance(X, pd.DataFrame):
129 |             transformed = self.scaler.transform(X.values)
130 |             return pd.DataFrame(transformed, columns=self._feature_names or X.columns, index=X.index)
    |                                                                                                    ^^ E501
131 |         if isinstance(X, pd.Series):
132 |             transformed = self.scaler.transform(X.values.reshape(-1, 1))
    |

gal_friday/feature_engine.py:133:100: E501 Line too long (102 > 99)
    |
131 |         if isinstance(X, pd.Series):
132 |             transformed = self.scaler.transform(X.values.reshape(-1, 1))
133 |             return pd.Series(transformed.flatten(), name=self._feature_names or X.name, index=X.index)
    |                                                                                                    ^^^ E501
134 |         return self.scaler.transform(X)
    |

gal_friday/feature_engine.py:136:29: N803 Argument name `X` should be lowercase
    |
134 |         return self.scaler.transform(X)
135 |
136 |     def fit_transform(self, X: Any, y: Any = None) -> Any:
    |                             ^^^^^^ N803
137 |         """Fit and transform in one step."""
138 |         self.fit(X, y)
    |

gal_friday/feature_engine.py:136:32: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `X`
    |
134 |         return self.scaler.transform(X)
135 |
136 |     def fit_transform(self, X: Any, y: Any = None) -> Any:
    |                                ^^^ ANN401
137 |         """Fit and transform in one step."""
138 |         self.fit(X, y)
    |

gal_friday/feature_engine.py:136:40: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `y`
    |
134 |         return self.scaler.transform(X)
135 |
136 |     def fit_transform(self, X: Any, y: Any = None) -> Any:
    |                                        ^^^ ANN401
137 |         """Fit and transform in one step."""
138 |         self.fit(X, y)
    |

gal_friday/feature_engine.py:136:55: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `fit_transform`
    |
134 |         return self.scaler.transform(X)
135 |
136 |     def fit_transform(self, X: Any, y: Any = None) -> Any:
    |                                                       ^^^ ANN401
137 |         """Fit and transform in one step."""
138 |         self.fit(X, y)
    |

gal_friday/feature_engine.py:262:100: E501 Line too long (123 > 99)
    |
260 |         )
261 |
262 |         self.feature_pipelines: dict[str, dict[str, Any]] = {} # Stores {'pipeline': Pipeline, 'spec': InternalFeatureSpec}
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
263 |         self._build_feature_pipelines()
    |

gal_friday/feature_engine.py:267:9: PLR0911 Too many return statements (15 > 6)
    |
265 |         self.logger.info("FeatureEngine initialized.", source_module=self._source_module)
266 |
267 |     def _determine_calculator_type_and_input(self, feature_key: str, raw_cfg: dict) -> tuple[str | None, str | None]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
268 |         """Determines calculator type and input type from feature key and raw config.
    |

gal_friday/feature_engine.py:267:9: PLR0912 Too many branches (14 > 12)
    |
265 |         self.logger.info("FeatureEngine initialized.", source_module=self._source_module)
266 |
267 |     def _determine_calculator_type_and_input(self, feature_key: str, raw_cfg: dict) -> tuple[str | None, str | None]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
268 |         """Determines calculator type and input type from feature key and raw config.
    |

gal_friday/feature_engine.py:267:100: E501 Line too long (117 > 99)
    |
265 |         self.logger.info("FeatureEngine initialized.", source_module=self._source_module)
266 |
267 |     def _determine_calculator_type_and_input(self, feature_key: str, raw_cfg: dict) -> tuple[str | None, str | None]:
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
268 |         """Determines calculator type and input type from feature key and raw config.
    |

gal_friday/feature_engine.py:295:30: E701 Multiple statements on one line (colon)
    |
293 |         # Infer from key if not explicitly provided
294 |         key_lower = feature_key.lower()
295 |         if "rsi" in key_lower: return "rsi", "close_series"
    |                              ^ E701
296 |         if "macd" in key_lower: return "macd", "close_series"
297 |         if "bbands" in key_lower: return "bbands", "close_series"
    |

gal_friday/feature_engine.py:296:31: E701 Multiple statements on one line (colon)
    |
294 |         key_lower = feature_key.lower()
295 |         if "rsi" in key_lower: return "rsi", "close_series"
296 |         if "macd" in key_lower: return "macd", "close_series"
    |                               ^ E701
297 |         if "bbands" in key_lower: return "bbands", "close_series"
298 |         if "roc" in key_lower: return "roc", "close_series"
    |

gal_friday/feature_engine.py:297:33: E701 Multiple statements on one line (colon)
    |
295 |         if "rsi" in key_lower: return "rsi", "close_series"
296 |         if "macd" in key_lower: return "macd", "close_series"
297 |         if "bbands" in key_lower: return "bbands", "close_series"
    |                                 ^ E701
298 |         if "roc" in key_lower: return "roc", "close_series"
299 |         if "atr" in key_lower: return "atr", "ohlcv_df"
    |

gal_friday/feature_engine.py:298:30: E701 Multiple statements on one line (colon)
    |
296 |         if "macd" in key_lower: return "macd", "close_series"
297 |         if "bbands" in key_lower: return "bbands", "close_series"
298 |         if "roc" in key_lower: return "roc", "close_series"
    |                              ^ E701
299 |         if "atr" in key_lower: return "atr", "ohlcv_df"
300 |         if "stdev" in key_lower: return "stdev", "close_series"
    |

gal_friday/feature_engine.py:299:30: E701 Multiple statements on one line (colon)
    |
297 |         if "bbands" in key_lower: return "bbands", "close_series"
298 |         if "roc" in key_lower: return "roc", "close_series"
299 |         if "atr" in key_lower: return "atr", "ohlcv_df"
    |                              ^ E701
300 |         if "stdev" in key_lower: return "stdev", "close_series"
301 |         if "vwap_ohlcv" in key_lower: return "vwap_ohlcv", "ohlcv_df"
    |

gal_friday/feature_engine.py:300:32: E701 Multiple statements on one line (colon)
    |
298 |         if "roc" in key_lower: return "roc", "close_series"
299 |         if "atr" in key_lower: return "atr", "ohlcv_df"
300 |         if "stdev" in key_lower: return "stdev", "close_series"
    |                                ^ E701
301 |         if "vwap_ohlcv" in key_lower: return "vwap_ohlcv", "ohlcv_df"
302 |         if "l2_spread" in key_lower: return "l2_spread", "l2_book_series"
    |

gal_friday/feature_engine.py:301:37: E701 Multiple statements on one line (colon)
    |
299 |         if "atr" in key_lower: return "atr", "ohlcv_df"
300 |         if "stdev" in key_lower: return "stdev", "close_series"
301 |         if "vwap_ohlcv" in key_lower: return "vwap_ohlcv", "ohlcv_df"
    |                                     ^ E701
302 |         if "l2_spread" in key_lower: return "l2_spread", "l2_book_series"
303 |         if "l2_imbalance" in key_lower: return "l2_imbalance", "l2_book_series"
    |

gal_friday/feature_engine.py:302:36: E701 Multiple statements on one line (colon)
    |
300 |         if "stdev" in key_lower: return "stdev", "close_series"
301 |         if "vwap_ohlcv" in key_lower: return "vwap_ohlcv", "ohlcv_df"
302 |         if "l2_spread" in key_lower: return "l2_spread", "l2_book_series"
    |                                    ^ E701
303 |         if "l2_imbalance" in key_lower: return "l2_imbalance", "l2_book_series"
304 |         if "l2_wap" in key_lower: return "l2_wap", "l2_book_series"
    |

gal_friday/feature_engine.py:303:39: E701 Multiple statements on one line (colon)
    |
301 |         if "vwap_ohlcv" in key_lower: return "vwap_ohlcv", "ohlcv_df"
302 |         if "l2_spread" in key_lower: return "l2_spread", "l2_book_series"
303 |         if "l2_imbalance" in key_lower: return "l2_imbalance", "l2_book_series"
    |                                       ^ E701
304 |         if "l2_wap" in key_lower: return "l2_wap", "l2_book_series"
305 |         if "l2_depth" in key_lower: return "l2_depth", "l2_book_series"
    |

gal_friday/feature_engine.py:304:33: E701 Multiple statements on one line (colon)
    |
302 |         if "l2_spread" in key_lower: return "l2_spread", "l2_book_series"
303 |         if "l2_imbalance" in key_lower: return "l2_imbalance", "l2_book_series"
304 |         if "l2_wap" in key_lower: return "l2_wap", "l2_book_series"
    |                                 ^ E701
305 |         if "l2_depth" in key_lower: return "l2_depth", "l2_book_series"
306 |         if "vwap_trades" in key_lower: return "vwap_trades", "trades_and_bar_starts"
    |

gal_friday/feature_engine.py:305:35: E701 Multiple statements on one line (colon)
    |
303 |         if "l2_imbalance" in key_lower: return "l2_imbalance", "l2_book_series"
304 |         if "l2_wap" in key_lower: return "l2_wap", "l2_book_series"
305 |         if "l2_depth" in key_lower: return "l2_depth", "l2_book_series"
    |                                   ^ E701
306 |         if "vwap_trades" in key_lower: return "vwap_trades", "trades_and_bar_starts"
307 |         if "volume_delta" in key_lower: return "volume_delta", "trades_and_bar_starts"
    |

gal_friday/feature_engine.py:306:38: E701 Multiple statements on one line (colon)
    |
304 |         if "l2_wap" in key_lower: return "l2_wap", "l2_book_series"
305 |         if "l2_depth" in key_lower: return "l2_depth", "l2_book_series"
306 |         if "vwap_trades" in key_lower: return "vwap_trades", "trades_and_bar_starts"
    |                                      ^ E701
307 |         if "volume_delta" in key_lower: return "volume_delta", "trades_and_bar_starts"
    |

gal_friday/feature_engine.py:307:39: E701 Multiple statements on one line (colon)
    |
305 |         if "l2_depth" in key_lower: return "l2_depth", "l2_book_series"
306 |         if "vwap_trades" in key_lower: return "vwap_trades", "trades_and_bar_starts"
307 |         if "volume_delta" in key_lower: return "volume_delta", "trades_and_bar_starts"
    |                                       ^ E701
308 |
309 |         self.logger.warning("Could not determine calculator_type or input_type for feature key: %s", feature_key)
    |

gal_friday/feature_engine.py:309:100: E501 Line too long (113 > 99)
    |
307 |         if "volume_delta" in key_lower: return "volume_delta", "trades_and_bar_starts"
308 |
309 |         self.logger.warning("Could not determine calculator_type or input_type for feature key: %s", feature_key)
    |                                                                                                    ^^^^^^^^^^^^^^ E501
310 |         return None, None
    |

gal_friday/feature_engine.py:313:9: C901 `_extract_feature_configs` is too complex (22 > 15)
    |
313 |     def _extract_feature_configs(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ C901
314 |         """Initializes `self._feature_configs` by loading feature definitions.
    |

gal_friday/feature_engine.py:313:9: PLR0912 Too many branches (23 > 12)
    |
313 |     def _extract_feature_configs(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
314 |         """Initializes `self._feature_configs` by loading feature definitions.
    |

gal_friday/feature_engine.py:313:9: PLR0915 Too many statements (69 > 50)
    |
313 |     def _extract_feature_configs(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ PLR0915
314 |         """Initializes `self._feature_configs` by loading feature definitions.
    |

gal_friday/feature_engine.py:362:100: E501 Line too long (102 > 99)
    |
360 |                 continue
361 |
362 |             calculator_type, input_type = self._determine_calculator_type_and_input(key, raw_cfg_dict)
    |                                                                                                    ^^^ E501
363 |             if not calculator_type or not input_type:
364 |                 self.logger.warning("Skipping feature %s due to undetermined type/input.", key)
    |

gal_friday/feature_engine.py:372:100: E501 Line too long (146 > 99)
    |
370 | _cfg_dict.get("params", {}))
371 | e top-level, merge them in:
372 | ast", "slow", "signal", "levels", "std_dev", "length_seconds", "bar_interval_seconds"]:
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
373 | mon_param_key not in parameters:
374 | dict[common_param_key]
    |

gal_friday/feature_engine.py:379:100: E501 Line too long (102 > 99)
    |
377 |             imputation_cfg = raw_cfg_dict.get("imputation")
378 |             scaling_cfg = raw_cfg_dict.get("scaling")
379 |             description = raw_cfg_dict.get("description", f"{calculator_type} feature based on {key}")
    |                                                                                                    ^^^ E501
380 |
381 |             category_str = raw_cfg_dict.get("category", "TECHNICAL").upper()
    |

gal_friday/feature_engine.py:402:100: E501 Line too long (101 > 99)
    |
400 |             parsed_specs[key] = spec_val
401 |
402 |         # self._feature_configs = parsed_specs # Old logic replaced by new registry-based logic below
    |                                                                                                    ^^ E501
403 |
404 |         registry_definitions = self._load_feature_registry(DEFAULT_FEATURE_REGISTRY_PATH)
    |

gal_friday/feature_engine.py:405:100: E501 Line too long (104 > 99)
    |
404 |         registry_definitions = self._load_feature_registry(DEFAULT_FEATURE_REGISTRY_PATH)
405 |         app_feature_config = self.config.get("features", {}) # This is the app-level config for features
    |                                                                                                    ^^^^^ E501
406 |
407 |         final_parsed_specs: dict[str, InternalFeatureSpec] = {}
    |

gal_friday/feature_engine.py:412:100: E501 Line too long (111 > 99)
    |
410 |             for key in app_feature_config:
411 |                 if not isinstance(key, str):
412 |                     self.logger.warning("Feature activation list contains non-string item: %s. Skipping.", key)
    |                                                                                                    ^^^^^^^^^^^^ E501
413 |                     continue
414 |                 if key not in registry_definitions:
    |

gal_friday/feature_engine.py:415:100: E501 Line too long (113 > 99)
    |
413 |                     continue
414 |                 if key not in registry_definitions:
415 |                     self.logger.warning("Feature key '%s' from app config not found in registry. Skipping.", key)
    |                                                                                                    ^^^^^^^^^^^^^^ E501
416 |                     continue
    |

gal_friday/feature_engine.py:420:100: E501 Line too long (107 > 99)
    |
418 |                 feature_def_from_registry = registry_definitions[key]
419 |                 if not isinstance(feature_def_from_registry, dict):
420 |                     self.logger.warning("Registry definition for '%s' is not a dictionary. Skipping.", key)
    |                                                                                                    ^^^^^^^^ E501
421 |                     continue
    |

gal_friday/feature_engine.py:423:100: E501 Line too long (106 > 99)
    |
421 |                     continue
422 |
423 |                 spec_result = self._parse_single_feature_definition(key, feature_def_from_registry.copy())
    |                                                                                                    ^^^^^^^ E501
424 |                 if spec_result is not None:
425 |                     final_parsed_specs[key] = spec_result
    |

gal_friday/feature_engine.py:427:100: E501 Line too long (107 > 99)
    |
425 |                     final_parsed_specs[key] = spec_result
426 |
427 |         elif isinstance(app_feature_config, dict): # Case 2: Dict of feature names with overrides or ad-hoc
    |                                                                                                    ^^^^^^^^ E501
428 |             for key, overrides_or_activation in app_feature_config.items():
429 |                 if not isinstance(overrides_or_activation, dict):
    |

gal_friday/feature_engine.py:430:100: E501 Line too long (116 > 99)
    |
428 |             for key, overrides_or_activation in app_feature_config.items():
429 |                 if not isinstance(overrides_or_activation, dict):
430 |                     self.logger.warning("Override/activation config for feature '%s' is not a dict. Skipping.", key)
    |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
431 |                     continue
    |

gal_friday/feature_engine.py:438:100: E501 Line too long (120 > 99)
    |
436 |                 if base_config: # Key found in registry, apply overrides
437 |                     if not isinstance(base_config, dict):
438 |                         self.logger.warning("Registry definition for '%s' is not a dictionary. Skipping override.", key)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^ E501
439 |                         continue
440 |                     final_config_dict = self._deep_merge_configs(base_config.copy(), overrides_or_activation)
    |

gal_friday/feature_engine.py:440:100: E501 Line too long (109 > 99)
    |
438 |                         self.logger.warning("Registry definition for '%s' is not a dictionary. Skipping override.", key)
439 |                         continue
440 |                     final_config_dict = self._deep_merge_configs(base_config.copy(), overrides_or_activation)
    |                                                                                                    ^^^^^^^^^^ E501
441 |                 else: # Key not in registry - treat as ad-hoc definition
442 |                     self.logger.info("Feature '%s' not found in registry, treating as ad-hoc definition from app config.", key)
    |

gal_friday/feature_engine.py:442:100: E501 Line too long (127 > 99)
    |
440 |                     final_config_dict = self._deep_merge_configs(base_config.copy(), overrides_or_activation)
441 |                 else: # Key not in registry - treat as ad-hoc definition
442 |                     self.logger.info("Feature '%s' not found in registry, treating as ad-hoc definition from app config.", key)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
443 |                     final_config_dict = overrides_or_activation.copy()
444 |                     # Ad-hoc definitions must provide all necessary fields like calculator_type, input_type
    |

gal_friday/feature_engine.py:444:100: E501 Line too long (107 > 99)
    |
442 |                     self.logger.info("Feature '%s' not found in registry, treating as ad-hoc definition from app config.", key)
443 |                     final_config_dict = overrides_or_activation.copy()
444 |                     # Ad-hoc definitions must provide all necessary fields like calculator_type, input_type
    |                                                                                                    ^^^^^^^^ E501
445 |                     if "calculator_type" not in final_config_dict or "input_type" not in final_config_dict:
446 |                         self.logger.warning("Ad-hoc feature '%s' missing 'calculator_type' or 'input_type'. Skipping.", key)
    |

gal_friday/feature_engine.py:445:100: E501 Line too long (107 > 99)
    |
443 |                     final_config_dict = overrides_or_activation.copy()
444 |                     # Ad-hoc definitions must provide all necessary fields like calculator_type, input_type
445 |                     if "calculator_type" not in final_config_dict or "input_type" not in final_config_dict:
    |                                                                                                    ^^^^^^^^ E501
446 |                         self.logger.warning("Ad-hoc feature '%s' missing 'calculator_type' or 'input_type'. Skipping.", key)
447 |                         continue
    |

gal_friday/feature_engine.py:446:100: E501 Line too long (124 > 99)
    |
444 |                     # Ad-hoc definitions must provide all necessary fields like calculator_type, input_type
445 |                     if "calculator_type" not in final_config_dict or "input_type" not in final_config_dict:
446 |                         self.logger.warning("Ad-hoc feature '%s' missing 'calculator_type' or 'input_type'. Skipping.", key)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
447 |                         continue
    |

gal_friday/feature_engine.py:454:100: E501 Line too long (136 > 99)
    |
453 | 
454 | config is neither a list nor a dict. No features will be configured based on it.")
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
455 | 
456 | 
    |

gal_friday/feature_engine.py:458:100: E501 Line too long (131 > 99)
    |
456 |         self._feature_configs = final_parsed_specs
457 |         if not self._feature_configs:
458 |             self.logger.warning("No features were successfully parsed or activated. FeatureEngine might not produce any features.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
    |

gal_friday/feature_engine.py:462:9: D205 1 blank line required between summary line and description
    |
461 |       def _deep_merge_configs(self, base: dict, override: dict) -> dict:
462 | /         """Deeply merges override dict into base dict.
463 | |         Recursively merges the `override` dictionary into the `base` dictionary.
464 | |
465 | |         For keys present in both `base` and `override`:
466 | |         - If both values are dictionaries, they are merged recursively.
467 | |         - Otherwise, the value from `override` takes precedence.
468 | |         Keys present only in `override` are added to the merged dictionary.
469 | |
470 | |         Args:
471 | |             base: The base configuration dictionary (e.g., from the feature registry).
472 | |             override: The dictionary with override values (e.g., from application config).
473 | |
474 | |         Returns:
475 | |             A new dictionary representing the deeply merged configuration.
476 | |         """
    | |___________^ D205
477 |           merged = base.copy()
478 |           for key, value in override.items():
    |
    = help: Insert single blank line

gal_friday/feature_engine.py:485:100: E501 Line too long (114 > 99)
    |
483 |         return merged
484 |
485 |     def _parse_single_feature_definition(self, feature_key: str, config_dict: dict) -> InternalFeatureSpec | None:
    |                                                                                                    ^^^^^^^^^^^^^^^ E501
486 |         """Parses a single, consolidated feature configuration dictionary into an
487 |         `InternalFeatureSpec` data object.
    |

gal_friday/feature_engine.py:486:9: D205 1 blank line required between summary line and description
    |
485 |       def _parse_single_feature_definition(self, feature_key: str, config_dict: dict) -> InternalFeatureSpec | None:
486 | /         """Parses a single, consolidated feature configuration dictionary into an
487 | |         `InternalFeatureSpec` data object.
488 | |
489 | |         This method is responsible for taking the final configuration dictionary for a
490 | |         feature (which may have resulted from merging registry definitions with
491 | |         application-level overrides, or could be an ad-hoc definition) and
492 | |         translating it into a structured `InternalFeatureSpec`.
493 | |
494 | |         It performs the following steps:
495 | |         1.  Determines `calculator_type` and `input_type`:
496 | |             - Prefers explicitly defined values in `config_dict`.
497 | |             - Falls back to inferring them using `_determine_calculator_type_and_input`
498 | |               if not explicit (useful for concise ad-hoc definitions).
499 | |         2.  Extracts `parameters`, ensuring it's a dictionary and merging any top-level
500 | |             common parameter keys (like 'period', 'length') into it if they are not
501 | |             already present under the `parameters` key itself.
502 | |         3.  Extracts `imputation`, `scaling`, `description`, `version`, and
503 | |             `output_properties` from `config_dict`, applying defaults where necessary.
504 | |         4.  Parses the `category` string into a `FeatureCategory` enum member.
505 | |         5.  Instantiates and returns the `InternalFeatureSpec`.
506 | |
507 | |         Args:
508 | |             feature_key: The unique key for the feature (used for logging and as `spec.key`).
509 | |             config_dict: The complete configuration dictionary for this single feature.
510 | |
511 | |         Returns:
512 | |             An `InternalFeatureSpec` instance if parsing is successful and essential
513 | |             fields like `calculator_type` and `input_type` can be determined.
514 | |             Returns `None` if critical information is missing, with errors logged.
515 | |         """
    | |___________^ D205
516 |           # calculator_type and input_type can be inferred if not explicit (legacy/ad-hoc)
517 |           # For registry-defined features, these should ideally be explicit.
    |
    = help: Insert single blank line

gal_friday/feature_engine.py:523:100: E501 Line too long (121 > 99)
    |
521 |         if not calculator_type or not input_type:
522 |             # Try to infer if they are missing (e.g. for ad-hoc definitions)
523 |             inferred_calc_type, inferred_input_type = self._determine_calculator_type_and_input(feature_key, config_dict)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
524 |             if not calculator_type: calculator_type = inferred_calc_type
525 |             if not input_type: input_type = inferred_input_type
    |

gal_friday/feature_engine.py:524:35: E701 Multiple statements on one line (colon)
    |
522 |             # Try to infer if they are missing (e.g. for ad-hoc definitions)
523 |             inferred_calc_type, inferred_input_type = self._determine_calculator_type_and_input(feature_key, config_dict)
524 |             if not calculator_type: calculator_type = inferred_calc_type
    |                                   ^ E701
525 |             if not input_type: input_type = inferred_input_type
    |

gal_friday/feature_engine.py:525:30: E701 Multiple statements on one line (colon)
    |
523 |             inferred_calc_type, inferred_input_type = self._determine_calculator_type_and_input(feature_key, config_dict)
524 |             if not calculator_type: calculator_type = inferred_calc_type
525 |             if not input_type: input_type = inferred_input_type
    |                              ^ E701
526 |
527 |             if not calculator_type or not input_type:
    |

gal_friday/feature_engine.py:529:100: E501 Line too long (121 > 99)
    |
527 |             if not calculator_type or not input_type:
528 |                 self.logger.warning(
529 |                     "Could not determine calculator_type or input_type for feature '%s' even after inference. Skipping.",
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
530 |                     feature_key,
531 |                 )
    |

gal_friday/feature_engine.py:536:44: E701 Multiple statements on one line (colon)
    |
534 |         parameters = config_dict.get("parameters", config_dict.get("params", {}))
535 |         # Ensure parameters is a dict, even if it was null/None in YAML
536 |         if not isinstance(parameters, dict): parameters = {}
    |                                            ^ E701
537 |
538 |         # Merge top-level common param keys if they exist and aren't already in 'parameters'
    |

gal_friday/feature_engine.py:539:100: E501 Line too long (142 > 99)
    |
538 |  and aren't already in 'parameters'
539 | t", "slow", "signal", "levels", "std_dev", "length_seconds", "bar_interval_seconds"]:
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
540 | _param_key not in parameters:
541 | t[common_param_key]
    |

gal_friday/feature_engine.py:545:100: E501 Line too long (105 > 99)
    |
543 |         imputation_cfg = config_dict.get("imputation")
544 |         scaling_cfg = config_dict.get("scaling")
545 |         description = config_dict.get("description", f"{calculator_type} feature based on {feature_key}")
    |                                                                                                    ^^^^^^ E501
546 |         version = config_dict.get("version")
547 |         output_properties = config_dict.get("output_properties", {})
    |

gal_friday/feature_engine.py:549:100: E501 Line too long (107 > 99)
    |
547 |         output_properties = config_dict.get("output_properties", {})
548 |
549 |         category_str = str(config_dict.get("category", "TECHNICAL")).upper() # Ensure string before upper()
    |                                                                                                    ^^^^^^^^ E501
550 |         try:
551 |             category = FeatureCategory[category_str]
    |

gal_friday/feature_engine.py:598:100: E501 Line too long (100 > 99)
    |
596 |             return {}
597 |         except Exception as e:
598 |             self.logger.exception(f"Unexpected error loading feature registry {registry_path}: {e}")
    |                                                                                                    ^ E501
599 |             return {}
    |

gal_friday/feature_engine.py:605:100: E501 Line too long (111 > 99)
    |
603 |             return {}
604 |
605 |         self.logger.info(f"Successfully loaded {len(registry_data)} feature definitions from {registry_path}.")
    |                                                                                                    ^^^^^^^^^^^^ E501
606 |         return registry_data
    |

gal_friday/feature_engine.py:608:9: C901 `_build_feature_pipelines` is too complex (43 > 15)
    |
606 |         return registry_data
607 |
608 |     def _build_feature_pipelines(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ C901
609 |         """Constructs Scikit-learn pipelines for each feature defined in `self._feature_configs`.
    |

gal_friday/feature_engine.py:608:9: PLR0912 Too many branches (25 > 12)
    |
606 |         return registry_data
607 |
608 |     def _build_feature_pipelines(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
609 |         """Constructs Scikit-learn pipelines for each feature defined in `self._feature_configs`.
    |

gal_friday/feature_engine.py:608:9: PLR0915 Too many statements (121 > 50)
    |
606 |         return registry_data
607 |
608 |     def _build_feature_pipelines(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ PLR0915
609 |         """Constructs Scikit-learn pipelines for each feature defined in `self._feature_configs`.
    |

gal_friday/feature_engine.py:634:13: D205 1 blank line required between summary line and description
    |
632 |                                       is_dataframe_output: bool = False,
633 |                                       spec_key: str = "") -> tuple[str, FunctionTransformer] | None:
634 | /             """Creates a Scikit-learn compatible imputation step based on configuration.
635 | |             Handles Series and DataFrame outputs from feature calculators.
636 | |             """
    | |_______________^ D205
637 |               if imputation_cfg == "passthrough":
638 |                   self.logger.debug("Imputation set to 'passthrough' for %s.", spec_key)
    |
    = help: Insert single blank line

gal_friday/feature_engine.py:651:100: E501 Line too long (125 > 99)
    |
649 |                  pass # strategy remains 'default' -> use default_fill_value
650 |             else: # Invalid config, treat as passthrough or log warning
651 |                 self.logger.warning("Unrecognized imputation config for %s: %s. No imputer added.", spec_key, imputation_cfg)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
652 |                 return None
    |

gal_friday/feature_engine.py:659:17: E731 Do not assign a `lambda` expression, use a `def`
    |
657 |             if strategy == "constant":
658 |                 step_name_suffix = f"const_{fill_value}"
659 |                 transform_func = lambda x: x.fillna(fill_value)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E731
660 |             elif strategy == "mean":
661 |                 step_name_suffix = "mean"
    |
    = help: Rewrite `transform_func` as a `def`

gal_friday/feature_engine.py:662:17: E731 Do not assign a `lambda` expression, use a `def`
    |
660 |             elif strategy == "mean":
661 |                 step_name_suffix = "mean"
662 |                 transform_func = lambda x: x.fillna(x.mean())
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E731
663 |             elif strategy == "median":
664 |                 step_name_suffix = "median"
    |
    = help: Rewrite `transform_func` as a `def`

gal_friday/feature_engine.py:665:17: E731 Do not assign a `lambda` expression, use a `def`
    |
663 |             elif strategy == "median":
664 |                 step_name_suffix = "median"
665 |                 transform_func = lambda x: x.fillna(x.median())
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E731
666 |             elif strategy == "default": # Use the passed default_fill_value
667 |                 step_name_suffix = f"default_fill_{default_fill_value}"
    |
    = help: Rewrite `transform_func` as a `def`

gal_friday/feature_engine.py:668:17: E731 Do not assign a `lambda` expression, use a `def`
    |
666 |             elif strategy == "default": # Use the passed default_fill_value
667 |                 step_name_suffix = f"default_fill_{default_fill_value}"
668 |                 transform_func = lambda x: x.fillna(default_fill_value)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E731
669 |             else: # Should not be reached if checks are exhaustive
670 |                 self.logger.warning("Unknown imputation strategy '%s' for %s. No imputer added.", strategy, spec_key)
    |
    = help: Rewrite `transform_func` as a `def`

gal_friday/feature_engine.py:670:100: E501 Line too long (117 > 99)
    |
668 |                 transform_func = lambda x: x.fillna(default_fill_value)
669 |             else: # Should not be reached if checks are exhaustive
670 |                 self.logger.warning("Unknown imputation strategy '%s' for %s. No imputer added.", strategy, spec_key)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
671 |                 return None
    |

gal_friday/feature_engine.py:673:100: E501 Line too long (222 > 99)
    |
671 | 
672 | 
673 |  if strategy != "default" else f"default_fill({default_fill_value})", fill_value if strategy == "constant" else "N/A", spec_key)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
674 | form_func, validate=False))
    |

gal_friday/feature_engine.py:674:100: E501 Line too long (121 > 99)
    |
673 |      self.logger.debug("Using output imputer strategy '%s' (fill: %s) for %s", strategy if strategy != "default" else f"default_fill
674 |      return (f"{spec_key}_output_imputer_{step_name_suffix}", FunctionTransformer(transform_func, validate=False))
    |                                                                                              ^^^^^^^^^^^^^^^^^^^^^^ E501
    |

gal_friday/feature_engine.py:679:100: E501 Line too long (101 > 99)
    |
677 |         # Helper for output scaler step
678 |         def get_output_scaler_step(scaling_cfg: dict[str, Any] | str | None,
679 |                                    spec_key: str = "") -> tuple[str, PandasScalerTransformer] | None:
    |                                                                                                    ^^ E501
680 |             """Creates a Scikit-learn compatible scaling step based on the feature's `scaling` configuration.
681 |             This step is managed by the FeatureEngine to make features ready for consumption,
    |

gal_friday/feature_engine.py:680:13: D205 1 blank line required between summary line and description
    |
678 |           def get_output_scaler_step(scaling_cfg: dict[str, Any] | str | None,
679 |                                      spec_key: str = "") -> tuple[str, PandasScalerTransformer] | None:
680 | /             """Creates a Scikit-learn compatible scaling step based on the feature's `scaling` configuration.
681 | |             This step is managed by the FeatureEngine to make features ready for consumption,
682 | |             potentially by models that expect scaled data.
683 | |             Uses PandasScalerTransformer to preserve pandas Series/DataFrame structure.
684 | |             """
    | |_______________^ D205
685 |               if scaling_cfg == "passthrough" or scaling_cfg is None:
686 |                   if scaling_cfg == "passthrough": self.logger.debug("Scaling set to 'passthrough' for %s.", spec_key)
    |
    = help: Insert single blank line

gal_friday/feature_engine.py:680:100: E501 Line too long (109 > 99)
    |
678 |         def get_output_scaler_step(scaling_cfg: dict[str, Any] | str | None,
679 |                                    spec_key: str = "") -> tuple[str, PandasScalerTransformer] | None:
680 |             """Creates a Scikit-learn compatible scaling step based on the feature's `scaling` configuration.
    |                                                                                                    ^^^^^^^^^^ E501
681 |             This step is managed by the FeatureEngine to make features ready for consumption,
682 |             potentially by models that expect scaled data.
    |

gal_friday/feature_engine.py:686:48: E701 Multiple statements on one line (colon)
    |
684 |             """
685 |             if scaling_cfg == "passthrough" or scaling_cfg is None:
686 |                 if scaling_cfg == "passthrough": self.logger.debug("Scaling set to 'passthrough' for %s.", spec_key)
    |                                                ^ E701
687 |                 else: self.logger.debug("No scaling configured or default 'None' for %s.", spec_key)
688 |                 return None
    |

gal_friday/feature_engine.py:686:100: E501 Line too long (116 > 99)
    |
684 |             """
685 |             if scaling_cfg == "passthrough" or scaling_cfg is None:
686 |                 if scaling_cfg == "passthrough": self.logger.debug("Scaling set to 'passthrough' for %s.", spec_key)
    |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
687 |                 else: self.logger.debug("No scaling configured or default 'None' for %s.", spec_key)
688 |                 return None
    |

gal_friday/feature_engine.py:687:21: E701 Multiple statements on one line (colon)
    |
685 |             if scaling_cfg == "passthrough" or scaling_cfg is None:
686 |                 if scaling_cfg == "passthrough": self.logger.debug("Scaling set to 'passthrough' for %s.", spec_key)
687 |                 else: self.logger.debug("No scaling configured or default 'None' for %s.", spec_key)
    |                     ^ E701
688 |                 return None
    |

gal_friday/feature_engine.py:687:100: E501 Line too long (100 > 99)
    |
685 |             if scaling_cfg == "passthrough" or scaling_cfg is None:
686 |                 if scaling_cfg == "passthrough": self.logger.debug("Scaling set to 'passthrough' for %s.", spec_key)
687 |                 else: self.logger.debug("No scaling configured or default 'None' for %s.", spec_key)
    |                                                                                                    ^ E501
688 |                 return None
    |

gal_friday/feature_engine.py:690:100: E501 Line too long (109 > 99)
    |
688 |                 return None
689 |
690 |             scaler_instance: StandardScaler | MinMaxScaler | RobustScaler = StandardScaler() # Default scaler
    |                                                                                                    ^^^^^^^^^^ E501
691 |             scaler_name_suffix = "StandardScaler"
    |

gal_friday/feature_engine.py:696:100: E501 Line too long (105 > 99)
    |
694 |                 method = scaling_cfg.get("method", "standard")
695 |                 if method == "minmax":
696 |                     scaler_instance = MinMaxScaler(feature_range=scaling_cfg.get("feature_range", (0,1)))
    |                                                                                                    ^^^^^^ E501
697 |                     scaler_name_suffix = f"MinMaxScaler_{scaler_instance.feature_range}"
698 |                 elif method == "robust":
    |

gal_friday/feature_engine.py:699:100: E501 Line too long (114 > 99)
    |
697 |                     scaler_name_suffix = f"MinMaxScaler_{scaler_instance.feature_range}"
698 |                 elif method == "robust":
699 |                     scaler_instance = RobustScaler(quantile_range=scaling_cfg.get("quantile_range", (25.0, 75.0)))
    |                                                                                                    ^^^^^^^^^^^^^^^ E501
700 |                     scaler_name_suffix = f"RobustScaler_{scaler_instance.quantile_range}"
701 |                 elif method != "standard":
    |

gal_friday/feature_engine.py:702:100: E501 Line too long (118 > 99)
    |
700 |              scaler_name_suffix = f"RobustScaler_{scaler_instance.quantile_range}"
701 |          elif method != "standard":
702 |              self.logger.warning("Unknown scaling method '%s' for %s. Using StandardScaler.", method, spec_key)
    |                                                                                              ^^^^^^^^^^^^^^^^^^^ E501
703 |      elif isinstance(scaling_cfg, str) and scaling_cfg not in ["standard", "passthrough"]: # e.g. just "minmax"
704 |           self.logger.warning("Simple string for scaling method '%s' for %s is ambiguous. Use dict config or 'passthrough'. Defaulti
    |

gal_friday/feature_engine.py:703:100: E501 Line too long (118 > 99)
    |
701 |          elif method != "standard":
702 |              self.logger.warning("Unknown scaling method '%s' for %s. Using StandardScaler.", method, spec_key)
703 |      elif isinstance(scaling_cfg, str) and scaling_cfg not in ["standard", "passthrough"]: # e.g. just "minmax"
    |                                                                                              ^^^^^^^^^^^^^^^^^^^ E501
704 |           self.logger.warning("Simple string for scaling method '%s' for %s is ambiguous. Use dict config or 'passthrough'. Defaulti
    |

gal_friday/feature_engine.py:704:100: E501 Line too long (185 > 99)
    |
702 | ing StandardScaler.", method, spec_key)
703 | ", "passthrough"]: # e.g. just "minmax"
704 |  %s is ambiguous. Use dict config or 'passthrough'. Defaulting to StandardScaler.", scaling_cfg, spec_key)
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
    |

gal_friday/feature_engine.py:707:100: E501 Line too long (102 > 99)
    |
707 |             self.logger.debug("Using %s for scaling for %s", type(scaler_instance).__name__, spec_key)
    |                                                                                                    ^^^ E501
708 |             return (f"{spec_key}_output_scaler_{scaler_name_suffix}", PandasScalerTransformer(scaler_instance))
    |

gal_friday/feature_engine.py:708:100: E501 Line too long (111 > 99)
    |
707 |             self.logger.debug("Using %s for scaling for %s", type(scaler_instance).__name__, spec_key)
708 |             return (f"{spec_key}_output_scaler_{scaler_name_suffix}", PandasScalerTransformer(scaler_instance))
    |                                                                                                    ^^^^^^^^^^^^ E501
    |

gal_friday/feature_engine.py:711:13: B007 Loop control variable `feature_key` not used within loop body
    |
711 |         for feature_key, spec in self._feature_configs.items(): # Now iterates over InternalFeatureSpec
    |             ^^^^^^^^^^^ B007
712 |             pipeline_steps = []
713 |             pipeline_name = f"{spec.key}_pipeline" # Use spec.key for consistency
    |
    = help: Rename unused `feature_key` to `_feature_key`

gal_friday/feature_engine.py:711:100: E501 Line too long (103 > 99)
    |
711 |         for feature_key, spec in self._feature_configs.items(): # Now iterates over InternalFeatureSpec
    |                                                                                                    ^^^^ E501
712 |             pipeline_steps = []
713 |             pipeline_name = f"{spec.key}_pipeline" # Use spec.key for consistency
    |

gal_friday/feature_engine.py:717:100: E501 Line too long (102 > 99)
    |
715 |             # Input imputer for features that take a single series like 'close'
716 |             if spec.input_type == "close_series":
717 |                 # TODO: Make input imputer strategy configurable if needed from global or feature spec
    |                                                                                                    ^^^ E501
718 |                 self.logger.debug("Adding standard input imputer (mean) for %s", spec.key)
719 |                 pipeline_steps.append((f"{spec.key}_input_imputer", SimpleImputer(strategy="mean")))
    |

gal_friday/feature_engine.py:719:100: E501 Line too long (100 > 99)
    |
717 |                 # TODO: Make input imputer strategy configurable if needed from global or feature spec
718 |                 self.logger.debug("Adding standard input imputer (mean) for %s", spec.key)
719 |                 pipeline_steps.append((f"{spec.key}_input_imputer", SimpleImputer(strategy="mean")))
    |                                                                                                    ^ E501
720 |
721 |             # Calculator step based on spec.calculator_type
    |

gal_friday/feature_engine.py:722:100: E501 Line too long (103 > 99)
    |
721 |      # Calculator step based on spec.calculator_type
722 |      calculator_func = getattr(FeatureEngine, f"_pipeline_compute_{spec.calculator_type}", None)
    |                                                                                              ^^^^ E501
723 |      if not calculator_func:
724 |          self.logger.error("No _pipeline_compute function found for calculator_type: %s (feature key: %s)", spec.calculator_type, sp
    |

gal_friday/feature_engine.py:724:100: E501 Line too long (146 > 99)
    |
722 | eline_compute_{spec.calculator_type}", None)
723 | 
724 | ction found for calculator_type: %s (feature key: %s)", spec.calculator_type, spec.key)
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
725 | 
    |

gal_friday/feature_engine.py:732:100: E501 Line too long (117 > 99)
    |
731 |      if spec.calculator_type in ["rsi", "roc", "stdev"]:
732 |          default_period = 14 if spec.calculator_type == "rsi" else 10 if spec.calculator_type == "roc" else 20
    |                                                                                              ^^^^^^^^^^^^^^^^^^ E501
733 |          calc_kw_args["period"] = spec.parameters.get("period", default_period)
734 |          if spec.parameters.get("period") is None: self.logger.debug("Using default period %s for %s ('%s')", calc_kw_args["period"]
    |

gal_friday/feature_engine.py:734:57: E701 Multiple statements on one line (colon)
    |
732 |                 default_period = 14 if spec.calculator_type == "rsi" else 10 if spec.calculator_type == "roc" else 20
733 |                 calc_kw_args["period"] = spec.parameters.get("period", default_period)
734 |                 if spec.parameters.get("period") is None: self.logger.debug("Using default period %s for %s ('%s')", calc_kw_args["pe
    |                                                         ^ E701
735 |
736 |             elif spec.calculator_type == "macd":
    |

gal_friday/feature_engine.py:734:100: E501 Line too long (172 > 99)
    |
732 | e 10 if spec.calculator_type == "roc" else 20
733 | efault_period)
734 | bug("Using default period %s for %s ('%s')", calc_kw_args["period"], spec.calculator_type, spec.key)
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
735 | 
736 | 
    |

gal_friday/feature_engine.py:741:100: E501 Line too long (170 > 99)
    |
739 | 9)
740 | ", "signal"]):
741 | s:%s,sig:%s) for %s", calc_kw_args["fast"], calc_kw_args["slow"], calc_kw_args["signal"], spec.key)
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
742 | 
743 | 
    |

gal_friday/feature_engine.py:747:100: E501 Line too long (149 > 99)
    |
745 | rs.get("std_dev", 2.0))
746 | v" not in spec.parameters:
747 | params (l:%s,s:%.1f) for %s", calc_kw_args["length"], calc_kw_args["std_dev"], spec.key)
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
748 | 
749 | 
    |

gal_friday/feature_engine.py:751:100: E501 Line too long (101 > 99)
    |
749 |      elif spec.calculator_type == "atr":
750 |          calc_kw_args["length"] = spec.parameters.get("length", 14)
751 |          # high_col, low_col, close_col default in function signature of _pipeline_compute_atr
    |                                                                                              ^^ E501
752 |          if "length" not in spec.parameters: self.logger.debug("Using default ATR length %s for %s", calc_kw_args["length"], spec.ke
    |

gal_friday/feature_engine.py:752:51: E701 Multiple statements on one line (colon)
    |
750 |                 calc_kw_args["length"] = spec.parameters.get("length", 14)
751 |                 # high_col, low_col, close_col default in function signature of _pipeline_compute_atr
752 |                 if "length" not in spec.parameters: self.logger.debug("Using default ATR length %s for %s", calc_kw_args["length"], s
    |                                                   ^ E701
753 |
754 |             elif spec.calculator_type == "vwap_ohlcv":
    |

gal_friday/feature_engine.py:752:100: E501 Line too long (141 > 99)
    |
750 | get("length", 14)
751 |  function signature of _pipeline_compute_atr
752 | logger.debug("Using default ATR length %s for %s", calc_kw_args["length"], spec.key)
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
753 | 
754 | 
    |

gal_friday/feature_engine.py:756:51: E701 Multiple statements on one line (colon)
    |
754 |             elif spec.calculator_type == "vwap_ohlcv":
755 |                 calc_kw_args["length"] = spec.parameters.get("length", 14)
756 |                 if "length" not in spec.parameters: self.logger.debug("Using default VWAP_OHLCV length %s for %s", calc_kw_args["leng
    |                                                   ^ E701
757 |
758 |             elif spec.calculator_type in ["l2_imbalance", "l2_depth", "l2_wap"]:
    |

gal_friday/feature_engine.py:756:100: E501 Line too long (148 > 99)
    |
754 | 
755 | ("length", 14)
756 | ger.debug("Using default VWAP_OHLCV length %s for %s", calc_kw_args["length"], spec.key)
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
757 | 
758 | 2_depth", "l2_wap"]:
    |

gal_friday/feature_engine.py:761:52: E701 Multiple statements on one line (colon)
    |
759 |                 # `ohlcv_close_prices` is NOT included here; it's passed dynamically for l2_wap.
760 |                 default_levels = 5
761 |                 if spec.calculator_type == "l2_wap": default_levels = 1
    |                                                    ^ E701
762 |                 elif spec.calculator_type == "l2_spread": default_levels = 0 # Not applicable for spread
    |

gal_friday/feature_engine.py:762:57: E701 Multiple statements on one line (colon)
    |
760 |                 default_levels = 5
761 |                 if spec.calculator_type == "l2_wap": default_levels = 1
762 |                 elif spec.calculator_type == "l2_spread": default_levels = 0 # Not applicable for spread
    |                                                         ^ E701
763 |
764 |                 if default_levels > 0: # Only add 'levels' if applicable
    |

gal_friday/feature_engine.py:762:100: E501 Line too long (104 > 99)
    |
760 |                 default_levels = 5
761 |                 if spec.calculator_type == "l2_wap": default_levels = 1
762 |                 elif spec.calculator_type == "l2_spread": default_levels = 0 # Not applicable for spread
    |                                                                                                    ^^^^^ E501
763 |
764 |                 if default_levels > 0: # Only add 'levels' if applicable
    |

gal_friday/feature_engine.py:766:55: E701 Multiple statements on one line (colon)
    |
764 |                 if default_levels > 0: # Only add 'levels' if applicable
765 |                     calc_kw_args["levels"] = spec.parameters.get("levels", default_levels)
766 |                     if "levels" not in spec.parameters: self.logger.debug("Using default levels %s for %s ('%s')", calc_kw_args["leve
    |                                                       ^ E701
767 |
768 |             elif spec.calculator_type == "vwap_trades" or spec.calculator_type == "volume_delta":
    |

gal_friday/feature_engine.py:766:100: E501 Line too long (170 > 99)
    |
764 | e
765 | s", default_levels)
766 | ug("Using default levels %s for %s ('%s')", calc_kw_args["levels"], spec.calculator_type, spec.key)
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
767 | 
768 | or_type == "volume_delta":
    |

gal_friday/feature_engine.py:768:18: PLR1714 Consider merging multiple comparisons.
    |
766 |                     if "levels" not in spec.parameters: self.logger.debug("Using default levels %s for %s ('%s')", calc_kw_args["leve
767 |
768 |             elif spec.calculator_type == "vwap_trades" or spec.calculator_type == "volume_delta":
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR1714
769 |                 # `ohlcv_close_prices` is NOT included here; it's passed dynamically.
770 |                 # `bar_start_times` is also dynamic, passed at runtime.
    |
    = help: Merge multiple comparisons

gal_friday/feature_engine.py:773:100: E501 Line too long (115 > 99)
    |
771 |      # `trade_history_deque` is the `X` input to fit_transform.
772 |      calc_kw_args["bar_interval_seconds"] = spec.parameters.get("bar_interval_seconds",
773 |                                                               spec.parameters.get("length_seconds", 60))
    |                                                                                          ^^^^^^^^^^^^^^^^ E501
774 |      if "bar_interval_seconds" not in spec.parameters and "length_seconds" not in spec.parameters:
775 |          self.logger.debug("Using default bar_interval_seconds %s for %s ('%s')", calc_kw_args["bar_interval_seconds"], spec.calcula
    |

gal_friday/feature_engine.py:774:100: E501 Line too long (109 > 99)
    |
772 |      calc_kw_args["bar_interval_seconds"] = spec.parameters.get("bar_interval_seconds",
773 |                                                               spec.parameters.get("length_seconds", 60))
774 |      if "bar_interval_seconds" not in spec.parameters and "length_seconds" not in spec.parameters:
    |                                                                                          ^^^^^^^^^^ E501
775 |          self.logger.debug("Using default bar_interval_seconds %s for %s ('%s')", calc_kw_args["bar_interval_seconds"], spec.calcula
776 |      # `bar_start_times` will be passed dynamically during the call in _calculate_and_publish_features
    |

gal_friday/feature_engine.py:775:100: E501 Line too long (162 > 99)
    |
773 |       spec.parameters.get("length_seconds", 60))
774 | d "length_seconds" not in spec.parameters:
775 | econds %s for %s ('%s')", calc_kw_args["bar_interval_seconds"], spec.calculator_type, spec.key)
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
776 | ng the call in _calculate_and_publish_features
    |

gal_friday/feature_engine.py:776:100: E501 Line too long (113 > 99)
    |
774 |                 if "bar_interval_seconds" not in spec.parameters and "length_seconds" not in spec.parameters:
775 |                     self.logger.debug("Using default bar_interval_seconds %s for %s ('%s')", calc_kw_args["bar_interval_seconds"], sp
776 |                 # `bar_start_times` will be passed dynamically during the call in _calculate_and_publish_features
    |                                                                                                    ^^^^^^^^^^^^^^ E501
777 |
778 |             # l2_spread currently has no parameters in its _pipeline_compute_l2_spread signature other than X.
    |

gal_friday/feature_engine.py:778:100: E501 Line too long (110 > 99)
    |
776 |                 # `bar_start_times` will be passed dynamically during the call in _calculate_and_publish_features
777 |
778 |             # l2_spread currently has no parameters in its _pipeline_compute_l2_spread signature other than X.
    |                                                                                                    ^^^^^^^^^^^ E501
779 |
780 |             pipeline_steps.append((f"{spec.key}_calculator", FunctionTransformer(calculator_func, kw_args=calc_kw_args, validate=Fals
    |

gal_friday/feature_engine.py:780:100: E501 Line too long (137 > 99)
    |
778 | its _pipeline_compute_l2_spread signature other than X.
779 | 
780 | tor", FunctionTransformer(calculator_func, kw_args=calc_kw_args, validate=False)))
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
781 | 
782 | 
    |

gal_friday/feature_engine.py:786:45: E701 Multiple statements on one line (colon)
    |
784 |      # Define default fill values based on feature type characteristics
785 |      default_fill = 0.0 # General default
786 |      if spec.calculator_type == "rsi": default_fill = 50.0
    |                                       ^ E701
787 |      elif spec.calculator_type in ["atr", "vwap_ohlcv", "l2_wap", "vwap_trades", "stdev"]: default_fill = np.nan # Will be filled by
    |

gal_friday/feature_engine.py:787:97: E701 Multiple statements on one line (colon)
    |
785 |             default_fill = 0.0 # General default
786 |             if spec.calculator_type == "rsi": default_fill = 50.0
787 |             elif spec.calculator_type in ["atr", "vwap_ohlcv", "l2_wap", "vwap_trades", "stdev"]: default_fill = np.nan # Will be fil
    |                                                                                                 ^ E701
788 |
789 |             imputer_step = get_output_imputer_step(spec.imputation, default_fill_value=default_fill, is_dataframe_output=is_df_output
    |

gal_friday/feature_engine.py:787:100: E501 Line too long (149 > 99)
    |
785 | 
786 | 50.0
787 | , "l2_wap", "vwap_trades", "stdev"]: default_fill = np.nan # Will be filled by mean then
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
788 | 
789 | ation, default_fill_value=default_fill, is_dataframe_output=is_df_output, spec_key=spec.key)
    |

gal_friday/feature_engine.py:789:100: E501 Line too long (153 > 99)
    |
787 | "l2_wap", "vwap_trades", "stdev"]: default_fill = np.nan # Will be filled by mean then
788 | 
789 | ion, default_fill_value=default_fill, is_dataframe_output=is_df_output, spec_key=spec.key)
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
790 | )
    |

gal_friday/feature_engine.py:790:28: E701 Multiple statements on one line (colon)
    |
789 |             imputer_step = get_output_imputer_step(spec.imputation, default_fill_value=default_fill, is_dataframe_output=is_df_output
790 |             if imputer_step: pipeline_steps.append(imputer_step)
    |                            ^ E701
791 |
792 |             scaler_step = get_output_scaler_step(spec.scaling, spec_key=spec.key)
    |

gal_friday/feature_engine.py:793:27: E701 Multiple statements on one line (colon)
    |
792 |             scaler_step = get_output_scaler_step(spec.scaling, spec_key=spec.key)
793 |             if scaler_step: pipeline_steps.append(scaler_step)
    |                           ^ E701
794 |
795 |             if pipeline_steps:
    |

gal_friday/feature_engine.py:1116:9: D205 1 blank line required between summary line and description
     |
1115 |       def _get_min_history_required(self) -> int:
1116 | /         """Determine the minimum required history size for TA calculations.
1117 | |         This function relies on accessing period/length parameters from feature configurations.
1118 | |         The addition of 'imputation' and 'scaling' keys at the same level in the
1119 | |         configuration structure does not affect its operation.
1120 | |         """
     | |___________^ D205
1121 |           min_size = 1  # Minimum baseline
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1130:100: E501 Line too long (102 > 99)
     |
1128 |                 periods.append(period)
1129 |             elif spec.calculator_type in ["bbands", "vwap_ohlcv", "atr", "stdev"]:
1130 |                 length = spec.parameters.get("length", 20 if spec.calculator_type == "bbands" else 14)
     |                                                                                                    ^^^ E501
1131 |                 periods.append(length)
     |

gal_friday/feature_engine.py:1144:9: D205 1 blank line required between summary line and description
     |
1142 |           default_value: int,
1143 |       ) -> int:
1144 | /         """Retrieve the period from config for a specific feature.
1145 | |         This function relies on accessing specific period/length parameters within a
1146 | |         feature's configuration dictionary. The addition of 'imputation' and 'scaling'
1147 | |         keys at the same level does not affect its ability to retrieve these parameters.
1148 | |         """
     | |___________^ D205
1149 |           feature_spec = self._feature_configs.get(feature_name)
1150 |           if feature_spec and isinstance(feature_spec, InternalFeatureSpec):
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1153:100: E501 Line too long (101 > 99)
     |
1151 |             period_value = feature_spec.parameters.get(field_name, default_value)
1152 |             return (
1153 |                 period_value if isinstance(period_value, int) and period_value > 0 else default_value
     |                                                                                                    ^^ E501
1154 |             )
1155 |         # If feature_spec is not found or not the right type
     |

gal_friday/feature_engine.py:1296:9: D205 1 blank line required between summary line and description
     |
1294 |       @staticmethod
1295 |       def _pipeline_compute_rsi(data: pd.Series, period: int) -> pd.Series:
1296 | /         """Compute RSI using pandas-ta, expecting float64 Series input.
1297 | |         Intended for use in Scikit-learn FunctionTransformer.
1298 | |         """
     | |___________^ D205
1299 |           if not isinstance(data, pd.Series):
1300 |               # self.logger.error("_pipeline_compute_rsi expects a pd.Series.") # Logger not available in static method
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1300:100: E501 Line too long (117 > 99)
     |
1298 |         """
1299 |         if not isinstance(data, pd.Series):
1300 |             # self.logger.error("_pipeline_compute_rsi expects a pd.Series.") # Logger not available in static method
     |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
1301 |             return pd.Series(dtype="float64", name=f"rsi_{period}") # Return empty named series on error
     |

gal_friday/feature_engine.py:1301:100: E501 Line too long (104 > 99)
     |
1299 |         if not isinstance(data, pd.Series):
1300 |             # self.logger.error("_pipeline_compute_rsi expects a pd.Series.") # Logger not available in static method
1301 |             return pd.Series(dtype="float64", name=f"rsi_{period}") # Return empty named series on error
     |                                                                                                    ^^^^^ E501
1302 |
1303 |         rsi_series = data.ta.rsi(length=period)
     |

gal_friday/feature_engine.py:1316:9: D205 1 blank line required between summary line and description
     |
1314 |           signal: int,
1315 |       ) -> pd.DataFrame:
1316 | /         """Compute MACD using pandas-ta, expecting float64 Series input.
1317 | |         Returns a DataFrame with MACD, histogram, and signal lines.
1318 | |         Intended for use in Scikit-learn FunctionTransformer.
1319 | |         """
     | |___________^ D205
1320 |           if not isinstance(data, pd.Series):
1321 |               # self.logger.error("_pipeline_compute_macd expects a pd.Series.")
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1332:9: D205 1 blank line required between summary line and description
     |
1330 |       @staticmethod
1331 |       def _fillna_bbands(bbands_df: pd.DataFrame, close_prices: pd.Series) -> pd.DataFrame:
1332 | /         """Helper to fill NaNs in Bollinger Bands results.
1333 | |         Middle band NaN is filled with close price. Lower/Upper NaNs also with close price.
1334 | |         """
     | |___________^ D205
1335 |           if bbands_df is None:
1336 |               return pd.DataFrame(dtype="float64")
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1350:100: E501 Line too long (106 > 99)
     |
1348 |             bbands_df[upper_col] = bbands_df[upper_col].fillna(close_prices)
1349 |
1350 |         # Any other columns (like bandwidth or percent) that might be NaN, fill with 0 or another strategy
     |                                                                                                    ^^^^^^^ E501
1351 |         for col in bbands_df.columns:
1352 |             if col not in [middle_col, lower_col, upper_col] and bbands_df[col].isna().any():
     |

gal_friday/feature_engine.py:1358:9: D205 1 blank line required between summary line and description
     |
1356 |       @staticmethod
1357 |       def _pipeline_compute_bbands(data: pd.Series, length: int, std_dev: float) -> pd.DataFrame:
1358 | /         """Compute Bollinger Bands using pandas-ta, expecting float64 Series input.
1359 | |         Returns a DataFrame with lower, middle, upper bands.
1360 | |         Intended for use in Scikit-learn FunctionTransformer.
1361 | |         """
     | |___________^ D205
1362 |           if not isinstance(data, pd.Series):
1363 |               return pd.DataFrame(dtype="float64")
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1365:100: E501 Line too long (101 > 99)
     |
1363 |             return pd.DataFrame(dtype="float64")
1364 |         bbands_df = data.ta.bbands(length=length, std=std_dev)
1365 |         # Custom NaN filling: Middle band with close, Lower/Upper also with close (0 width initially)
     |                                                                                                    ^^ E501
1366 |         if bbands_df is not None:
1367 |             bbands_df = FeatureEngine._fillna_bbands(bbands_df, data)
     |

gal_friday/feature_engine.py:1368:100: E501 Line too long (102 > 99)
     |
1366 |         if bbands_df is not None:
1367 |             bbands_df = FeatureEngine._fillna_bbands(bbands_df, data)
1368 |         return bbands_df.astype("float64") if bbands_df is not None else pd.DataFrame(dtype="float64")
     |                                                                                                    ^^^ E501
1369 |
1370 |     @staticmethod
     |

gal_friday/feature_engine.py:1372:9: D205 1 blank line required between summary line and description
     |
1370 |       @staticmethod
1371 |       def _pipeline_compute_roc(data: pd.Series, period: int) -> pd.Series:
1372 | /         """Compute Rate of Change (ROC) using pandas-ta, expecting float64 Series input.
1373 | |         Intended for use in Scikit-learn FunctionTransformer.
1374 | |         """
     | |___________^ D205
1375 |           if not isinstance(data, pd.Series):
1376 |               return pd.Series(dtype="float64", name=f"roc_{period}")
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1391:9: D205 1 blank line required between summary line and description
     |
1389 |           close_col: str = "close",
1390 |       ) -> pd.Series:
1391 | /         """Compute Average True Range (ATR) using pandas-ta.
1392 | |         Expects a DataFrame with high, low, close columns (float64).
1393 | |         Intended for use in Scikit-learn FunctionTransformer.
1394 | |         """
     | |___________^ D205
1395 |           if not isinstance(ohlc_data, pd.DataFrame):
1396 |               return pd.Series(dtype="float64", name=f"atr_{length}")
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1416:9: D205 1 blank line required between summary line and description
     |
1414 |       @staticmethod
1415 |       def _pipeline_compute_stdev(data: pd.Series, length: int) -> pd.Series:
1416 | /         """Compute Standard Deviation using pandas .rolling().std().
1417 | |         Expects float64 Series input.
1418 | |         Intended for use in Scikit-learn FunctionTransformer.
1419 | |         """
     | |___________^ D205
1420 |           if not isinstance(data, pd.Series):
1421 |               return pd.Series(dtype="float64", name=f"stdev_{length}")
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1437:9: D205 1 blank line required between summary line and description
     |
1435 |           volume_col: str = "volume",
1436 |       ) -> pd.Series:
1437 | /         """Compute VWAP from OHLCV data using rolling window.
1438 | |         Expects DataFrame with Decimal objects for price/volume, converts to float64 Series output.
1439 | |         Intended for use in Scikit-learn FunctionTransformer.
1440 | |         """
     | |___________^ D205
1441 |           if not isinstance(ohlcv_df, pd.DataFrame):
1442 |               return pd.Series(dtype="float64")
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1459:100: E501 Line too long (103 > 99)
     |
1458 |         vwap_series_decimal = sum_tp_vol / sum_vol
1459 |         # Replace infinities (from division by zero if sum_vol is 0) with NaN before further processing
     |                                                                                                    ^^^^ E501
1460 |         vwap_series_decimal = vwap_series_decimal.replace([Decimal("Infinity"), Decimal("-Infinity")], pd.NA)
     |

gal_friday/feature_engine.py:1460:100: E501 Line too long (109 > 99)
     |
1458 |         vwap_series_decimal = sum_tp_vol / sum_vol
1459 |         # Replace infinities (from division by zero if sum_vol is 0) with NaN before further processing
1460 |         vwap_series_decimal = vwap_series_decimal.replace([Decimal("Infinity"), Decimal("-Infinity")], pd.NA)
     |                                                                                                    ^^^^^^^^^^ E501
1461 |
1462 |         # Iterate and fill NaNs or zero-volume results with the typical price of that bar
     |

gal_friday/feature_engine.py:1464:100: E501 Line too long (101 > 99)
     |
1462 |         # Iterate and fill NaNs or zero-volume results with the typical price of that bar
1463 |         for idx in ohlcv_df.index:
1464 |             current_sum_vol = sum_vol.get(idx) # Use .get for safety if index alignment isn't perfect
     |                                                                                                    ^^ E501
1465 |             current_vwap_val = vwap_series_decimal.get(idx)
     |

gal_friday/feature_engine.py:1467:100: E501 Line too long (104 > 99)
     |
1465 |             current_vwap_val = vwap_series_decimal.get(idx)
1466 |
1467 |             if current_sum_vol == Decimal("0") or pd.isna(current_sum_vol) or pd.isna(current_vwap_val):
     |                                                                                                    ^^^^^ E501
1468 |                 # Ensure we access original Decimal values for typical price calculation if ohlcv_df was float
1469 |                 # However, ohlcv_df input to this function is already converted to Decimal for H,L,C,V
     |

gal_friday/feature_engine.py:1468:100: E501 Line too long (110 > 99)
     |
1467 |             if current_sum_vol == Decimal("0") or pd.isna(current_sum_vol) or pd.isna(current_vwap_val):
1468 |                 # Ensure we access original Decimal values for typical price calculation if ohlcv_df was float
     |                                                                                                    ^^^^^^^^^^^ E501
1469 |                 # However, ohlcv_df input to this function is already converted to Decimal for H,L,C,V
1470 |                 # So, high_d, low_d, close_d can be used with .loc[idx]
     |

gal_friday/feature_engine.py:1469:100: E501 Line too long (102 > 99)
     |
1467 |             if current_sum_vol == Decimal("0") or pd.isna(current_sum_vol) or pd.isna(current_vwap_val):
1468 |                 # Ensure we access original Decimal values for typical price calculation if ohlcv_df was float
1469 |                 # However, ohlcv_df input to this function is already converted to Decimal for H,L,C,V
     |                                                                                                    ^^^ E501
1470 |                 # So, high_d, low_d, close_d can be used with .loc[idx]
1471 |                 # Or, re-access from the original ohlcv_df if it was passed with Decimals
     |

gal_friday/feature_engine.py:1472:100: E501 Line too long (101 > 99)
     |
1470 |                 # So, high_d, low_d, close_d can be used with .loc[idx]
1471 |                 # Or, re-access from the original ohlcv_df if it was passed with Decimals
1472 |                 # For simplicity, assume ohlcv_df passed has Decimal type for H,L,C for this fallback
     |                                                                                                    ^^ E501
1473 |                 # If ohlcv_df was passed as float64, this might lose some Decimal precision for typical price.
1474 |                 # The current `_calculate_and_publish_features` converts ohlcv_df to float64 first,
     |

gal_friday/feature_engine.py:1473:100: E501 Line too long (110 > 99)
     |
1471 |                 # Or, re-access from the original ohlcv_df if it was passed with Decimals
1472 |                 # For simplicity, assume ohlcv_df passed has Decimal type for H,L,C for this fallback
1473 |                 # If ohlcv_df was passed as float64, this might lose some Decimal precision for typical price.
     |                                                                                                    ^^^^^^^^^^^ E501
1474 |                 # The current `_calculate_and_publish_features` converts ohlcv_df to float64 first,
1475 |                 # then this function converts selected columns back to Decimal. This is acceptable.
     |

gal_friday/feature_engine.py:1477:17: E741 Ambiguous variable name: `l`
     |
1475 |                 # then this function converts selected columns back to Decimal. This is acceptable.
1476 |                 h = high_d.get(idx, pd.NA)
1477 |                 l = low_d.get(idx, pd.NA)
     |                 ^ E741
1478 |                 c = close_d.get(idx, pd.NA)
1479 |                 if pd.notna(h) and pd.notna(l) and pd.notna(c):
     |

gal_friday/feature_engine.py:1482:100: E501 Line too long (116 > 99)
     |
1480 |                     vwap_series_decimal[idx] = (h + l + c) / Decimal("3.0")
1481 |                 else:
1482 |                     # If any HLC is NA for this specific bar, we can't calculate typical price, so leave/make it NaN
     |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
1483 |                     vwap_series_decimal[idx] = pd.NA
     |

gal_friday/feature_engine.py:1487:100: E501 Line too long (107 > 99)
     |
1486 |         # Convert to float64 for pipeline compatibility.
1487 |         # NaNs from missing HLC for typical price fallback, or if typical price itself is NaN, will remain.
     |                                                                                                    ^^^^^^^^ E501
1488 |         vwap_series_float = vwap_series_decimal.astype("float64")
1489 |         vwap_series_float.name = f"vwap_ohlcv_{length}"
     |

gal_friday/feature_engine.py:1499:9: PLR0912 Too many branches (17 > 12)
     |
1498 |     @staticmethod
1499 |     def _pipeline_compute_vwap_trades(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
1500 |         trade_history_deque: deque, # Deque of trade dicts {"price": Decimal, "volume": Decimal, "timestamp": datetime}
1501 |         bar_start_times: pd.Series, # Series of datetime objects
     |

gal_friday/feature_engine.py:1500:100: E501 Line too long (119 > 99)
     |
1498 |     @staticmethod
1499 |     def _pipeline_compute_vwap_trades(
1500 |         trade_history_deque: deque, # Deque of trade dicts {"price": Decimal, "volume": Decimal, "timestamp": datetime}
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
1501 |         bar_start_times: pd.Series, # Series of datetime objects
1502 |         bar_interval_seconds: int,
     |

gal_friday/feature_engine.py:1505:9: D205 1 blank line required between summary line and description
     |
1503 |           ohlcv_close_prices: pd.Series | None = None, # For fallback
1504 |       ) -> pd.Series:
1505 | /         """Compute VWAP from trade data for specified bar start times.
1506 | |         Returns a float64 Series.
1507 | |         If no relevant trades or sum_volume is zero, falls back to ohlcv_close_prices.
1508 | |         If fallback also fails, defaults to 0.0.
1509 | |         Intended for use in Scikit-learn FunctionTransformer.
1510 | |         """
     | |___________^ D205
1511 |           series_name = f"vwap_trades_{bar_interval_seconds}s"
1512 |           output_index = bar_start_times.index if isinstance(bar_start_times, pd.Series) else None
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1514:100: E501 Line too long (105 > 99)
     |
1512 |         output_index = bar_start_times.index if isinstance(bar_start_times, pd.Series) else None
1513 |         if not isinstance(bar_start_times, pd.Series): # Basic validation for bar_start_times
1514 |             # trade_history_deque validation is implicitly handled by checking if trades_df is None/empty
     |                                                                                                    ^^^^^^ E501
1515 |             return pd.Series(dtype="float64", index=output_index, name=series_name)
     |

gal_friday/feature_engine.py:1529:100: E501 Line too long (101 > 99)
     |
1527 |                     trades_df = pd.DataFrame(list(trade_history_deque))
1528 |
1529 |                 if not trades_df.empty: # Proceed with type conversion only if DataFrame is not empty
     |                                                                                                    ^^ E501
1530 |                     trades_df["price"] = trades_df["price"].apply(lambda x: Decimal(str(x)))
1531 |                     trades_df["volume"] = trades_df["volume"].apply(lambda x: Decimal(str(x)))
     |

gal_friday/feature_engine.py:1537:100: E501 Line too long (107 > 99)
     |
1535 |             except (ValueError, TypeError, KeyError, AttributeError):
1536 |                 # Catch broad errors during DataFrame creation or type conversion
1537 |                 # self.logger.warning("Error processing trade_history_deque: %s", e) # Logger not available
     |                                                                                                    ^^^^^^^^ E501
1538 |                 trades_df = None # Force fallback for all bars if trade data is corrupt
     |

gal_friday/feature_engine.py:1540:100: E501 Line too long (102 > 99)
     |
1538 |                 trades_df = None # Force fallback for all bars if trade data is corrupt
1539 |
1540 |         for bar_start_dt_idx, bar_start_dt in bar_start_times.items(): # Use .items() for index access
     |                                                                                                    ^^^ E501
1541 |             calculated_vwap = np.nan
     |

gal_friday/feature_engine.py:1546:100: E501 Line too long (100 > 99)
     |
1544 |                 bar_end_dt = bar_start_dt + pd.Timedelta(seconds=bar_interval_seconds)
1545 |                 relevant_trades = trades_df[
1546 |                     (trades_df["timestamp"] >= bar_start_dt) & (trades_df["timestamp"] < bar_end_dt)
     |                                                                                                    ^ E501
1547 |                 ]
     |

gal_friday/feature_engine.py:1561:100: E501 Line too long (103 > 99)
     |
1559 |                 current_bar_ohlcv_close_price = np.nan
1560 |                 if ohlcv_close_prices is not None:
1561 |                     # Try to get by direct index (bar_start_dt may be the index for ohlcv_close_prices)
     |                                                                                                    ^^^^ E501
1562 |                     # Or by bar_start_dt_idx if ohlcv_close_prices is aligned with bar_start_times' original index
1563 |                     if bar_start_dt in ohlcv_close_prices.index:
     |

gal_friday/feature_engine.py:1562:100: E501 Line too long (114 > 99)
     |
1560 |                 if ohlcv_close_prices is not None:
1561 |                     # Try to get by direct index (bar_start_dt may be the index for ohlcv_close_prices)
1562 |                     # Or by bar_start_dt_idx if ohlcv_close_prices is aligned with bar_start_times' original index
     |                                                                                                    ^^^^^^^^^^^^^^^ E501
1563 |                     if bar_start_dt in ohlcv_close_prices.index:
1564 |                          current_bar_ohlcv_close_price = ohlcv_close_prices.get(bar_start_dt)
     |

gal_friday/feature_engine.py:1565:100: E501 Line too long (112 > 99)
     |
1563 |                     if bar_start_dt in ohlcv_close_prices.index:
1564 |                          current_bar_ohlcv_close_price = ohlcv_close_prices.get(bar_start_dt)
1565 |                     elif bar_start_dt_idx in ohlcv_close_prices.index: # Fallback to original index if different
     |                                                                                                    ^^^^^^^^^^^^^ E501
1566 |                          current_bar_ohlcv_close_price = ohlcv_close_prices.get(bar_start_dt_idx)
     |

gal_friday/feature_engine.py:1582:100: E501 Line too long (114 > 99)
     |
1580 |     # Note: _calculate_vwap and _calculate_vwap_from_trades removed.
1581 |     # --- Removed _calculate_roc, _calculate_atr, _calculate_stdev ---
1582 |     # --- Removed _calculate_bid_ask_spread, _calculate_order_book_imbalance, _calculate_wap, _calculate_depth ---
     |                                                                                                    ^^^^^^^^^^^^^^^ E501
1583 |         # --- Removed _calculate_true_volume_delta_from_trades, _calculate_vwap_from_trades ---
     |

gal_friday/feature_engine.py:1588:9: D205 1 blank line required between summary line and description
     |
1586 |       @staticmethod
1587 |       def _pipeline_compute_l2_spread(l2_books_series: pd.Series) -> pd.DataFrame:
1588 | /         """Computes bid-ask spread from a Series of L2 book snapshots.
1589 | |         Outputs a DataFrame with 'abs_spread' and 'pct_spread' (float64).
1590 | |         If L2 book is None, empty, or best bid/ask cannot be determined, outputs 0.0 for spreads.
1591 | |         Intended for Scikit-learn FunctionTransformer.
1592 | |         """
     | |___________^ D205
1593 |           abs_spreads = []
1594 |           pct_spreads = []
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1604:20: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
     |
1602 |                 if book and \
1603 |                    isinstance(book.get("bids"), list) and len(book["bids"]) > 0 and \
1604 |                    isinstance(book["bids"][0], (list, tuple)) and len(book["bids"][0]) == 2 and \
     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
1605 |                    isinstance(book.get("asks"), list) and len(book["asks"]) > 0 and \
1606 |                    isinstance(book["asks"][0], (list, tuple)) and len(book["asks"][0]) == 2:
     |
     = help: Convert to `X | Y`

gal_friday/feature_engine.py:1604:91: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
     |
1602 |                 if book and \
1603 |                    isinstance(book.get("bids"), list) and len(book["bids"]) > 0 and \
1604 |                    isinstance(book["bids"][0], (list, tuple)) and len(book["bids"][0]) == 2 and \
     |                                                                                           ^ PLR2004
1605 |                    isinstance(book.get("asks"), list) and len(book["asks"]) > 0 and \
1606 |                    isinstance(book["asks"][0], (list, tuple)) and len(book["asks"][0]) == 2:
     |

gal_friday/feature_engine.py:1606:20: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
     |
1604 |                    isinstance(book["bids"][0], (list, tuple)) and len(book["bids"][0]) == 2 and \
1605 |                    isinstance(book.get("asks"), list) and len(book["asks"]) > 0 and \
1606 |                    isinstance(book["asks"][0], (list, tuple)) and len(book["asks"][0]) == 2:
     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
1607 |
1608 |                     best_bid_price_str = str(book["bids"][0][0])
     |
     = help: Convert to `X | Y`

gal_friday/feature_engine.py:1606:91: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
     |
1604 |                    isinstance(book["bids"][0], (list, tuple)) and len(book["bids"][0]) == 2 and \
1605 |                    isinstance(book.get("asks"), list) and len(book["asks"]) > 0 and \
1606 |                    isinstance(book["asks"][0], (list, tuple)) and len(book["asks"][0]) == 2:
     |                                                                                           ^ PLR2004
1607 |
1608 |                     best_bid_price_str = str(book["bids"][0][0])
     |

gal_friday/feature_engine.py:1630:100: E501 Line too long (102 > 99)
     |
1628 |                 # else: conditions for invalid book structure lead to default 0.0 values
1629 |             except (TypeError, IndexError, ValueError, AttributeError):
1630 |                 # Errors from malformed book data, missing keys, non-Decimal convertible strings, etc.
     |                                                                                                    ^^^ E501
1631 |                 # These will result in the default 0.0 values being used.
1632 |                 pass # current_abs_spread and current_pct_spread remain 0.0
     |

gal_friday/feature_engine.py:1645:9: D205 1 blank line required between summary line and description
     |
1643 |       @staticmethod
1644 |       def _pipeline_compute_l2_imbalance(l2_books_series: pd.Series, levels: int = 5) -> pd.Series:
1645 | /         """Computes order book imbalance from a Series of L2 book snapshots.
1646 | |         Outputs a Series (float64).
1647 | |         If L2 book is None, empty, levels are malformed, or total volume for imbalance calc is zero, outputs 0.0.
1648 | |         Intended for Scikit-learn FunctionTransformer.
1649 | |         """
     | |___________^ D205
1650 |           imbalances = []
1651 |           series_name = f"imbalance_{levels}"
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1647:100: E501 Line too long (113 > 99)
     |
1645 |         """Computes order book imbalance from a Series of L2 book snapshots.
1646 |         Outputs a Series (float64).
1647 |         If L2 book is None, empty, levels are malformed, or total volume for imbalance calc is zero, outputs 0.0.
     |                                                                                                    ^^^^^^^^^^^^^^ E501
1648 |         Intended for Scikit-learn FunctionTransformer.
1649 |         """
     |

gal_friday/feature_engine.py:1667:33: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
     |
1665 |      valid_bids = True
1666 |      for i in range(levels):
1667 |          if not (isinstance(book["bids"][i], (list, tuple)) and len(book["bids"][i]) == 2 and book["bids"][i][1] is not None):
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
1668 |              valid_bids = False; break
     |
     = help: Convert to `X | Y`

gal_friday/feature_engine.py:1667:100: E501 Line too long (141 > 99)
     |
1665 | 
1666 | 
1667 | ], (list, tuple)) and len(book["bids"][i]) == 2 and book["bids"][i][1] is not None):
     |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1668 | 
     |

gal_friday/feature_engine.py:1667:104: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
     |
1665 |      valid_bids = True
1666 |      for i in range(levels):
1667 |          if not (isinstance(book["bids"][i], (list, tuple)) and len(book["bids"][i]) == 2 and book["bids"][i][1] is not None):
     |                                                                                          ^ PLR2004
1668 |              valid_bids = False; break
     |

gal_friday/feature_engine.py:1668:47: E702 Multiple statements on one line (semicolon)
     |
1666 |                     for i in range(levels):
1667 |                         if not (isinstance(book["bids"][i], (list, tuple)) and len(book["bids"][i]) == 2 and book["bids"][i][1] is n
1668 |                             valid_bids = False; break
     |                                               ^ E702
1669 |
1670 |                     valid_asks = True
     |

gal_friday/feature_engine.py:1672:33: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
     |
1670 |      valid_asks = True
1671 |      for i in range(levels):
1672 |          if not (isinstance(book["asks"][i], (list, tuple)) and len(book["asks"][i]) == 2 and book["asks"][i][1] is not None):
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
1673 |              valid_asks = False; break
     |
     = help: Convert to `X | Y`

gal_friday/feature_engine.py:1672:100: E501 Line too long (141 > 99)
     |
1670 | 
1671 | 
1672 | ], (list, tuple)) and len(book["asks"][i]) == 2 and book["asks"][i][1] is not None):
     |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1673 | 
     |

gal_friday/feature_engine.py:1672:104: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
     |
1670 |      valid_asks = True
1671 |      for i in range(levels):
1672 |          if not (isinstance(book["asks"][i], (list, tuple)) and len(book["asks"][i]) == 2 and book["asks"][i][1] is not None):
     |                                                                                          ^ PLR2004
1673 |              valid_asks = False; break
     |

gal_friday/feature_engine.py:1673:47: E702 Multiple statements on one line (semicolon)
     |
1671 |                     for i in range(levels):
1672 |                         if not (isinstance(book["asks"][i], (list, tuple)) and len(book["asks"][i]) == 2 and book["asks"][i][1] is n
1673 |                             valid_asks = False; break
     |                                               ^ E702
1674 |
1675 |                     if valid_bids and valid_asks:
     |

gal_friday/feature_engine.py:1676:100: E501 Line too long (104 > 99)
     |
1675 |                     if valid_bids and valid_asks:
1676 |                         bid_vol_at_levels = sum(Decimal(str(book["bids"][i][1])) for i in range(levels))
     |                                                                                                    ^^^^^ E501
1677 |                         ask_vol_at_levels = sum(Decimal(str(book["asks"][i][1])) for i in range(levels))
     |

gal_friday/feature_engine.py:1677:100: E501 Line too long (104 > 99)
     |
1675 |                     if valid_bids and valid_asks:
1676 |                         bid_vol_at_levels = sum(Decimal(str(book["bids"][i][1])) for i in range(levels))
1677 |                         ask_vol_at_levels = sum(Decimal(str(book["asks"][i][1])) for i in range(levels))
     |                                                                                                    ^^^^^ E501
1678 |
1679 |                         total_vol = bid_vol_at_levels + ask_vol_at_levels
     |

gal_friday/feature_engine.py:1685:100: E501 Line too long (101 > 99)
     |
1683 |                 # else: conditions for invalid book structure lead to default 0.0
1684 |             except (TypeError, IndexError, ValueError, AttributeError):
1685 |                 # Errors from malformed book data, missing keys, non-Decimal convertible strings etc.
     |                                                                                                    ^^ E501
1686 |                 pass # current_imbalance remains 0.0
     |

gal_friday/feature_engine.py:1698:9: D205 1 blank line required between summary line and description
     |
1696 |           levels: int = 1, # Typically levels=1 for WAP
1697 |       ) -> pd.Series:
1698 | /         """Computes Weighted Average Price (WAP) from a Series of L2 book snapshots.
1699 | |         Outputs a Series (float64).
1700 | |         If WAP cannot be calculated (e.g., invalid book, zero volume for top level),
1701 | |         it falls back to the corresponding ohlcv_close_prices.loc[index_of_l2_book_entry].
1702 | |         If fallback also fails or is not available, defaults to 0.0.
1703 | |         Intended for Scikit-learn FunctionTransformer.
1704 | |         """
     | |___________^ D205
1705 |           series_name = f"wap_{levels}"
1706 |           output_index = l2_books_series.index if isinstance(l2_books_series, pd.Series) else None
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1712:100: E501 Line too long (102 > 99)
     |
1710 |         waps = []
1711 |         for book_idx, book in l2_books_series.items():
1712 |             calculated_wap = np.nan # Initialize as NaN to indicate not yet calculated/fallback needed
     |                                                                                                    ^^^ E501
1713 |
1714 |             try:
     |

gal_friday/feature_engine.py:1715:100: E501 Line too long (107 > 99)
     |
1714 |             try:
1715 |                 # Validate book structure for the specified number of levels (here, only top level for WAP)
     |                                                                                                    ^^^^^^^^ E501
1716 |                 if book and \
1717 |                    isinstance(book.get("bids"), list) and len(book["bids"]) >= levels and \
     |

gal_friday/feature_engine.py:1718:20: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
     |
1716 |                 if book and \
1717 |                    isinstance(book.get("bids"), list) and len(book["bids"]) >= levels and \
1718 |                    isinstance(book["bids"][levels-1], (list, tuple)) and len(book["bids"][levels-1]) == 2 and \
     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
1719 |                    isinstance(book.get("asks"), list) and len(book["asks"]) >= levels and \
1720 |                    isinstance(book["asks"][levels-1], (list, tuple)) and len(book["asks"][levels-1]) == 2:
     |
     = help: Convert to `X | Y`

gal_friday/feature_engine.py:1718:100: E501 Line too long (111 > 99)
     |
1716 |                 if book and \
1717 |                    isinstance(book.get("bids"), list) and len(book["bids"]) >= levels and \
1718 |                    isinstance(book["bids"][levels-1], (list, tuple)) and len(book["bids"][levels-1]) == 2 and \
     |                                                                                                    ^^^^^^^^^^^^ E501
1719 |                    isinstance(book.get("asks"), list) and len(book["asks"]) >= levels and \
1720 |                    isinstance(book["asks"][levels-1], (list, tuple)) and len(book["asks"][levels-1]) == 2:
     |

gal_friday/feature_engine.py:1718:105: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
     |
1716 |                 if book and \
1717 |                    isinstance(book.get("bids"), list) and len(book["bids"]) >= levels and \
1718 |                    isinstance(book["bids"][levels-1], (list, tuple)) and len(book["bids"][levels-1]) == 2 and \
     |                                                                                                         ^ PLR2004
1719 |                    isinstance(book.get("asks"), list) and len(book["asks"]) >= levels and \
1720 |                    isinstance(book["asks"][levels-1], (list, tuple)) and len(book["asks"][levels-1]) == 2:
     |

gal_friday/feature_engine.py:1720:20: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
     |
1718 |                    isinstance(book["bids"][levels-1], (list, tuple)) and len(book["bids"][levels-1]) == 2 and \
1719 |                    isinstance(book.get("asks"), list) and len(book["asks"]) >= levels and \
1720 |                    isinstance(book["asks"][levels-1], (list, tuple)) and len(book["asks"][levels-1]) == 2:
     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
1721 |
1722 |                     # For WAP, typically levels=1, so we use index 0
     |
     = help: Convert to `X | Y`

gal_friday/feature_engine.py:1720:100: E501 Line too long (106 > 99)
     |
1718 |                    isinstance(book["bids"][levels-1], (list, tuple)) and len(book["bids"][levels-1]) == 2 and \
1719 |                    isinstance(book.get("asks"), list) and len(book["asks"]) >= levels and \
1720 |                    isinstance(book["asks"][levels-1], (list, tuple)) and len(book["asks"][levels-1]) == 2:
     |                                                                                                    ^^^^^^^ E501
1721 |
1722 |                     # For WAP, typically levels=1, so we use index 0
     |

gal_friday/feature_engine.py:1720:105: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
     |
1718 |                    isinstance(book["bids"][levels-1], (list, tuple)) and len(book["bids"][levels-1]) == 2 and \
1719 |                    isinstance(book.get("asks"), list) and len(book["asks"]) >= levels and \
1720 |                    isinstance(book["asks"][levels-1], (list, tuple)) and len(book["asks"][levels-1]) == 2:
     |                                                                                                         ^ PLR2004
1721 |
1722 |                     # For WAP, typically levels=1, so we use index 0
     |

gal_friday/feature_engine.py:1728:100: E501 Line too long (109 > 99)
     |
1726 |                     best_ask_vol_str = str(book["asks"][0][1])
1727 |
1728 |                     if not all([best_bid_price_str, best_bid_vol_str, best_ask_price_str, best_ask_vol_str]):
     |                                                                                                    ^^^^^^^^^^ E501
1729 |                         raise ValueError("Empty price or volume string encountered.")
     |

gal_friday/feature_engine.py:1738:100: E501 Line too long (113 > 99)
     |
1736 |                     total_vol = best_bid_vol + best_ask_vol
1737 |                     if total_vol > Decimal("0"):
1738 |                         wap_decimal = (best_bid_price * best_ask_vol + best_ask_price * best_bid_vol) / total_vol
     |                                                                                                    ^^^^^^^^^^^^^^ E501
1739 |                         calculated_wap = float(wap_decimal)
1740 |                 # else: conditions for invalid book structure, calculated_wap remains np.nan
     |

gal_friday/feature_engine.py:1742:100: E501 Line too long (102 > 99)
     |
1740 |                 # else: conditions for invalid book structure, calculated_wap remains np.nan
1741 |             except (TypeError, IndexError, ValueError, AttributeError):
1742 |                 # Errors from malformed book data, missing keys, non-Decimal convertible strings, etc.
     |                                                                                                    ^^^ E501
1743 |                 # calculated_wap remains np.nan
1744 |                 pass
     |

gal_friday/feature_engine.py:1764:9: D205 1 blank line required between summary line and description
     |
1762 |       @staticmethod
1763 |       def _pipeline_compute_l2_depth(l2_books_series: pd.Series, levels: int = 5) -> pd.DataFrame:
1764 | /         """Computes bid and ask depth from a Series of L2 book snapshots.
1765 | |         Outputs a DataFrame with 'bid_depth_{levels}' and 'ask_depth_{levels}' (float64).
1766 | |         If L2 book is None, empty, or levels are malformed, outputs 0.0 for depths.
1767 | |         Intended for Scikit-learn FunctionTransformer.
1768 | |         """
     | |___________^ D205
1769 |           bid_depths = []
1770 |           ask_depths = []
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1788:33: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
     |
1786 |      valid_bids = True
1787 |      for i in range(levels):
1788 |          if not (isinstance(book["bids"][i], (list, tuple)) and len(book["bids"][i]) == 2 and book["bids"][i][1] is not None):
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
1789 |              valid_bids = False; break
     |
     = help: Convert to `X | Y`

gal_friday/feature_engine.py:1788:100: E501 Line too long (141 > 99)
     |
1786 | 
1787 | 
1788 | ], (list, tuple)) and len(book["bids"][i]) == 2 and book["bids"][i][1] is not None):
     |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1789 | 
     |

gal_friday/feature_engine.py:1788:104: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
     |
1786 |      valid_bids = True
1787 |      for i in range(levels):
1788 |          if not (isinstance(book["bids"][i], (list, tuple)) and len(book["bids"][i]) == 2 and book["bids"][i][1] is not None):
     |                                                                                          ^ PLR2004
1789 |              valid_bids = False; break
     |

gal_friday/feature_engine.py:1789:47: E702 Multiple statements on one line (semicolon)
     |
1787 |                     for i in range(levels):
1788 |                         if not (isinstance(book["bids"][i], (list, tuple)) and len(book["bids"][i]) == 2 and book["bids"][i][1] is n
1789 |                             valid_bids = False; break
     |                                               ^ E702
1790 |
1791 |                     valid_asks = True
     |

gal_friday/feature_engine.py:1793:33: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
     |
1791 |      valid_asks = True
1792 |      for i in range(levels):
1793 |          if not (isinstance(book["asks"][i], (list, tuple)) and len(book["asks"][i]) == 2 and book["asks"][i][1] is not None):
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
1794 |              valid_asks = False; break
     |
     = help: Convert to `X | Y`

gal_friday/feature_engine.py:1793:100: E501 Line too long (141 > 99)
     |
1791 | 
1792 | 
1793 | ], (list, tuple)) and len(book["asks"][i]) == 2 and book["asks"][i][1] is not None):
     |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1794 | 
     |

gal_friday/feature_engine.py:1793:104: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
     |
1791 |      valid_asks = True
1792 |      for i in range(levels):
1793 |          if not (isinstance(book["asks"][i], (list, tuple)) and len(book["asks"][i]) == 2 and book["asks"][i][1] is not None):
     |                                                                                          ^ PLR2004
1794 |              valid_asks = False; break
     |

gal_friday/feature_engine.py:1794:47: E702 Multiple statements on one line (semicolon)
     |
1792 |                     for i in range(levels):
1793 |                         if not (isinstance(book["asks"][i], (list, tuple)) and len(book["asks"][i]) == 2 and book["asks"][i][1] is n
1794 |                             valid_asks = False; break
     |                                               ^ E702
1795 |
1796 |                     if valid_bids and valid_asks:
     |

gal_friday/feature_engine.py:1797:100: E501 Line too long (100 > 99)
     |
1796 |                     if valid_bids and valid_asks:
1797 |                         bid_depth_val = sum(Decimal(str(book["bids"][i][1])) for i in range(levels))
     |                                                                                                    ^ E501
1798 |                         ask_depth_val = sum(Decimal(str(book["asks"][i][1])) for i in range(levels))
1799 |                         current_bid_depth = float(bid_depth_val)
     |

gal_friday/feature_engine.py:1798:100: E501 Line too long (100 > 99)
     |
1796 |                     if valid_bids and valid_asks:
1797 |                         bid_depth_val = sum(Decimal(str(book["bids"][i][1])) for i in range(levels))
1798 |                         ask_depth_val = sum(Decimal(str(book["asks"][i][1])) for i in range(levels))
     |                                                                                                    ^ E501
1799 |                         current_bid_depth = float(bid_depth_val)
1800 |                         current_ask_depth = float(ask_depth_val)
     |

gal_friday/feature_engine.py:1803:100: E501 Line too long (102 > 99)
     |
1801 |                 # else: conditions for invalid book structure lead to default 0.0
1802 |             except (TypeError, IndexError, ValueError, AttributeError):
1803 |                  # Errors from malformed book data, missing keys, non-Decimal convertible strings etc.
     |                                                                                                    ^^^ E501
1804 |                 pass # current_bid_depth and current_ask_depth remain 0.0
     |

gal_friday/feature_engine.py:1813:16: RET504 Unnecessary assignment to `df` before `return` statement
     |
1811 |             col_name_ask: ask_depths,
1812 |         }, index=output_index, dtype="float64")
1813 |         return df
     |                ^^ RET504
1814 |
1815 |     @staticmethod
     |
     = help: Remove unnecessary assignment

gal_friday/feature_engine.py:1820:100: E501 Line too long (122 > 99)
     |
1818 |         bar_start_times: pd.Series, # Series of bar start datetime objects
1819 |         bar_interval_seconds: int,
1820 |         ohlcv_close_prices: pd.Series | None = None, # Added for signature consistency, not used by this specific function
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^ E501
1821 |     ) -> pd.Series:
1822 |         """Computes Volume Delta from trade data for specified bar start times.
     |

gal_friday/feature_engine.py:1822:9: D205 1 blank line required between summary line and description
     |
1820 |           ohlcv_close_prices: pd.Series | None = None, # Added for signature consistency, not used by this specific function
1821 |       ) -> pd.Series:
1822 | /         """Computes Volume Delta from trade data for specified bar start times.
1823 | |         If no trades for a bar, delta is 0.0.
1824 | |         Outputs a Series (float64).
1825 | |         Intended for Scikit-learn FunctionTransformer.
1826 | |         """
     | |___________^ D205
1827 |           deltas = []
1828 |           series_name = f"volume_delta_{bar_interval_seconds}s"
     |
     = help: Insert single blank line

gal_friday/feature_engine.py:1829:100: E501 Line too long (100 > 99)
     |
1827 |      deltas = []
1828 |      series_name = f"volume_delta_{bar_interval_seconds}s"
1829 |      if not isinstance(bar_start_times, pd.Series) or not isinstance(trade_history_deque, deque):
     |                                                                                                  ^ E501
1830 |          return pd.Series(dtype="float64", index=bar_start_times.index if isinstance(bar_start_times, pd.Series) else None, name=se
     |

gal_friday/feature_engine.py:1830:100: E501 Line too long (144 > 99)
     |
1828 | s"
1829 | t isinstance(trade_history_deque, deque):
1830 | rt_times.index if isinstance(bar_start_times, pd.Series) else None, name=series_name)
     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1831 | 
1832 | istory
     |

gal_friday/feature_engine.py:1858:100: E501 Line too long (124 > 99)
     |
1856 |             deltas.append(float(buy_volume - sell_volume))
1857 |
1858 |         return pd.Series(deltas, index=bar_start_times.index, dtype="float64", name=f"volume_delta_{bar_interval_seconds}s")
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
     |

gal_friday/feature_engine.py:1865:100: E501 Line too long (114 > 99)
     |
1863 |     # Note: _calculate_vwap and _calculate_vwap_from_trades removed.
1864 |     # --- Removed _calculate_roc, _calculate_atr, _calculate_stdev ---
1865 |     # --- Removed _calculate_bid_ask_spread, _calculate_order_book_imbalance, _calculate_wap, _calculate_depth ---
     |                                                                                                    ^^^^^^^^^^^^^^^ E501
1866 |         # --- Removed _calculate_true_volume_delta_from_trades, _calculate_vwap_from_trades ---
     |

gal_friday/feature_engine.py:1869:15: C901 `_calculate_and_publish_features` is too complex (32 > 15)
     |
1869 |     async def _calculate_and_publish_features(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
1870 |         self,
1871 |         trading_pair: str,
     |

gal_friday/feature_engine.py:1869:15: PLR0912 Too many branches (39 > 12)
     |
1869 |     async def _calculate_and_publish_features(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
1870 |         self,
1871 |         trading_pair: str,
     |

gal_friday/feature_engine.py:1869:15: PLR0915 Too many statements (111 > 50)
     |
1869 |     async def _calculate_and_publish_features(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0915
1870 |         self,
1871 |         trading_pair: str,
     |

gal_friday/feature_engine.py:1905:100: E501 Line too long (107 > 99)
     |
1903 |         # Filter OHLCV data up to the current bar's start time for historical context
1904 |         # Pipelines will internally select the latest point after calculation over history.
1905 |         current_ohlcv_df_decimal = ohlcv_df_full_history[ohlcv_df_full_history.index <= bar_start_datetime]
     |                                                                                                    ^^^^^^^^ E501
1906 |
1907 |         if current_ohlcv_df_decimal.empty:
     |

gal_friday/feature_engine.py:1908:100: E501 Line too long (120 > 99)
     |
1907 |         if current_ohlcv_df_decimal.empty:
1908 |             self.logger.warning("No historical OHLCV data available for %s up to %s.", trading_pair, bar_start_datetime)
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^ E501
1909 |             return # Cannot proceed without data for this timestamp
     |

gal_friday/feature_engine.py:1920:100: E501 Line too long (106 > 99)
     |
1919 |         # L2 book snapshot for the current bar
1920 |         # Assuming self.l2_books[trading_pair] holds the latest book, or one aligned by a separate process
     |                                                                                                    ^^^^^^^ E501
1921 |         # For pipeline processing, we need a Series (even if single-element)
1922 |         latest_l2_book_snapshot = self.l2_books.get(trading_pair) # This is the overall latest
     |

gal_friday/feature_engine.py:1931:100: E501 Line too long (108 > 99)
     |
1929 |         bar_start_times_series = pd.Series([bar_start_datetime], index=[bar_start_datetime])
1930 |
1931 |         # Prepare the single close price for the current bar, aligned to its timestamp for dynamic injection
     |                                                                                                    ^^^^^^^^^ E501
1932 |         # This Series will have one entry: index=bar_start_datetime, value=close_price_at_bar_start_datetime
1933 |         ohlcv_close_for_dynamic_injection = None
     |

gal_friday/feature_engine.py:1932:100: E501 Line too long (108 > 99)
     |
1931 |         # Prepare the single close price for the current bar, aligned to its timestamp for dynamic injection
1932 |         # This Series will have one entry: index=bar_start_datetime, value=close_price_at_bar_start_datetime
     |                                                                                                    ^^^^^^^^^ E501
1933 |         ohlcv_close_for_dynamic_injection = None
1934 |         if bar_start_datetime in close_series_for_pipelines.index:
     |

gal_friday/feature_engine.py:1935:100: E501 Line too long (100 > 99)
     |
1933 |         ohlcv_close_for_dynamic_injection = None
1934 |         if bar_start_datetime in close_series_for_pipelines.index:
1935 |             ohlcv_close_for_dynamic_injection = close_series_for_pipelines.loc[[bar_start_datetime]]
     |                                                                                                    ^ E501
1936 |         else:
1937 |             self.logger.warning(
     |

gal_friday/feature_engine.py:1938:100: E501 Line too long (136 > 99)
     |
1936 | 
1937 | 
1938 |  bar %s in historical data. Features needing this fallback may fail or use 0.0.",
     |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1939 | 
1940 | 
     |

gal_friday/feature_engine.py:1941:100: E501 Line too long (103 > 99)
     |
1939 |                 bar_start_datetime,
1940 |             )
1941 |             # Create an empty series with the right index to prevent downstream errors if it's expected
     |                                                                                                    ^^^^ E501
1942 |             ohlcv_close_for_dynamic_injection = pd.Series(dtype="float64", index=[bar_start_datetime])
     |

gal_friday/feature_engine.py:1942:100: E501 Line too long (102 > 99)
     |
1940 |             )
1941 |             # Create an empty series with the right index to prevent downstream errors if it's expected
1942 |             ohlcv_close_for_dynamic_injection = pd.Series(dtype="float64", index=[bar_start_datetime])
     |                                                                                                    ^^^ E501
     |

gal_friday/feature_engine.py:1958:100: E501 Line too long (103 > 99)
     |
1956 |                 pipeline_input_data = ohlcv_df_for_pipelines
1957 |             elif spec.input_type == "l2_book_series":
1958 |                 pipeline_input_data = l2_books_aligned_series # Single latest book snapshot in a Series
     |                                                                                                    ^^^^ E501
1959 |             elif spec.input_type == "trades_and_bar_starts":
1960 |                 # For these, X is the trade_history_deque. bar_start_times is injected dynamically.
     |

gal_friday/feature_engine.py:1963:100: E501 Line too long (121 > 99)
     |
1961 |                 pipeline_input_data = trades_deque
1962 |             else:
1963 |                 self.logger.warning("Unknown input_type '%s' for pipeline %s. Skipping.", spec.input_type, pipeline_name)
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
1964 |                 continue
     |

gal_friday/feature_engine.py:1979:100: E501 Line too long (121 > 99)
     |
1978 |                         # Inject ohlcv_close_prices (aligned to the specific input type's index)
1979 |                         if ohlcv_close_for_dynamic_injection is not None and not ohlcv_close_for_dynamic_injection.empty:
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
1980 |                             current_kw_args["ohlcv_close_prices"] = ohlcv_close_for_dynamic_injection
1981 |                         else: # Pass None or an empty series if not available, function should handle it
     |

gal_friday/feature_engine.py:1980:100: E501 Line too long (101 > 99)
     |
1978 |                         # Inject ohlcv_close_prices (aligned to the specific input type's index)
1979 |                         if ohlcv_close_for_dynamic_injection is not None and not ohlcv_close_for_dynamic_injection.empty:
1980 |                             current_kw_args["ohlcv_close_prices"] = ohlcv_close_for_dynamic_injection
     |                                                                                                    ^^ E501
1981 |                         else: # Pass None or an empty series if not available, function should handle it
1982 |                             current_kw_args["ohlcv_close_prices"] = pd.Series(dtype="float64", index=[bar_start_datetime])
     |

gal_friday/feature_engine.py:1981:100: E501 Line too long (104 > 99)
     |
1979 |                         if ohlcv_close_for_dynamic_injection is not None and not ohlcv_close_for_dynamic_injection.empty:
1980 |                             current_kw_args["ohlcv_close_prices"] = ohlcv_close_for_dynamic_injection
1981 |                         else: # Pass None or an empty series if not available, function should handle it
     |                                                                                                    ^^^^^ E501
1982 |                             current_kw_args["ohlcv_close_prices"] = pd.Series(dtype="float64", index=[bar_start_datetime])
     |

gal_friday/feature_engine.py:1982:100: E501 Line too long (122 > 99)
     |
1980 |                             current_kw_args["ohlcv_close_prices"] = ohlcv_close_for_dynamic_injection
1981 |                         else: # Pass None or an empty series if not available, function should handle it
1982 |                             current_kw_args["ohlcv_close_prices"] = pd.Series(dtype="float64", index=[bar_start_datetime])
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^ E501
     |

gal_friday/feature_engine.py:1991:100: E501 Line too long (156 > 99)
     |
1989 | kw_args
1990 | 
1991 |  found in cloned pipeline %s. Skipping dynamic args.", calculator_step_name, pipeline_name)
     |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1992 | 
1993 | dified)
     |

gal_friday/feature_engine.py:1998:100: E501 Line too long (113 > 99)
     |
1996 |                 else:
1997 |                     # This case should ideally be caught by input_type checks or earlier validation
1998 |                     self.logger.warning("Pipeline input data is None for %s. Skipping execution.", pipeline_name)
     |                                                                                                    ^^^^^^^^^^^^^^ E501
1999 |                     continue # Skip to next pipeline if input data is None
     |

gal_friday/feature_engine.py:2011:100: E501 Line too long (149 > 99)
     |
2009 | 
2010 | 
2011 | s", "trades_and_bar_starts"] or len(raw_pipeline_output) > 1 : # If it processed history
     |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
2012 | _output.iloc[-1]
2013 | ue for the current bar
     |

gal_friday/feature_engine.py:2014:100: E501 Line too long (121 > 99)
     |
2012 |                         latest_features_values = raw_pipeline_output.iloc[-1]
2013 |                     else: # Already the single calculated value for the current bar
2014 |                         latest_features_values = raw_pipeline_output.iloc[0] if len(raw_pipeline_output) == 1 else np.nan
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
2015 |             elif isinstance(raw_pipeline_output, pd.DataFrame):
2016 |                 if not raw_pipeline_output.empty:
     |

gal_friday/feature_engine.py:2017:100: E501 Line too long (123 > 99)
     |
2015 |             elif isinstance(raw_pipeline_output, pd.DataFrame):
2016 |                 if not raw_pipeline_output.empty:
2017 |                     if spec.input_type not in ["l2_book_series"] or len(raw_pipeline_output) > 1: # If it processed history
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
2018 |                         latest_features_values = raw_pipeline_output.iloc[-1] # This gives a Series (one row)
2019 |                     else: # Already the single calculated row for the current bar
     |

gal_friday/feature_engine.py:2018:100: E501 Line too long (109 > 99)
     |
2016 |      if not raw_pipeline_output.empty:
2017 |          if spec.input_type not in ["l2_book_series"] or len(raw_pipeline_output) > 1: # If it processed history
2018 |              latest_features_values = raw_pipeline_output.iloc[-1] # This gives a Series (one row)
     |                                                                                          ^^^^^^^^^^ E501
2019 |          else: # Already the single calculated row for the current bar
2020 |              latest_features_values = raw_pipeline_output.iloc[0] if len(raw_pipeline_output) == 1 else pd.Series(dtype="float64")
     |

gal_friday/feature_engine.py:2020:100: E501 Line too long (141 > 99)
     |
2018 | line_output.iloc[-1] # This gives a Series (one row)
2019 |  row for the current bar
2020 | line_output.iloc[0] if len(raw_pipeline_output) == 1 else pd.Series(dtype="float64")
     |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
2021 | ay): # Should be rare due to PandasScalerTransformer
2022 | _pipeline_output.size > 0:
     |

gal_friday/feature_engine.py:2021:100: E501 Line too long (109 > 99)
     |
2019 |              else: # Already the single calculated row for the current bar
2020 |                  latest_features_values = raw_pipeline_output.iloc[0] if len(raw_pipeline_output) == 1 else pd.Series(dtype="float6
2021 |      elif isinstance(raw_pipeline_output, np.ndarray): # Should be rare due to PandasScalerTransformer
     |                                                                                              ^^^^^^^^^^ E501
2022 |           if raw_pipeline_output.ndim == 1 and raw_pipeline_output.size > 0:
2023 |              latest_features_values = raw_pipeline_output[-1]
     |

gal_friday/feature_engine.py:2024:51: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
     |
2022 |                  if raw_pipeline_output.ndim == 1 and raw_pipeline_output.size > 0:
2023 |                     latest_features_values = raw_pipeline_output[-1]
2024 |                  elif raw_pipeline_output.ndim == 2 and raw_pipeline_output.shape[0] > 0:
     |                                                   ^ PLR2004
2025 |                     latest_features_values = pd.Series(raw_pipeline_output[-1, :]) # Convert row to series
2026 |             else: # scalar float, e.g. if pipeline output was just one value
     |

gal_friday/feature_engine.py:2025:100: E501 Line too long (106 > 99)
     |
2023 |                     latest_features_values = raw_pipeline_output[-1]
2024 |                  elif raw_pipeline_output.ndim == 2 and raw_pipeline_output.shape[0] > 0:
2025 |                     latest_features_values = pd.Series(raw_pipeline_output[-1, :]) # Convert row to series
     |                                                                                                    ^^^^^^^ E501
2026 |             else: # scalar float, e.g. if pipeline output was just one value
2027 |                 latest_features_values = raw_pipeline_output
     |

gal_friday/feature_engine.py:2032:100: E501 Line too long (113 > 99)
     |
2030 |             if isinstance(latest_features_values, pd.Series):
2031 |                 for idx_name, value in latest_features_values.items():
2032 |                     # Construct a unique feature name, e.g. from pipeline_name and sub-feature name (column name)
     |                                                                                                    ^^^^^^^^^^^^^^ E501
2033 |                     # Ensure idx_name (column from DataFrame) is a string
2034 |                     col_name = str(idx_name)
     |

gal_friday/feature_engine.py:2040:100: E501 Line too long (102 > 99)
     |
2038 |                     # For now: pipeline_name (which is feature_key_pipeline) + column name
2039 |                     base_feature_key = pipeline_name.replace("_pipeline","")
2040 |                     # If pipeline_name was "macd_12_26_9_pipeline", base_feature_key is "macd_12_26_9"
     |                                                                                                    ^^^ E501
2041 |                     # col_name could be "MACD_12_26_9", "MACDh_12_26_9", "MACDs_12_26_9"
2042 |                     # A better way for naming is to use the original feature_key from config and the column name.
     |

gal_friday/feature_engine.py:2042:100: E501 Line too long (113 > 99)
     |
2040 |                     # If pipeline_name was "macd_12_26_9_pipeline", base_feature_key is "macd_12_26_9"
2041 |                     # col_name could be "MACD_12_26_9", "MACDh_12_26_9", "MACDs_12_26_9"
2042 |                     # A better way for naming is to use the original feature_key from config and the column name.
     |                                                                                                    ^^^^^^^^^^^^^^ E501
2043 |                     # original_feature_config_key = pipeline_info['params'].get('original_key', base_feature_key)
     |

gal_friday/feature_engine.py:2043:100: E501 Line too long (113 > 99)
     |
2041 |                     # col_name could be "MACD_12_26_9", "MACDh_12_26_9", "MACDs_12_26_9"
2042 |                     # A better way for naming is to use the original feature_key from config and the column name.
2043 |                     # original_feature_config_key = pipeline_info['params'].get('original_key', base_feature_key)
     |                                                                                                    ^^^^^^^^^^^^^^ E501
2044 |
2045 |                     # Simplified naming: {original_feature_key}_{column_suffix}
     |

gal_friday/feature_engine.py:2046:100: E501 Line too long (125 > 99)
     |
2045 |                     # Simplified naming: {original_feature_key}_{column_suffix}
2046 |                     # Example: feature_key = "macd_config_name", col_name = "MACD_12_26_9" -> "macd_config_name_MACD_12_26_9"
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
2047 |                     # Or, if col_name is like "lowerband", "upperband" from bbands.
2048 |                     feature_output_name = f"{base_feature_key}_{col_name}"
     |

gal_friday/feature_engine.py:2059:100: E501 Line too long (112 > 99)
     |
2057 |             # Ensure all_generated_features contains float values, not Decimals or other types
2058 |             # Most pipeline steps should output float64, but final check can be useful.
2059 |             float_features = {k: float(v) if pd.notna(v) else np.nan for k, v in all_generated_features.items()}
     |                                                                                                    ^^^^^^^^^^^^^ E501
2060 |
2061 |             # Filter out NaNs before passing to Pydantic if model fields are not Optional
     |

gal_friday/feature_engine.py:2062:100: E501 Line too long (113 > 99)
     |
2061 |             # Filter out NaNs before passing to Pydantic if model fields are not Optional
2062 |             # Or ensure Pydantic model fields are Optional if NaNs are possible and mean "feature not applicable"
     |                                                                                                    ^^^^^^^^^^^^^^ E501
2063 |             # For now, assuming Pydantic model fields are non-Optional floats.
2064 |             # If a feature is NaN, it means it couldn't be calculated; this should be handled.
     |

gal_friday/feature_engine.py:2072:100: E501 Line too long (102 > 99)
     |
2070 |             # If a feature calculation results in NaN, it might indicate an issue.
2071 |             # For now, we will attempt to pass them and let Pydantic validate.
2072 |             # If Pydantic fields are not Optional, NaNs will cause errors if not converted or handled.
     |                                                                                                    ^^^ E501
2073 |             # The current Pydantic model has non-optional float fields.
2074 |             # So, if any value in float_features is NaN, Pydantic validation will fail.
     |

gal_friday/feature_engine.py:2075:100: E501 Line too long (127 > 99)
     |
2073 |             # The current Pydantic model has non-optional float fields.
2074 |             # So, if any value in float_features is NaN, Pydantic validation will fail.
2075 |             # This is a design choice: either features must always be valid floats, or Pydantic model must use Optional[float].
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
2076 |             # Given "Zero NaN" policy, we expect valid floats.
2077 |             # If a feature is missing from all_generated_features, Pydantic will also complain.
     |

gal_friday/feature_engine.py:2084:100: E501 Line too long (115 > 99)
     |
2082 |         except Exception as e: # Catch Pydantic ValidationError or other issues
2083 |             self.logger.error(
2084 |                 "Failed to validate or structure features using Pydantic model for %s at %s: %s. Raw features: %s",
     |                                                                                                    ^^^^^^^^^^^^^^^^ E501
2085 |                 trading_pair,
2086 |                 timestamp_features_for,
     |

gal_friday/feature_engine.py:2095:100: E501 Line too long (150 > 99)
     |
2093 | uilt (mostly for transition)
2094 | load:
2095 | ng feature calculation with remaining old handlers.", source_module=self._source_module)
     |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
2096 | t it's mostly empty now) ...
     |

gal_friday/feature_engine.py:2101:100: E501 Line too long (108 > 99)
     |
2099 |         if not features_for_payload: # Check if any features were produced
2100 |             self.logger.info(
2101 |                 "No features were successfully structured or validated for %s at %s. Not publishing event.",
     |                                                                                                    ^^^^^^^^^ E501
2102 |                 trading_pair,
2103 |                 timestamp_features_for, # This was timestamp_features_for
     |

gal_friday/feature_engine.py:2157:100: E501 Line too long (113 > 99)
     |
2155 |     # as their logic will be incorporated into the new pipeline-based feature generation.
2156 |     # Other _process_* methods will be updated or replaced in subsequent steps.
2157 |     # --- Removed _process_bbands_feature, _process_roc_feature, _process_atr_feature, _process_stdev_feature ---
     |                                                                                                    ^^^^^^^^^^^^^^ E501
2158 |     # --- Removed _process_vwap_feature ---
2159 |     # --- Removed _process_roc_feature, _process_atr_feature, _process_stdev_feature ---
     |

gal_friday/feature_engine.py:2160:100: E501 Line too long (104 > 99)
     |
2158 |     # --- Removed _process_vwap_feature ---
2159 |     # --- Removed _process_roc_feature, _process_atr_feature, _process_stdev_feature ---
2160 |     # --- Removed _process_l2_spread_feature, _process_l2_imbalance_feature, _process_l2_wap_feature ---
     |                                                                                                    ^^^^^ E501
2161 |     # --- Removed _process_l2_depth_feature, _process_volume_delta_feature ---
     |

gal_friday/interfaces/execution_handler_interface.py:144:7: D101 Missing docstring in public class
    |
144 | class ExecutionHandlerKwargs(TypedDict, total=False):
    |       ^^^^^^^^^^^^^^^^^^^^^^ D101
145 |     # This TypedDict is initially empty or can include common keys
146 |     # if they are known. `total=False` makes all keys optional.
    |

gal_friday/interfaces/strategy_interface.py:263:100: E501 Line too long (126 > 99)
    |
261 |         # Portfolio-specific validation
262 |         if action.action_type in [ActionType.SELL, ActionType.CLOSE_LONG]:
263 |             asset_spec_or_default_dict: AssetSpecification | dict[str, Any] = self.asset_specifications.get(action.symbol, {})
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
264 |             if isinstance(asset_spec_or_default_dict, dict):
265 |                 current_position = asset_spec_or_default_dict.get("position", 0)
    |

gal_friday/kraken_historical_data_service.py:885:1: W293 Blank line contains whitespace
    |
883 |     ) -> list[dict[str, Any]] | None:
884 |         """Fetch historical trade data from Kraken.
885 |         
    | ^^^^^^^^ W293
886 |         Args:
887 |             trading_pair: Trading pair (e.g., "XRP/USD")
    |
    = help: Remove whitespace from blank line

gal_friday/kraken_historical_data_service.py:891:1: W293 Blank line contains whitespace
    |
889 |             until: End time (exclusive)
890 |             limit: Maximum number of trades to fetch
891 |             
    | ^^^^^^^^^^^^ W293
892 |         Returns:
893 |             List of trade dictionaries or None on error
    |
    = help: Remove whitespace from blank line

gal_friday/kraken_historical_data_service.py:926:100: E501 Line too long (101 > 99)
    |
924 |                 if not result or result.get("error"):
925 |                     self.logger.error(
926 |                         f"Error fetching trades: {result.get('error') if result else 'No response'}",
    |                                                                                                    ^^ E501
927 |                         source_module=self._source_module,
928 |                     )
    |

gal_friday/kraken_historical_data_service.py:949:58: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
947 |                         "side": "buy" if trade[3] == "b" else "sell",
948 |                         "order_type": "market" if trade[4] == "m" else "limit",
949 |                         "misc": trade[5] if len(trade) > 5 else "",
    |                                                          ^ PLR2004
950 |                     }
    |

gal_friday/kraken_historical_data_service.py:992:1: W293 Blank line contains whitespace
    |
990 |     ) -> dict[str, Any] | None:
991 |         """Make a public API request to Kraken.
992 |         
    | ^^^^^^^^ W293
993 |         Args:
994 |             endpoint: API endpoint
    |
    = help: Remove whitespace from blank line

gal_friday/kraken_historical_data_service.py:996:1: W293 Blank line contains whitespace
    |
994 |             endpoint: API endpoint
995 |             params: Request parameters
996 |             
    | ^^^^^^^^^^^^ W293
997 |         Returns:
998 |             API response or None on error
    |
    = help: Remove whitespace from blank line

gal_friday/kraken_historical_data_service.py:1003:13: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
     |
1001 |               url = f"{self.api_base_url}{endpoint}"
1002 |
1003 | /             async with aiohttp.ClientSession() as session:
1004 | |                 async with session.get(url, params=params) as response:
     | |_______________________________________________________________________^ SIM117
1005 |                       if response.status != 200:
1006 |                           self.logger.error(
     |
     = help: Combine `with` statements

gal_friday/kraken_historical_data_service.py:1005:43: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
     |
1003 |             async with aiohttp.ClientSession() as session:
1004 |                 async with session.get(url, params=params) as response:
1005 |                     if response.status != 200:
     |                                           ^^^ PLR2004
1006 |                         self.logger.error(
1007 |                             f"API request failed with status {response.status}",
     |

gal_friday/kraken_historical_data_service.py:1024:1: W293 Blank line contains whitespace
     |
1022 |     def _get_kraken_pair_name(self, trading_pair: str) -> str | None:
1023 |         """Convert internal pair format to Kraken format.
1024 |         
     | ^^^^^^^^ W293
1025 |         Args:
1026 |             trading_pair: Internal format (e.g., "XRP/USD")
     |
     = help: Remove whitespace from blank line

gal_friday/kraken_historical_data_service.py:1027:1: W293 Blank line contains whitespace
     |
1025 |         Args:
1026 |             trading_pair: Internal format (e.g., "XRP/USD")
1027 |             
     | ^^^^^^^^^^^^ W293
1028 |         Returns:
1029 |             Kraken format (e.g., "XXRPZUSD") or None if not found
     |
     = help: Remove whitespace from blank line

gal_friday/logger_service.py:91:100: E501 Line too long (123 > 99)
   |
89 | # Define a type alias for exc_info to improve readability and manage line length
90 | # Moved to module level and updated to use Union, Tuple
91 | ExcInfoType: TypingTypeAlias = bool | tuple[type[BaseException], BaseException, types.TracebackType] | BaseException | None
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
92 |
93 | # Define a Protocol for ConfigManager to properly type hint its interface
   |

gal_friday/logger_service.py:201:100: E501 Line too long (101 > 99)
    |
199 |         # the output of what %(context)s produced.
200 |         context_str = ""
201 |         if hasattr(record, "context") and record.context: # record.context is now guaranteed to exist
    |                                                                                                    ^^ E501
202 |             if isinstance(record.context, dict):
203 |                 context_items = [f"{k}={v}" for k, v in record.context.items()]
    |

gal_friday/logger_service.py:228:100: E501 Line too long (102 > 99)
    |
226 |     """Asynchronous handler for logging to PostgreSQL database using SQLAlchemy."""
227 |
228 |     # ALLOWED_TABLE_NAMES might not be strictly necessary if we always log to the 'Log' model's table.
    |                                                                                                    ^^^ E501
229 |     # However, if the table name for the Log model can vary, this could be used for validation.
230 |     # For now, assuming Log model maps to 'logs' table.
    |

gal_friday/logger_service.py:233:100: E501 Line too long (113 > 99)
    |
231 |     # ALLOWED_TABLE_NAMES: ClassVar[set[str]] = {"logs"}
232 |
233 |     def __init__(self, session_maker: async_sessionmaker[AsyncSession], loop: asyncio.AbstractEventLoop) -> None:
    |                                                                                                    ^^^^^^^^^^^^^^ E501
234 |         """Initialize the handler with SQLAlchemy session maker and event loop.
    |

gal_friday/logger_service.py:280:16: SIM101 Multiple `isinstance` calls for expression, merge into a single call
    |
278 |         context_data = None # Changed from context_json
279 |         if hasattr(record, "context") and record.context:
280 |             if isinstance(record.context, dict) or isinstance(record.context, list):
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SIM101
281 |                 context_data = record.context # Keep as Python dict/list for SQLAlchemy
282 |             else:
    |
    = help: Merge `isinstance` calls

gal_friday/logger_service.py:327:13: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
    |
325 |               log_entry = Log(**record_data)
326 |
327 | /             async with self._session_maker() as session:
328 | |                 async with session.begin(): # Start a transaction
    | |___________________________________________^ SIM117
329 |                       session.add(log_entry)
330 |                   # Commit happens automatically with session.begin() context manager,
    |
    = help: Combine `with` statements

gal_friday/logger_service.py:395:100: E501 Line too long (101 > 99)
    |
393 |                     )
394 |                     await asyncio.sleep(wait_time)
395 |             except (RuntimeError, ValueError, TypeError, DatabaseError) as e: # General non-DB errors
    |                                                                                                    ^^ E501
396 |                 logging.getLogger(__name__).error(
397 |                     "AsyncPostgresHandler: Non-retryable error caught in _process_queue_with_retry for record: %s. Error: %s",
    |

gal_friday/logger_service.py:397:100: E501 Line too long (126 > 99)
    |
395 |             except (RuntimeError, ValueError, TypeError, DatabaseError) as e: # General non-DB errors
396 |                 logging.getLogger(__name__).error(
397 |                     "AsyncPostgresHandler: Non-retryable error caught in _process_queue_with_retry for record: %s. Error: %s",
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
398 |                     record_data.get("message", "N/A"), e, exc_info=True,
399 |                 )
    |

gal_friday/logger_service.py:442:100: E501 Line too long (108 > 99)
    |
440 |                  self.start_processing() # Try to start it if it never did
441 |
442 |             if self._loop and self._loop.is_running(): # Check if loop is available for call_soon_threadsafe
    |                                                                                                    ^^^^^^^^^ E501
443 |                  self._loop.call_soon_threadsafe(lambda: self._queue.put_nowait(None))
444 |             else: # Fallback if loop is closed, try to put directly (might fail if full)
    |

gal_friday/logger_service.py:448:100: E501 Line too long (130 > 99)
    |
446 |                     self._queue.put_nowait(None)
447 |                 except QueueFull:
448 |                     logging.getLogger(__name__).error("AsyncPostgresHandler: Queue full while trying to add sentinel in close().")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
449 |
450 |         super().close() # Calls Handler.close()
    |

gal_friday/logger_service.py:515:100: E501 Line too long (116 > 99)
    |
514 |         # Queue and thread for handling synchronous logging calls from async context
515 |         self._queue: queue.Queue[tuple[Callable[..., None], tuple, dict]] = queue.Queue() # Keep this for sync calls
    |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
516 |         self._thread = threading.Thread(target=self._process_log_queue, daemon=True)
517 |         self._stop_event = threading.Event()
    |

gal_friday/logger_service.py:611:100: E501 Line too long (103 > 99)
    |
609 |                         handler.close()
610 |                 # Re-run the DB handler part of _setup_logging logic
611 |                 db_table = str(self._config_manager.get("logging.database.table_name", default="logs"))
    |                                                                                                    ^^^^ E501
612 |                 if db_table != "logs": db_table = "logs" # Enforce
613 |                 db_level_str = str(self._config_manager.get("logging.database.level", default="INFO")).upper()
    |

gal_friday/logger_service.py:612:38: E701 Multiple statements on one line (colon)
    |
610 |                 # Re-run the DB handler part of _setup_logging logic
611 |                 db_table = str(self._config_manager.get("logging.database.table_name", default="logs"))
612 |                 if db_table != "logs": db_table = "logs" # Enforce
    |                                      ^ E701
613 |                 db_level_str = str(self._config_manager.get("logging.database.level", default="INFO")).upper()
614 |                 db_level = getattr(logging, db_level_str, logging.INFO)
    |

gal_friday/logger_service.py:613:100: E501 Line too long (110 > 99)
    |
611 |                 db_table = str(self._config_manager.get("logging.database.table_name", default="logs"))
612 |                 if db_table != "logs": db_table = "logs" # Enforce
613 |                 db_level_str = str(self._config_manager.get("logging.database.level", default="INFO")).upper()
    |                                                                                                    ^^^^^^^^^^^ E501
614 |                 db_level = getattr(logging, db_level_str, logging.INFO)
615 |                 try:
    |

gal_friday/logger_service.py:616:100: E501 Line too long (112 > 99)
    |
614 |                 db_level = getattr(logging, db_level_str, logging.INFO)
615 |                 try:
616 |                     self._async_handler = AsyncPostgresHandler(self._db_session_maker, asyncio.get_event_loop())
    |                                                                                                    ^^^^^^^^^^^^^ E501
617 |                     self._async_handler.setLevel(db_level)
618 |                     self._root_logger.addHandler(self._async_handler)
    |

gal_friday/logger_service.py:885:9: S101 Use of `assert` detected
    |
883 |             return False
884 |
885 |         assert url is not None, "URL should be a string after 'all' check"
    |         ^^^^^^ S101
886 |
887 |         try:
    |

gal_friday/logger_service.py:889:57: F401 `influxdb_client.Point` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
887 |         try:
888 |             # Import influxdb_client specifics here, only when actually trying to initialize
889 |             from influxdb_client import InfluxDBClient, Point
    |                                                         ^^^^^ F401
890 |             from influxdb_client.client.exceptions import InfluxDBError
891 |             from influxdb_client.client.write_api import SYNCHRONOUS
    |
    = help: Remove unused import: `influxdb_client.Point`

gal_friday/logger_service.py:890:59: F401 `influxdb_client.client.exceptions.InfluxDBError` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
888 |             # Import influxdb_client specifics here, only when actually trying to initialize
889 |             from influxdb_client import InfluxDBClient, Point
890 |             from influxdb_client.client.exceptions import InfluxDBError
    |                                                           ^^^^^^^^^^^^^ F401
891 |             from influxdb_client.client.write_api import SYNCHRONOUS
892 |         except ImportError:
    |
    = help: Remove unused import: `influxdb_client.client.exceptions.InfluxDBError`

gal_friday/logger_service.py:936:10: TC010 Invalid string member in `X | Y`-style union type
    |
934 |         fields: dict[str, Any],
935 |         timestamp: datetime,
936 |     ) -> "InfluxDBPoint" | None:  # Returns InfluxDB Point or None
    |          ^^^^^^^^^^^^^^^ TC010
937 |         """Prepare a data point for InfluxDB.
    |

gal_friday/logger_service.py:1087:100: E501 Line too long (103 > 99)
     |
1085 |                         handler.close()
1086 |                 # Re-run the DB handler part of _setup_logging logic
1087 |                 db_table = str(self._config_manager.get("logging.database.table_name", default="logs"))
     |                                                                                                    ^^^^ E501
1088 |                 if db_table != "logs": db_table = "logs" # Enforce
1089 |                 db_level_str = str(self._config_manager.get("logging.database.level", default="INFO")).upper()
     |

gal_friday/logger_service.py:1088:38: E701 Multiple statements on one line (colon)
     |
1086 |                 # Re-run the DB handler part of _setup_logging logic
1087 |                 db_table = str(self._config_manager.get("logging.database.table_name", default="logs"))
1088 |                 if db_table != "logs": db_table = "logs" # Enforce
     |                                      ^ E701
1089 |                 db_level_str = str(self._config_manager.get("logging.database.level", default="INFO")).upper()
1090 |                 db_level = getattr(logging, db_level_str, logging.INFO)
     |

gal_friday/logger_service.py:1089:100: E501 Line too long (110 > 99)
     |
1087 |                 db_table = str(self._config_manager.get("logging.database.table_name", default="logs"))
1088 |                 if db_table != "logs": db_table = "logs" # Enforce
1089 |                 db_level_str = str(self._config_manager.get("logging.database.level", default="INFO")).upper()
     |                                                                                                    ^^^^^^^^^^^ E501
1090 |                 db_level = getattr(logging, db_level_str, logging.INFO)
1091 |                 try:
     |

gal_friday/logger_service.py:1092:100: E501 Line too long (112 > 99)
     |
1090 |                 db_level = getattr(logging, db_level_str, logging.INFO)
1091 |                 try:
1092 |                     self._async_handler = AsyncPostgresHandler(self._db_session_maker, asyncio.get_event_loop())
     |                                                                                                    ^^^^^^^^^^^^^ E501
1093 |                     self._async_handler.setLevel(db_level)
1094 |                     self._root_logger.addHandler(self._async_handler)
     |

gal_friday/logger_service.py:1120:100: E501 Line too long (129 > 99)
     |
1118 |             self.info("AsyncPostgresHandler processing started.", source_module="LoggerService")
1119 |         elif self._db_enabled:
1120 |             self.error("DB logging enabled, but AsyncPostgresHandler not initialized in start().", source_module="LoggerService")
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
     |

gal_friday/logger_service.py:1148:100: E501 Line too long (111 > 99)
     |
1146 |             try:
1147 |                 if hasattr(self._async_handler, "wait_closed"):
1148 |                     await asyncio.wait_for(self._async_handler.wait_closed(), timeout=10.0) # Increased timeout
     |                                                                                                    ^^^^^^^^^^^^ E501
1149 |                     self.info(
1150 |                         "SQLAlchemy database log handler closed gracefully.",
     |

gal_friday/logger_service.py:1166:100: E501 Line too long (105 > 99)
     |
1164 |                 )
1165 |
1166 |         # Signal the log processing thread to stop (This thread is for the python logging queue, keep it)
     |                                                                                                    ^^^^^^ E501
1167 |         self._stop_event.set()
1168 |         self._thread.join(timeout=2.0)
     |

gal_friday/logger_service.py:1178:100: E501 Line too long (111 > 99)
     |
1176 |         """Initialize the SQLAlchemy engine and session factory for database logging."""
1177 |         if not self._db_enabled:
1178 |             self.info("Database logging is disabled. SQLAlchemy setup skipped.", source_module="LoggerService")
     |                                                                                                    ^^^^^^^^^^^^ E501
1179 |             return
     |

gal_friday/logger_service.py:1184:100: E501 Line too long (102 > 99)
     |
1182 |         if not db_url:
1183 |             self.error(
1184 |                 "Database logging enabled but connection_string is missing. SQLAlchemy setup failed.",
     |                                                                                                    ^^^ E501
1185 |                 source_module="LoggerService",
1186 |             )
     |

gal_friday/logger_service.py:1194:100: E501 Line too long (150 > 99)
     |
1192 | ing...",
1193 | 
1194 | rl).find("@")] + "@********" if "@" in str(db_url) else str(db_url)}, # Mask credentials
     |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1195 | 
1196 | database.pool_size", 5)
     |

gal_friday/logger_service.py:1208:100: E501 Line too long (107 > 99)
     |
1206 |             # Use async_sessionmaker for AsyncEngine and AsyncSession
1207 |             self._sqlalchemy_session_factory = async_sessionmaker(
1208 |                 bind=self._sqlalchemy_engine, class_=AsyncSession, expire_on_commit=False, autoflush=False,
     |                                                                                                    ^^^^^^^^ E501
1209 |             )
1210 |             self.info(
     |

gal_friday/logger_service.py:1226:100: E501 Line too long (114 > 99)
     |
1224 |         except Exception as e: # Catch any other unexpected errors
1225 |             self.critical(
1226 |                 "An unexpected error occurred during SQLAlchemy engine initialization: %s. Disabling DB logging.",
     |                                                                                                    ^^^^^^^^^^^^^^^ E501
1227 |                 e,
1228 |                 source_module="LoggerService",
     |

gal_friday/main.py:21:46: TC001 Move application import `.config_manager.ConfigManager` into a type-checking block
   |
20 | # Import exchange specification classes
21 | from .config_manager import ConfigManager as ConfigManagerType
   |                                              ^^^^^^^^^^^^^^^^^ TC001
22 | from .core.asset_registry import ExchangeSpecification, ExchangeType
   |
   = help: Move into type-checking block

gal_friday/main.py:561:100: E501 Line too long (123 > 99)
    |
559 |             log.debug("FeatureRegistryClient instantiated.")
560 |         else:
561 |             log.warning("FeatureRegistryClient not available, StrategyArbitrator will operate without feature validation.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
562 |             self.feature_registry_client = None
    |

gal_friday/main.py:859:100: E501 Line too long (112 > 99)
    |
857 |         # --- 5. Database Connection Pool and Session Maker ---
858 |         if DatabaseConnectionPool is not None and self.config is not None:
859 |             # Create a basic logger instance for DatabaseConnectionPool if self.logger_service isn't fully ready
    |                                                                                                    ^^^^^^^^^^^^^ E501
860 |             # Or ensure LoggerService is instantiated in a basic mode first.
861 |             # For this step, assuming a basic logger from python's logging can be passed or self.logger_service is basic.
    |

gal_friday/main.py:861:100: E501 Line too long (121 > 99)
    |
859 |             # Create a basic logger instance for DatabaseConnectionPool if self.logger_service isn't fully ready
860 |             # Or ensure LoggerService is instantiated in a basic mode first.
861 |             # For this step, assuming a basic logger from python's logging can be passed or self.logger_service is basic.
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
862 |             # If LoggerService needs full setup for other services to use its get_logger, this order is tricky.
863 |             # Let's assume self.logger_service is not yet the full DB-logging instance.
    |

gal_friday/main.py:862:100: E501 Line too long (111 > 99)
    |
860 |             # Or ensure LoggerService is instantiated in a basic mode first.
861 |             # For this step, assuming a basic logger from python's logging can be passed or self.logger_service is basic.
862 |             # If LoggerService needs full setup for other services to use its get_logger, this order is tricky.
    |                                                                                                    ^^^^^^^^^^^^ E501
863 |             # Let's assume self.logger_service is not yet the full DB-logging instance.
864 |             # We will use a temporary logger for db_pool.
    |

gal_friday/main.py:874:100: E501 Line too long (121 > 99)
    |
872 |             self.session_maker = self.db_connection_pool.get_session_maker()
873 |             if not self.session_maker:
874 |                 log.critical("Failed to get session_maker from DatabaseConnectionPool. DB-dependent services will fail.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
875 |                 raise DependencyMissingError("Application", "session_maker from DatabaseConnectionPool")
876 |             log.info("DatabaseConnectionPool initialized and session_maker created.")
    |

gal_friday/main.py:875:100: E501 Line too long (104 > 99)
    |
873 |             if not self.session_maker:
874 |                 log.critical("Failed to get session_maker from DatabaseConnectionPool. DB-dependent services will fail.")
875 |                 raise DependencyMissingError("Application", "session_maker from DatabaseConnectionPool")
    |                                                                                                    ^^^^^ E501
876 |             log.info("DatabaseConnectionPool initialized and session_maker created.")
877 |         else:
    |

gal_friday/model_lifecycle/cloud_storage.py:40:1: W293 Blank line contains whitespace
   |
38 |     def __init__(self, config: ConfigManager, logger: LoggerService) -> None:
39 |         """Initialize GCS backend.
40 |         
   | ^^^^^^^^ W293
41 |         Args:
42 |             config: Configuration manager
   |
   = help: Remove whitespace from blank line

gal_friday/model_lifecycle/cloud_storage.py:68:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
66 |             )
67 |         except ImportError:
68 |             raise ImportError("google-cloud-storage not installed")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
69 |         except Exception as e:
70 |             raise RuntimeError(f"Failed to initialize GCS client: {e}")
   |

gal_friday/model_lifecycle/cloud_storage.py:70:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
68 |             raise ImportError("google-cloud-storage not installed")
69 |         except Exception as e:
70 |             raise RuntimeError(f"Failed to initialize GCS client: {e}")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
71 |
72 |     async def upload(self, local_path: Path, remote_path: str) -> bool:
   |

gal_friday/model_lifecycle/cloud_storage.py:203:17: SIM108 Use ternary operator `file_path = local_path if not relative_path else local_path / relative_path` instead of `if`-`else`-block
    |
201 |                   # Calculate local file path
202 |                   relative_path = blob.name[len(remote_path):].lstrip("/")
203 | /                 if not relative_path:  # Single file
204 | |                     file_path = local_path
205 | |                 else:
206 | |                     file_path = local_path / relative_path
    | |__________________________________________________________^ SIM108
207 |
208 |                   task = self._download_file(blob, file_path)
    |
    = help: Replace `if`-`else`-block with `file_path = local_path if not relative_path else local_path / relative_path`

gal_friday/model_lifecycle/cloud_storage.py:231:42: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `blob`
    |
229 |             return False
230 |
231 |     async def _download_file(self, blob: Any, local_path: Path) -> bool:
    |                                          ^^^ ANN401
232 |         """Download single file from GCS."""
233 |         try:
    |

gal_friday/model_lifecycle/cloud_storage.py:287:17: S608 Possible SQL injection vector through string-based query construction
    |
285 |         except Exception:
286 |             self.logger.exception(
287 |                 f"Failed to delete from GCS: {remote_path}",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S608
288 |                 source_module=self._source_module,
289 |             )
    |

gal_friday/model_lifecycle/cloud_storage.py:339:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
337 |             )
338 |         except ImportError:
339 |             raise ImportError("aioboto3 not installed")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
340 |
341 |     async def upload(self, local_path: Path, remote_path: str) -> bool:
    |

gal_friday/model_lifecycle/cloud_storage.py:355:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `s3`
    |
353 |             return False
354 |
355 |     async def _upload_file_s3(self, s3: Any, local_path: Path, remote_path: str) -> bool:
    |                                         ^^^ ANN401
356 |         """Upload single file to S3."""
357 |         try:
    |

gal_friday/model_lifecycle/cloud_storage.py:403:46: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `s3`
    |
401 |             return False
402 |
403 |     async def _upload_directory_s3(self, s3: Any, local_path: Path, remote_path: str) -> bool:
    |                                              ^^^ ANN401
404 |         """Upload directory recursively to S3."""
405 |         try:
    |

gal_friday/model_lifecycle/cloud_storage.py:454:25: SIM108 Use ternary operator `file_path = local_path if not relative_path else local_path / relative_path` instead of `if`-`else`-block
    |
452 |                           # Calculate local file path
453 |                           relative_path = obj["Key"][len(remote_path):].lstrip("/")
454 | /                         if not relative_path:  # Single file
455 | |                             file_path = local_path
456 | |                         else:
457 | |                             file_path = local_path / relative_path
    | |__________________________________________________________________^ SIM108
458 |
459 |                           task = self._download_file_s3(s3, obj["Key"], file_path)
    |
    = help: Replace `if`-`else`-block with `file_path = local_path if not relative_path else local_path / relative_path`

gal_friday/model_lifecycle/cloud_storage.py:489:43: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `s3`
    |
487 |             return False
488 |
489 |     async def _download_file_s3(self, s3: Any, key: str, local_path: Path) -> bool:
    |                                           ^^^ ANN401
490 |         """Download single file from S3."""
491 |         try:
    |

gal_friday/model_lifecycle/cloud_storage.py:553:17: S608 Possible SQL injection vector through string-based query construction
    |
551 |         except Exception:
552 |             self.logger.exception(
553 |                 f"Failed to delete from S3: {remote_path}",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S608
554 |                 source_module=self._source_module,
555 |             )
    |

gal_friday/model_lifecycle/experiment_manager.py:27:60: TC001 Move application import `gal_friday.dal.models.experiment.Experiment` into a type-checking block
   |
26 | # Import SQLAlchemy models that this manager might deal with if it transforms data
27 | from gal_friday.dal.models.experiment import Experiment as ExperimentModel
   |                                                            ^^^^^^^^^^^^^^^ TC001
28 | from gal_friday.dal.repositories.experiment_repository import ExperimentRepository
29 | from gal_friday.logger_service import LoggerService
   |
   = help: Move into type-checking block

gal_friday/model_lifecycle/experiment_manager.py:180:100: E501 Line too long (101 > 99)
    |
178 |         self.model_registry = model_registry
179 |         self.session_maker = session_maker # Store session_maker
180 |         self.experiment_repo = ExperimentRepository(session_maker, logger_service) # Instantiate repo
    |                                                                                                    ^^ E501
181 |         self.pubsub = pubsub_manager
182 |         self.logger = logger_service
    |

gal_friday/model_lifecycle/experiment_manager.py:190:100: E501 Line too long (102 > 99)
    |
189 |         # Configuration
190 |         self.max_concurrent_experiments = self.config_manager.get_int("experiments.max_concurrent", 3)
    |                                                                                                    ^^^ E501
191 |         self.auto_stop_on_significance = self.config_manager.get_bool(
192 |             "experiments.auto_stop_on_significance", True,
    |

gal_friday/model_lifecycle/experiment_manager.py:194:100: E501 Line too long (107 > 99)
    |
192 |             "experiments.auto_stop_on_significance", True,
193 |         )
194 |         self.check_interval_minutes = self.config_manager.get_int("experiments.check_interval_minutes", 60)
    |                                                                                                    ^^^^^^^^ E501
195 |
196 |         # State
    |

gal_friday/model_lifecycle/experiment_manager.py:266:100: E501 Line too long (112 > 99)
    |
265 |             # Convert specific Decimal fields back to Decimal if to_dict stringified them
266 |             for key in ["traffic_split", "confidence_level", "minimum_detectable_effect", "max_loss_threshold"]:
    |                                                                                                    ^^^^^^^^^^^^^ E501
267 |                 if key in experiment_data_dict and experiment_data_dict[key] is not None:
268 |                     experiment_data_dict[key] = Decimal(str(experiment_data_dict[key]))
    |

gal_friday/model_lifecycle/experiment_manager.py:276:100: E501 Line too long (103 > 99)
    |
276 |             created_experiment_model = await self.experiment_repo.save_experiment(experiment_data_dict)
    |                                                                                                    ^^^^ E501
277 |
278 |             # Helper to safely get .hex
    |

gal_friday/model_lifecycle/experiment_manager.py:279:31: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `val`
    |
278 |             # Helper to safely get .hex
279 |             def safe_hex(val: Any, name: str) -> str:
    |                               ^^^ ANN401
280 |                 if isinstance(val, uuid.UUID):
281 |                     return val.hex
    |

gal_friday/model_lifecycle/experiment_manager.py:298:100: E501 Line too long (115 > 99)
    |
296 |                     raise TypeError(err_msg) from e
297 |
298 |             exp_id_hex = safe_hex(created_experiment_model.experiment_id, "created_experiment_model.experiment_id")
    |                                                                                                    ^^^^^^^^^^^^^^^^ E501
299 |             control_id_hex = safe_hex(created_experiment_model.control_model_id, "created_experiment_model.control_model_id")
300 |             treatment_id_hex = safe_hex(created_experiment_model.treatment_model_id, "created_experiment_model.treatment_model_id")
    |

gal_friday/model_lifecycle/experiment_manager.py:299:100: E501 Line too long (125 > 99)
    |
298 |             exp_id_hex = safe_hex(created_experiment_model.experiment_id, "created_experiment_model.experiment_id")
299 |             control_id_hex = safe_hex(created_experiment_model.control_model_id, "created_experiment_model.control_model_id")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
300 |             treatment_id_hex = safe_hex(created_experiment_model.treatment_model_id, "created_experiment_model.treatment_model_id")
    |

gal_friday/model_lifecycle/experiment_manager.py:300:100: E501 Line too long (131 > 99)
    |
298 |             exp_id_hex = safe_hex(created_experiment_model.experiment_id, "created_experiment_model.experiment_id")
299 |             control_id_hex = safe_hex(created_experiment_model.control_model_id, "created_experiment_model.control_model_id")
300 |             treatment_id_hex = safe_hex(created_experiment_model.treatment_model_id, "created_experiment_model.treatment_model_id")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
301 |
302 |             # Add to active experiments (still using ExperimentConfig dataclass for now)
    |

gal_friday/model_lifecycle/experiment_manager.py:471:100: E501 Line too long (167 > 99)
    |
469 | 
470 | 
471 | nt {experiment_id}, event {event_id}. Cannot record outcome.", source_module=self._source_module)
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
472 | 
    |

gal_friday/model_lifecycle/experiment_manager.py:483:100: E501 Line too long (164 > 99)
    |
481 | 
482 | 
483 | und in performance tracking for experiment {experiment_id}.", source_module=self._source_module)
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
484 | 
485 | 
    |

gal_friday/model_lifecycle/experiment_manager.py:645:100: E501 Line too long (108 > 99)
    |
643 |             }
644 |
645 |             await self.experiment_repo.save_results(uuid.UUID(experiment_id), results) # Convert str to UUID
    |                                                                                                    ^^^^^^^^^ E501
646 |
647 |             # Remove from active experiments
    |

gal_friday/model_lifecycle/experiment_manager.py:680:100: E501 Line too long (117 > 99)
    |
678 |         try:
679 |             # experiment_repo.get_active_experiments() returns Sequence[ExperimentModel]
680 |             active_experiment_models: Sequence[ExperimentModel] = await self.experiment_repo.get_active_experiments()
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
681 |
682 |             for exp_model in active_experiment_models:
    |

gal_friday/model_lifecycle/experiment_manager.py:685:17: F841 Local variable `config_data` is assigned to but never used
    |
683 |                 # Convert ExperimentModel to ExperimentConfig if internal logic still uses it.
684 |                 # This is a simplification; direct use of exp_model attributes is preferred.
685 |                 config_data = exp_model.config_data or {} # Use stored config_data if available
    |                 ^^^^^^^^^^^ F841
686 |                 # Map model fields to ExperimentConfig fields
687 |                 # This mapping might be complex if structures differ significantly.
    |
    = help: Remove assignment to unused variable `config_data`

gal_friday/model_lifecycle/experiment_manager.py:691:35: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `val`
    |
690 |                 # Helper to safely get .hex
691 |                 def safe_hex(val: Any, name: str) -> str:
    |                                   ^^^ ANN401
692 |                     if not isinstance(val, uuid.UUID):
693 |                         err_msg = f"{name} is not a UUID instance: {type(val)}"
    |

gal_friday/model_lifecycle/experiment_manager.py:698:100: E501 Line too long (111 > 99)
    |
696 |                     return val.hex
697 |
698 |                 exp_id_hex = safe_hex(exp_model.experiment_id, f"exp_model.experiment_id for {exp_model.name}")
    |                                                                                                    ^^^^^^^^^^^^ E501
699 |                 control_id_hex = safe_hex(exp_model.control_model_id, f"exp_model.control_model_id for {exp_model.name}")
700 |                 treatment_id_hex = safe_hex(exp_model.treatment_model_id, f"exp_model.treatment_model_id for {exp_model.name}")
    |

gal_friday/model_lifecycle/experiment_manager.py:699:100: E501 Line too long (121 > 99)
    |
698 |                 exp_id_hex = safe_hex(exp_model.experiment_id, f"exp_model.experiment_id for {exp_model.name}")
699 |                 control_id_hex = safe_hex(exp_model.control_model_id, f"exp_model.control_model_id for {exp_model.name}")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
700 |                 treatment_id_hex = safe_hex(exp_model.treatment_model_id, f"exp_model.treatment_model_id for {exp_model.name}")
    |

gal_friday/model_lifecycle/experiment_manager.py:700:100: E501 Line too long (127 > 99)
    |
698 |                 exp_id_hex = safe_hex(exp_model.experiment_id, f"exp_model.experiment_id for {exp_model.name}")
699 |                 control_id_hex = safe_hex(exp_model.control_model_id, f"exp_model.control_model_id for {exp_model.name}")
700 |                 treatment_id_hex = safe_hex(exp_model.treatment_model_id, f"exp_model.treatment_model_id for {exp_model.name}")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
701 |
702 |                 exp_config = ExperimentConfig(
    |

gal_friday/model_lifecycle/experiment_manager.py:710:100: E501 Line too long (139 > 99)
    |
708 | gy(exp_model.allocation_strategy),
709 | t, # Already Decimal
710 | ace(tzinfo=UTC if exp_model.start_time.tzinfo is None else None), # Ensure tz-aware
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
711 | tzinfo=UTC if exp_model.end_time and exp_model.end_time.tzinfo is None else None) if exp_model.end_time else None,
712 | n_samples_per_variant or 1000,
    |

gal_friday/model_lifecycle/experiment_manager.py:711:100: E501 Line too long (170 > 99)
    |
709 | cimal
710 | if exp_model.start_time.tzinfo is None else None), # Ensure tz-aware
711 | xp_model.end_time and exp_model.end_time.tzinfo is None else None) if exp_model.end_time else None,
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
712 | ariant or 1000,
713 | 
    |

gal_friday/model_lifecycle/experiment_manager.py:714:100: E501 Line too long (175 > 99)
    |
712 | ant or 1000,
713 | 
714 | rics", []) if isinstance(exp_model.secondary_metrics, dict) else (exp_model.secondary_metrics or []),
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
715 | _CONFIDENCE_LEVEL,
716 | _effect or DEFAULT_MIN_DETECTABLE_EFFECT,
    |

gal_friday/model_lifecycle/experiment_manager.py:716:100: E501 Line too long (115 > 99)
    |
714 |          secondary_metrics=exp_model.secondary_metrics.get("metrics", []) if isinstance(exp_model.secondary_metrics, dict) else (exp
715 |          confidence_level=exp_model.confidence_level or DEFAULT_CONFIDENCE_LEVEL,
716 |          minimum_detectable_effect=exp_model.minimum_detectable_effect or DEFAULT_MIN_DETECTABLE_EFFECT,
    |                                                                                          ^^^^^^^^^^^^^^^^ E501
717 |          max_loss_threshold=exp_model.max_loss_threshold,
718 |      )
    |

gal_friday/model_lifecycle/experiment_manager.py:722:100: E501 Line too long (112 > 99)
    |
721 |      # Load performance data (repo returns dict)
722 |      # This part might need adjustment if VariantPerformance objects are stored/retrieved differently
    |                                                                                          ^^^^^^^^^^^^^ E501
723 |      perf_data = await self.experiment_repo.get_experiment_performance(uuid.UUID(str(exp_model.experiment_id))) # Convert SQLAlchemy
    |

gal_friday/model_lifecycle/experiment_manager.py:723:100: E501 Line too long (148 > 99)
    |
721 | 
722 | Performance objects are stored/retrieved differently
723 | xperiment_performance(uuid.UUID(str(exp_model.experiment_id))) # Convert SQLAlchemy UUID
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
724 | 
725 | using VariantPerformance in memory)
    |

gal_friday/model_lifecycle/experiment_manager.py:731:100: E501 Line too long (108 > 99)
    |
729 |                 for variant_name, metrics in perf_data.items():
730 |                     # Use previously hexed IDs
731 |                     model_id_for_variant = control_id_hex if variant_name == "control" else treatment_id_hex
    |                                                                                                    ^^^^^^^^^ E501
732 |                     vp = VariantPerformance(model_id=model_id_for_variant, variant_name=variant_name)
733 |                     vp.sample_count = metrics.get("sample_count", 0)
    |

gal_friday/model_lifecycle/experiment_manager.py:732:100: E501 Line too long (101 > 99)
    |
730 |                     # Use previously hexed IDs
731 |                     model_id_for_variant = control_id_hex if variant_name == "control" else treatment_id_hex
732 |                     vp = VariantPerformance(model_id=model_id_for_variant, variant_name=variant_name)
    |                                                                                                    ^^ E501
733 |                     vp.sample_count = metrics.get("sample_count", 0)
734 |                     vp.correct_predictions = metrics.get("correct_predictions", 0)
    |

gal_friday/model_lifecycle/experiment_manager.py:735:100: E501 Line too long (110 > 99)
    |
733 |                     vp.sample_count = metrics.get("sample_count", 0)
734 |                     vp.correct_predictions = metrics.get("correct_predictions", 0)
735 |                     vp.predictions_made = vp.sample_count # Assuming one prediction per sample for this metric
    |                                                                                                    ^^^^^^^^^^^ E501
736 |                     vp.signals_generated = metrics.get("signals_generated", 0)
737 |                     vp.total_return = metrics.get("total_return", Decimal(0))
    |

gal_friday/model_lifecycle/experiment_manager.py:758:100: E501 Line too long (112 > 99)
    |
756 |         if experiment_id not in self.active_experiments:
757 |             # Try to load from database
758 |             exp_data = await self.experiment_repo.get_experiment(uuid.UUID(experiment_id)) # Convert str to UUID
    |                                                                                                    ^^^^^^^^^^^^^ E501
759 |             if not exp_data:
760 |                 return {"error": "Experiment not found"}
    |

gal_friday/model_lifecycle/registry.py:20:36: TC002 Move third-party import `sqlalchemy.ext.asyncio.AsyncSession` into a type-checking block
   |
18 | import numpy.typing as npt
19 | from sklearn.base import BaseEstimator
20 | from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker  # Added
   |                                    ^^^^^^^^^^^^ TC002
21 |
22 | # from gal_friday.dal.base import BaseEntity # BaseEntity is removed
   |
   = help: Move into type-checking block

gal_friday/model_lifecycle/registry.py:20:50: TC002 Move third-party import `sqlalchemy.ext.asyncio.async_sessionmaker` into a type-checking block
   |
18 | import numpy.typing as npt
19 | from sklearn.base import BaseEstimator
20 | from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker  # Added
   |                                                  ^^^^^^^^^^^^^^^^^^ TC002
21 |
22 | # from gal_friday.dal.base import BaseEntity # BaseEntity is removed
   |
   = help: Move into type-checking block

gal_friday/model_lifecycle/registry.py:23:65: TC001 Move application import `gal_friday.dal.models.model_version.ModelVersion` into a type-checking block
   |
22 | # from gal_friday.dal.base import BaseEntity # BaseEntity is removed
23 | from gal_friday.dal.models.model_version import ModelVersion as ModelVersionModel
   |                                                                 ^^^^^^^^^^^^^^^^^ TC001
24 | from gal_friday.dal.repositories.model_repository import ModelRepository  # Keep for instantiation
   |
   = help: Move into type-checking block

gal_friday/model_lifecycle/registry.py:29:100: E501 Line too long (103 > 99)
   |
27 |     from gal_friday.config_manager import ConfigManager
28 |
29 |     # from gal_friday.dal.repositories.model_repository import ModelRepository # Already imported above
   |                                                                                                    ^^^^ E501
30 |     from gal_friday.logger_service import LoggerService
31 |     from gal_friday.utils.secrets_manager import SecretsManager
   |

gal_friday/model_lifecycle/registry.py:354:100: E501 Line too long (100 > 99)
    |
352 |                     "training_data_start", "training_data_end",
353 |                 ]:
354 |                     if metadata_dict.get(date_field) and isinstance(metadata_dict[date_field], str):
    |                                                                                                    ^ E501
355 |                         dt_obj = datetime.fromisoformat(str(metadata_dict[date_field]))
356 |                         if dt_obj.tzinfo is None: # Make timezone aware
    |

gal_friday/model_lifecycle/registry.py:403:100: E501 Line too long (100 > 99)
    |
402 |         # Storage configuration
403 |         self.storage_path = Path(self.config_manager.get("model_registry.storage_path", "./models"))
    |                                                                                                    ^ E501
404 |         self.storage_path.mkdir(parents=True, exist_ok=True)
    |

gal_friday/model_lifecycle/registry.py:407:100: E501 Line too long (104 > 99)
    |
406 |         # Cloud storage backend (optional)
407 |         self.use_cloud_storage = self.config_manager.get_bool("model_registry.use_cloud_storage", False)
    |                                                                                                    ^^^^^ E501
408 |         self.cloud_storage = None
409 |         if self.use_cloud_storage:
    |

gal_friday/model_lifecycle/registry.py:520:15: D102 Missing docstring in public method
    |
518 |             raise
519 |
520 |     async def get_model(
    |               ^^^^^^^^^ D102
521 |         self,
522 |         model_name: str,
    |

gal_friday/model_lifecycle/registry.py:530:28: E701 Multiple statements on one line (colon)
    |
528 |             if version:
529 |                 versions = await self.model_repo.get_model_versions_by_name(model_name, version)
530 |                 if versions: model_version_model = versions[0]
    |                            ^ E701
531 |             elif stage:
532 |                 stages = await self.model_repo.get_model_versions_by_stage(model_name, stage.value)
    |

gal_friday/model_lifecycle/registry.py:533:26: E701 Multiple statements on one line (colon)
    |
531 |             elif stage:
532 |                 stages = await self.model_repo.get_model_versions_by_stage(model_name, stage.value)
533 |                 if stages: model_version_model = stages[0]
    |                          ^ E701
534 |             else:
535 |                 model_version_model = await self.model_repo.get_latest_model_version_by_name(model_name)
    |

gal_friday/model_lifecycle/registry.py:535:100: E501 Line too long (104 > 99)
    |
533 |                 if stages: model_version_model = stages[0]
534 |             else:
535 |                 model_version_model = await self.model_repo.get_latest_model_version_by_name(model_name)
    |                                                                                                    ^^^^^ E501
536 |
537 |             if not model_version_model:
    |

gal_friday/model_lifecycle/registry.py:538:100: E501 Line too long (101 > 99)
    |
537 |             if not model_version_model:
538 |                 raise ValueError(f"Model not found: {model_name} (version={version}, stage={stage})")
    |                                                                                                    ^^ E501
539 |
540 |             metadata_dto = self._model_version_to_metadata_dto(model_version_model)
    |

gal_friday/model_lifecycle/registry.py:542:100: E501 Line too long (127 > 99)
    |
540 |             metadata_dto = self._model_version_to_metadata_dto(model_version_model)
541 |
542 |             deployments = await self.model_repo.get_deployments_for_model_version(uuid.UUID(str(model_version_model.model_id)))
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
543 |             metadata_dto.deployment_history = [
544 |                 {
    |

gal_friday/model_lifecycle/registry.py:574:15: D102 Missing docstring in public method
    |
572 |             raise
573 |
574 |     async def list_models(
    |               ^^^^^^^^^^^ D102
575 |         self,
576 |         model_name: str | None = None,
    |

gal_friday/model_lifecycle/registry.py:585:15: D102 Missing docstring in public method
    |
583 |         return [self._model_version_to_metadata_dto(mvm) for mvm in model_version_models]
584 |
585 |     async def get_all_models(self) -> list[ModelMetadata]:
    |               ^^^^^^^^^^^^^^ D102
586 |         model_version_models = await self.model_repo.list_all_model_versions()
587 |         return [self._model_version_to_metadata_dto(mvm) for mvm in model_version_models]
    |

gal_friday/model_lifecycle/registry.py:589:15: D102 Missing docstring in public method
    |
587 |         return [self._model_version_to_metadata_dto(mvm) for mvm in model_version_models]
588 |
589 |     async def get_model_count(
    |               ^^^^^^^^^^^^^^^ D102
590 |         self,
591 |         stage: ModelStage | None = None,
    |

gal_friday/model_lifecycle/registry.py:593:100: E501 Line too long (105 > 99)
    |
591 |         stage: ModelStage | None = None,
592 |     ) -> int:
593 |         models_list = await self.model_repo.list_all_model_versions(stage=stage.value if stage else None)
    |                                                                                                    ^^^^^^ E501
594 |         return len(models_list)
    |

gal_friday/model_lifecycle/registry.py:596:15: D102 Missing docstring in public method
    |
594 |         return len(models_list)
595 |
596 |     async def promote_model(
    |               ^^^^^^^^^^^^^ D102
597 |         self,
598 |         model_id_str: str,
    |

gal_friday/model_lifecycle/registry.py:608:100: E501 Line too long (107 > 99)
    |
606 |                 raise ValueError(f"Model not found: {model_id_str}")
607 |
608 |             from_stage = ModelStage(model_version.stage) if model_version.stage else ModelStage.DEVELOPMENT
    |                                                                                                    ^^^^^^^^ E501
609 |
610 |             if not self._is_valid_promotion(from_stage, to_stage):
    |

gal_friday/model_lifecycle/registry.py:616:100: E501 Line too long (111 > 99)
    |
615 |             if to_stage == ModelStage.PRODUCTION:
616 |                 active_prod_deployments = await self.model_repo.get_active_deployment(model_version.model_name)
    |                                                                                                    ^^^^^^^^^^^^ E501
617 |                 if active_prod_deployments and active_prod_deployments.model_id != model_uuid:
618 |                     await self.model_repo.update_model_version_stage(
    |

gal_friday/model_lifecycle/registry.py:644:15: D102 Missing docstring in public method
    |
642 |             raise
643 |
644 |     async def delete_model(
    |               ^^^^^^^^^^^^ D102
645 |         self,
646 |         model_id: str,
    |

gal_friday/model_lifecycle/registry.py:653:100: E501 Line too long (115 > 99)
    |
651 |             model_version = await self.model_repo.get_model_version(model_uuid)
652 |             if not model_version:
653 |                 self.logger.warning(f"Model not found for deletion: {model_id}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^ E501
654 |                 return False
    |

gal_friday/model_lifecycle/registry.py:656:100: E501 Line too long (110 > 99)
    |
654 |                 return False
655 |
656 |             current_stage = ModelStage(model_version.stage) if model_version.stage else ModelStage.DEVELOPMENT
    |                                                                                                    ^^^^^^^^^^^ E501
657 |
658 |             if current_stage == ModelStage.PRODUCTION and not force:
    |

gal_friday/model_lifecycle/registry.py:659:100: E501 Line too long (115 > 99)
    |
658 |             if current_stage == ModelStage.PRODUCTION and not force:
659 |                 raise ValueError("Cannot delete/archive active production model without force=True. Demote first.")
    |                                                                                                    ^^^^^^^^^^^^^^^^ E501
660 |
661 |             updated_model = await self.model_repo.update_model_version_stage(
    |

gal_friday/model_lifecycle/registry.py:666:100: E501 Line too long (108 > 99)
    |
665 |             if not updated_model:
666 |                  self.logger.error(f"Failed to archive model {model_id}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^ E501
667 |                  return False
    |

gal_friday/model_lifecycle/registry.py:669:100: E501 Line too long (127 > 99)
    |
667 |                  return False
668 |
669 |             if self.config_manager.get_bool("model_registry.delete_archived_artifacts", False) and model_version.artifact_path:
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
670 |                 artifact_path = Path(model_version.artifact_path)
671 |                 if artifact_path.exists() and artifact_path.is_dir():
    |

gal_friday/model_lifecycle/registry.py:674:100: E501 Line too long (152 > 99)
    |
672 | 
673 | 
674 | acts for archived model {model_id} at {artifact_path}", source_module=self._source_module)
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
675 | 
676 | ifacts for model {model_id} at {artifact_path}: {e}", source_module=self._source_module)
    |

gal_friday/model_lifecycle/registry.py:676:100: E501 Line too long (150 > 99)
    |
674 | facts for archived model {model_id} at {artifact_path}", source_module=self._source_module)
675 | 
676 | tifacts for model {model_id} at {artifact_path}: {e}", source_module=self._source_module)
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
677 | 
678 | 
    |

gal_friday/model_lifecycle/registry.py:692:30: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
690 |         try:
691 |             parts = list(map(int, current_version_str.split(".")))
692 |             if len(parts) == 3:
    |                              ^ PLR2004
693 |                 parts[2] += 1
694 |                 return ".".join(map(str, parts))
    |

gal_friday/model_lifecycle/registry.py:742:100: E501 Line too long (141 > 99)
    |
740 | 
741 | 
742 | ot a UUID instance: {type(model_id_uuid)} for model_name {model_version.model_name}"
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
743 | lf._source_module)
744 | 
    |

gal_friday/model_lifecycle/registry.py:747:100: E501 Line too long (122 > 99)
    |
746 |         # Ensure created_at and training_completed_at are timezone-aware (UTC)
747 |         created_at_utc = model_version.created_at.replace(tzinfo=UTC if model_version.created_at.tzinfo is None else None)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^ E501
748 |         training_completed_at_utc = None
749 |         if model_version.training_completed_at:
    |

gal_friday/model_lifecycle/registry.py:763:100: E501 Line too long (101 > 99)
    |
761 |             created_at=created_at_utc,
762 |             training_completed_at=training_completed_at_utc,
763 |             stage=ModelStage(model_version.stage) if model_version.stage else ModelStage.DEVELOPMENT,
    |                                                                                                    ^^ E501
764 |             status=ModelStatus.READY,
765 |             metrics=model_version.metrics or {},
    |

gal_friday/model_lifecycle/retraining_pipeline.py:587:100: E501 Line too long (100 > 99)
    |
585 |         # Check repository
586 |         if self.retraining_repository:
587 |             return await self.retraining_repository.get_job(uuid.UUID(job_id)) # Convert str to UUID
    |                                                                                                    ^ E501
588 |
589 |         return None
    |

gal_friday/models/__init__.py:1:1: D104 Missing docstring in public package
gal_friday/models/base.py:1:1: D100 Missing docstring in public module
gal_friday/models/configuration.py:1:1: D100 Missing docstring in public module
gal_friday/models/configuration.py:12:7: D101 Missing docstring in public class
   |
12 | class Configuration(Base):
   |       ^^^^^^^^^^^^^ D101
13 |     __tablename__ = "configurations"
   |

gal_friday/models/configuration.py:18:100: E501 Line too long (102 > 99)
   |
16 |     config_hash = Column(String(64), unique=True, nullable=False, index=True)
17 |     config_content = Column(JSON, nullable=False)
18 |     loaded_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), index=True)
   |                                                                                                    ^^^ E501
19 |     is_active = Column(Boolean, nullable=False, default=True)
   |

gal_friday/models/configuration.py:21:9: D105 Missing docstring in magic method
   |
19 |     is_active = Column(Boolean, nullable=False, default=True)
20 |
21 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
22 |         return (
23 |             f"<Configuration(config_pk={self.config_pk}, config_hash='{self.config_hash}', "
   |

gal_friday/models/configuration.py:34:9: F841 Local variable `event_data` is assigned to but never used
   |
32 |         # from gal_friday.core.events import LogEvent
33 |
34 |         event_data = {
   |         ^^^^^^^^^^ F841
35 |             "source_module": self.__class__.__name__,
36 |             "event_id": uuid.uuid4(),
   |
   = help: Remove assignment to unused variable `event_data`

gal_friday/models/configuration.py:39:100: E501 Line too long (105 > 99)
   |
37 |             "timestamp": datetime.utcnow(),
38 |             "level": "INFO", # Or some other appropriate level
39 |             "message": f"Configuration accessed/processed: PK={self.config_pk}, Hash={self.config_hash}",
   |                                                                                                    ^^^^^^ E501
40 |             "context": {
41 |                 "config_pk": self.config_pk,
   |

gal_friday/models/configuration.py:63:100: E501 Line too long (102 > 99)
   |
61 |             timestamp=datetime.utcnow(),
62 |             level="INFO",  # Or some other appropriate level
63 |             message=f"Configuration accessed/processed: PK={self.config_pk}, Hash={self.config_hash}",
   |                                                                                                    ^^^ E501
64 |             context={
65 |                 "config_pk": self.config_pk,
   |

gal_friday/models/fill.py:1:1: D100 Missing docstring in public module
gal_friday/models/fill.py:20:7: D101 Missing docstring in public class
   |
20 | class Fill(Base):
   |       ^^^^ D101
21 |     __tablename__ = "fills"
   |

gal_friday/models/fill.py:25:100: E501 Line too long (109 > 99)
   |
23 |     fill_pk: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
24 |     fill_id: Mapped[str | None] = mapped_column(String(64), nullable=True)  # Exchange fill ID
25 |     order_pk: Mapped[int] = mapped_column(Integer, ForeignKey("orders.order_pk"), nullable=False, index=True)
   |                                                                                                    ^^^^^^^^^^ E501
26 |     exchange_order_id: Mapped[str | None] = mapped_column(String(64), index=True, nullable=True) # From Order, denormalized for easier
   |

gal_friday/models/fill.py:26:100: E501 Line too long (140 > 99)
   |
24 | 4), nullable=True)  # Exchange fill ID
25 | gnKey("orders.order_pk"), nullable=False, index=True)
26 | n(String(64), index=True, nullable=True) # From Order, denormalized for easier query
   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
27 | 
28 | , nullable=False)
   |

gal_friday/models/fill.py:35:100: E501 Line too long (103 > 99)
   |
33 |     commission: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False)
34 |     commission_asset: Mapped[str] = mapped_column(String(16), nullable=False)
35 |     liquidity_type: Mapped[str | None] = mapped_column(String(10), nullable=True)  # 'MAKER' or 'TAKER'
   |                                                                                                    ^^^^ E501
36 |     filled_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True) # Changed to Mapped[datetime]
   |

gal_friday/models/fill.py:36:100: E501 Line too long (130 > 99)
   |
34 |     commission_asset: Mapped[str] = mapped_column(String(16), nullable=False)
35 |     liquidity_type: Mapped[str | None] = mapped_column(String(10), nullable=True)  # 'MAKER' or 'TAKER'
36 |     filled_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True) # Changed to Mapped[datetime]
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
37 |
38 |     # Relationships
   |

gal_friday/models/fill.py:46:9: D105 Missing docstring in magic method
   |
44 |     )
45 |
46 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
47 |         return (
48 |             f"<Fill(fill_pk={self.fill_pk}, fill_id='{self.fill_id}', order_pk={self.order_pk}, "
   |

gal_friday/models/fill.py:54:100: E501 Line too long (104 > 99)
   |
52 |     def to_event(self) -> "ExecutionReportEvent": # Added to_event with type hints
53 |         """Converts the Fill object to an ExecutionReportEvent."""
54 |         # Imports needed for ExecutionReportEvent. Assuming they are or will be available in the module.
   |                                                                                                    ^^^^^ E501
55 |         # from decimal import Decimal # Already imported via sqlalchemy Numeric
56 |         # import uuid # For event_id and signal_id
   |

gal_friday/models/fill.py:71:100: E501 Line too long (114 > 99)
   |
70 |         # Simulating access to related order for some fields:
71 |         order_exchange_order_id = self.exchange_order_id or (self.order.exchange_order_id if self.order else None)
   |                                                                                                    ^^^^^^^^^^^^^^^ E501
72 |         order_trading_pair = self.trading_pair or (self.order.trading_pair if self.order else "UNKNOWN/UNKNOWN")
73 |         order_exchange = self.exchange or (self.order.exchange if self.order else "UNKNOWN_EXCHANGE")
   |

gal_friday/models/fill.py:72:100: E501 Line too long (112 > 99)
   |
70 |         # Simulating access to related order for some fields:
71 |         order_exchange_order_id = self.exchange_order_id or (self.order.exchange_order_id if self.order else None)
72 |         order_trading_pair = self.trading_pair or (self.order.trading_pair if self.order else "UNKNOWN/UNKNOWN")
   |                                                                                                    ^^^^^^^^^^^^^ E501
73 |         order_exchange = self.exchange or (self.order.exchange if self.order else "UNKNOWN_EXCHANGE")
74 |         order_side = self.side or (self.order.side if self.order else "UNKNOWN_SIDE")
   |

gal_friday/models/fill.py:73:100: E501 Line too long (101 > 99)
   |
71 |         order_exchange_order_id = self.exchange_order_id or (self.order.exchange_order_id if self.order else None)
72 |         order_trading_pair = self.trading_pair or (self.order.trading_pair if self.order else "UNKNOWN/UNKNOWN")
73 |         order_exchange = self.exchange or (self.order.exchange if self.order else "UNKNOWN_EXCHANGE")
   |                                                                                                    ^^ E501
74 |         order_side = self.side or (self.order.side if self.order else "UNKNOWN_SIDE")
75 |         order_type = self.order.order_type if self.order else "MARKET" # Default if no order
   |

gal_friday/models/fill.py:77:100: E501 Line too long (127 > 99)
   |
75 |         order_type = self.order.order_type if self.order else "MARKET" # Default if no order
76 |         quantity_ordered = self.order.quantity if self.order else self.quantity_filled # Default
77 |         signal_id_val = self.order.signal_id if self.order and hasattr(self.order, "signal_id") else uuid.uuid4() # Placeholder
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
78 |
79 |         _client_order_id_from_order = self.order.client_order_id if self.order and hasattr(self.order, "client_order_id") else None
   |

gal_friday/models/fill.py:79:100: E501 Line too long (131 > 99)
   |
77 |         signal_id_val = self.order.signal_id if self.order and hasattr(self.order, "signal_id") else uuid.uuid4() # Placeholder
78 |
79 |         _client_order_id_from_order = self.order.client_order_id if self.order and hasattr(self.order, "client_order_id") else None
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
80 |         client_order_id_val = str(_client_order_id_from_order) if _client_order_id_from_order is not None else None
   |

gal_friday/models/fill.py:80:100: E501 Line too long (115 > 99)
   |
79 |         _client_order_id_from_order = self.order.client_order_id if self.order and hasattr(self.order, "client_order_id") else None
80 |         client_order_id_val = str(_client_order_id_from_order) if _client_order_id_from_order is not None else None
   |                                                                                                    ^^^^^^^^^^^^^^^^ E501
   |

gal_friday/models/fill.py:102:100: E501 Line too long (109 > 99)
    |
100 |         # Since I cannot import it here directly within this tool call easily,
101 |         # I will construct a dictionary that matches its likely structure.
102 |         # In a real scenario, I'd ensure the import `from gal_friday.core.events import ExecutionReportEvent`
    |                                                                                                    ^^^^^^^^^^ E501
103 |         # is at the top of the file.
    |

gal_friday/models/fill.py:116:100: E501 Line too long (179 > 99)
    |
114 | 
115 | 
116 |  "exchange_order_id" to "ExecutionReportEvent" has incompatible type "str | Any | None"; expected "str"
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
117 | 
118 | rity should be adjusted.
    |

gal_friday/models/fill.py:118:100: E501 Line too long (100 > 99)
    |
116 |      # This addresses: gal_friday/models/fill.py:144: error: Argument "exchange_order_id" to "ExecutionReportEvent" has incompatible
117 |      # We need to provide a string if the event strictly expects one.
118 |      # Alternatively, the event definition or this model's data integrity should be adjusted.
    |                                                                                              ^ E501
119 |      # For now, using a placeholder:
120 |      final_exchange_order_id = "UNKNOWN_FILL_EXCH_ORD_ID" # Placeholder
    |

gal_friday/models/fill.py:122:9: F841 Local variable `event_data` is assigned to but never used
    |
120 |             final_exchange_order_id = "UNKNOWN_FILL_EXCH_ORD_ID" # Placeholder
121 |
122 |         event_data = {
    |         ^^^^^^^^^^ F841
123 |             "source_module": self.__class__.__name__,
124 |             "event_id": uuid.uuid4(),
    |
    = help: Remove assignment to unused variable `event_data`

gal_friday/models/fill.py:137:100: E501 Line too long (111 > 99)
    |
135 |             "quantity_filled": self.quantity_filled,
136 |             "average_fill_price": self.fill_price, # Fill price is the average for this fill
137 |             "limit_price": self.order.limit_price if self.order and self.order.order_type == "LIMIT" else None,
    |                                                                                                    ^^^^^^^^^^^^ E501
138 |             "stop_price": self.order.stop_price if self.order and "STOP" in self.order.order_type else None,
139 |             "commission": self.commission,
    |

gal_friday/models/fill.py:138:100: E501 Line too long (108 > 99)
    |
136 |             "average_fill_price": self.fill_price, # Fill price is the average for this fill
137 |             "limit_price": self.order.limit_price if self.order and self.order.order_type == "LIMIT" else None,
138 |             "stop_price": self.order.stop_price if self.order and "STOP" in self.order.order_type else None,
    |                                                                                                    ^^^^^^^^^ E501
139 |             "commission": self.commission,
140 |             "commission_asset": self.commission_asset,
    |

gal_friday/models/fill.py:168:100: E501 Line too long (131 > 99)
    |
166 |             side=cast("str", order_side),
167 |             quantity_ordered=quantity_ordered, # Ensure this is Decimal
168 |             signal_id=cast("uuid.UUID", signal_id_val), # Was Column[UUID] | UUID, event expects UUID | None. Value is always UUID.
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
169 |             client_order_id=client_order_id_val,
170 |             quantity_filled=self.quantity_filled, # Ensure this is Decimal
    |

gal_friday/models/fill.py:172:100: E501 Line too long (134 > 99)
    |
170 |             quantity_filled=self.quantity_filled, # Ensure this is Decimal
171 |             average_fill_price=self.fill_price, # Ensure this is Decimal
172 |             limit_price=cast("Decimal | None", (self.order.limit_price if self.order and self.order.order_type == "LIMIT" else None)),
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
173 |             stop_price=cast("Decimal | None", (self.order.stop_price if self.order and "STOP" in self.order.order_type else None)),
174 |             commission=self.commission, # Ensure Decimal or None
    |

gal_friday/models/fill.py:173:100: E501 Line too long (131 > 99)
    |
171 |             average_fill_price=self.fill_price, # Ensure this is Decimal
172 |             limit_price=cast("Decimal | None", (self.order.limit_price if self.order and self.order.order_type == "LIMIT" else None)),
173 |             stop_price=cast("Decimal | None", (self.order.stop_price if self.order and "STOP" in self.order.order_type else None)),
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
174 |             commission=self.commission, # Ensure Decimal or None
175 |             commission_asset=self.commission_asset,
    |

gal_friday/models/log.py:1:1: D100 Missing docstring in public module
gal_friday/models/log.py:20:7: D101 Missing docstring in public class
   |
20 | class Log(Base):
   |       ^^^ D101
21 |     __tablename__ = "logs"
   |

gal_friday/models/log.py:23:100: E501 Line too long (111 > 99)
   |
21 |     __tablename__ = "logs"
22 |
23 |     id: Mapped[int] = mapped_column(BigInteger, primary_key=True, index=True) # Assuming BigInteger maps to int
   |                                                                                                    ^^^^^^^^^^^^ E501
24 |     timestamp: Mapped[datetime.datetime] = mapped_column(TIMESTAMP(timezone=True), nullable=False, default=datetime.datetime.utcnow)
25 |     logger_name: Mapped[str] = mapped_column(String(255), nullable=False)
   |

gal_friday/models/log.py:24:100: E501 Line too long (132 > 99)
   |
23 |     id: Mapped[int] = mapped_column(BigInteger, primary_key=True, index=True) # Assuming BigInteger maps to int
24 |     timestamp: Mapped[datetime.datetime] = mapped_column(TIMESTAMP(timezone=True), nullable=False, default=datetime.datetime.utcnow)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
25 |     logger_name: Mapped[str] = mapped_column(String(255), nullable=False)
26 |     level_name: Mapped[str] = mapped_column(String(50), nullable=False)
   |

gal_friday/models/log.py:29:100: E501 Line too long (100 > 99)
   |
27 |     level_no: Mapped[int] = mapped_column(Integer, nullable=False) # Added Mapped for consistency
28 |     message: Mapped[str] = mapped_column(Text, nullable=False) # Changed to Mapped[str]
29 |     pathname: Mapped[str | None] = mapped_column(Text, nullable=True) # Added Mapped for consistency
   |                                                                                                    ^ E501
30 |     filename: Mapped[str | None] = mapped_column(String(255), nullable=True) # Added Mapped for consistency
31 |     lineno: Mapped[int | None] = mapped_column(Integer, nullable=True)
   |

gal_friday/models/log.py:30:100: E501 Line too long (107 > 99)
   |
28 |     message: Mapped[str] = mapped_column(Text, nullable=False) # Changed to Mapped[str]
29 |     pathname: Mapped[str | None] = mapped_column(Text, nullable=True) # Added Mapped for consistency
30 |     filename: Mapped[str | None] = mapped_column(String(255), nullable=True) # Added Mapped for consistency
   |                                                                                                    ^^^^^^^^ E501
31 |     lineno: Mapped[int | None] = mapped_column(Integer, nullable=True)
32 |     func_name: Mapped[str | None] = mapped_column(String(255), nullable=True)
   |

gal_friday/models/log.py:33:100: E501 Line too long (113 > 99)
   |
31 |     lineno: Mapped[int | None] = mapped_column(Integer, nullable=True)
32 |     func_name: Mapped[str | None] = mapped_column(String(255), nullable=True)
33 |     context_json: Mapped[dict[str, Any] | None] = mapped_column(JSON, nullable=True) # Assuming JSON maps to dict
   |                                                                                                    ^^^^^^^^^^^^^^ E501
34 |     exception_text: Mapped[str | None] = mapped_column(Text, nullable=True)
   |

gal_friday/models/log.py:36:9: D105 Missing docstring in magic method
   |
34 |     exception_text: Mapped[str | None] = mapped_column(Text, nullable=True)
35 |
36 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
37 |         return f"<Log(id={self.id}, name='{self.logger_name}', level='{self.level_name}')>"
   |

gal_friday/models/order.py:1:1: D100 Missing docstring in public module
gal_friday/models/order.py:15:7: D101 Missing docstring in public class
   |
15 | class Order(Base):
   |       ^^^^^ D101
16 |     __tablename__ = "orders"
   |

gal_friday/models/order.py:19:100: E501 Line too long (112 > 99)
   |
18 |     order_pk = Column(Integer, primary_key=True, autoincrement=True)
19 |     client_order_id = Column(PG_UUID(as_uuid=True), unique=True, nullable=False, default=uuid.uuid4, index=True)
   |                                                                                                    ^^^^^^^^^^^^^ E501
20 |     exchange_order_id = Column(String(64), unique=True, nullable=True, index=True)
21 |     signal_id = Column(PG_UUID(as_uuid=True), ForeignKey("signals.signal_id"), index=True)
   |

gal_friday/models/order.py:33:100: E501 Line too long (103 > 99)
   |
31 |     error_message = Column(Text, nullable=True)
32 |
33 |     created_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), index=True)
   |                                                                                                    ^^^^ E501
34 |     submitted_at = Column(DateTime(timezone=True), nullable=True)
35 |     last_updated_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), onupdate=func.now())
   |

gal_friday/models/order.py:35:100: E501 Line too long (117 > 99)
   |
33 |     created_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), index=True)
34 |     submitted_at = Column(DateTime(timezone=True), nullable=True)
35 |     last_updated_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), onupdate=func.now())
   |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
36 |
37 |     # Relationships
   |

gal_friday/models/order.py:42:100: E501 Line too long (126 > 99)
   |
41 |     # Relationships to Trade table (will be fully defined in Trade model via back_populates)
42 |     # trade_entry: Mapped[Optional["Trade"]] = relationship(foreign_keys="Trade.entry_order_pk", back_populates="entry_order")
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
43 |     # trade_exit: Mapped[Optional["Trade"]] = relationship(foreign_keys="Trade.exit_order_pk", back_populates="exit_order")
44 |     # The above lines are commented out as they are defined by the 'Trade' model's back_populates
   |

gal_friday/models/order.py:43:100: E501 Line too long (123 > 99)
   |
41 |     # Relationships to Trade table (will be fully defined in Trade model via back_populates)
42 |     # trade_entry: Mapped[Optional["Trade"]] = relationship(foreign_keys="Trade.entry_order_pk", back_populates="entry_order")
43 |     # trade_exit: Mapped[Optional["Trade"]] = relationship(foreign_keys="Trade.exit_order_pk", back_populates="exit_order")
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
44 |     # The above lines are commented out as they are defined by the 'Trade' model's back_populates
   |

gal_friday/models/order.py:46:9: D105 Missing docstring in magic method
   |
44 |     # The above lines are commented out as they are defined by the 'Trade' model's back_populates
45 |
46 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
47 |         return (
48 |             f"<Order(order_pk={self.order_pk}, client_order_id={self.client_order_id}, "
   |

gal_friday/models/order.py:71:100: E501 Line too long (104 > 99)
   |
69 |                 total_fill_value += fill.quantity_filled * fill.fill_price
70 |                 commission_val += fill.commission
71 |                 if commission_asset_val is None and fill.commission_asset: # Take first commission asset
   |                                                                                                    ^^^^^ E501
72 |                     commission_asset_val = fill.commission_asset
   |

gal_friday/models/order.py:74:100: E501 Line too long (108 > 99)
   |
72 |                     commission_asset_val = fill.commission_asset
73 |
74 |         average_fill_price_val = total_fill_value / quantity_filled_val if quantity_filled_val > 0 else None
   |                                                                                                    ^^^^^^^^^ E501
75 |
76 |         event_data = {
   |

gal_friday/models/order.py:95:100: E501 Line too long (139 > 99)
   |
93 | 
94 | 
95 | or self.submitted_at or self.created_at, # Best available exchange-related timestamp
   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
96 | 
97 | 
   |

gal_friday/models/portfolio_snapshot.py:1:1: D100 Missing docstring in public module
gal_friday/models/portfolio_snapshot.py:9:7: D101 Missing docstring in public class
   |
 9 | class PortfolioSnapshot(Base):
   |       ^^^^^^^^^^^^^^^^^ D101
10 |     __tablename__ = "portfolio_snapshots"
   |

gal_friday/models/portfolio_snapshot.py:13:100: E501 Line too long (124 > 99)
   |
12 |     snapshot_pk = Column(Integer, primary_key=True, autoincrement=True)
13 |     snapshot_timestamp = Column(DateTime(timezone=True), unique=True, nullable=False, server_default=func.now(), index=True)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
14 |     total_equity = Column(Numeric(18, 8), nullable=False)
15 |     available_balance = Column(Numeric(18, 8), nullable=False)
   |

gal_friday/models/portfolio_snapshot.py:22:9: D105 Missing docstring in magic method
   |
20 |     positions = Column(JSON, nullable=False)  # JSON object detailing current positions
21 |
22 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
23 |         return (
24 |             f"<PortfolioSnapshot(snapshot_pk={self.snapshot_pk}, "
   |

gal_friday/models/portfolio_snapshot.py:32:100: E501 Line too long (107 > 99)
   |
30 |         return {
31 |             "snapshot_pk": self.snapshot_pk,
32 |             "snapshot_timestamp": self.snapshot_timestamp.isoformat() if self.snapshot_timestamp else None,
   |                                                                                                    ^^^^^^^^ E501
33 |             "total_equity": float(self.total_equity) if self.total_equity is not None else None,
34 |             "available_balance": float(self.available_balance) if self.available_balance is not None else None,
   |

gal_friday/models/portfolio_snapshot.py:34:100: E501 Line too long (111 > 99)
   |
32 |             "snapshot_timestamp": self.snapshot_timestamp.isoformat() if self.snapshot_timestamp else None,
33 |             "total_equity": float(self.total_equity) if self.total_equity is not None else None,
34 |             "available_balance": float(self.available_balance) if self.available_balance is not None else None,
   |                                                                                                    ^^^^^^^^^^^^ E501
35 |             "total_exposure_pct": self.total_exposure_pct,
36 |             "daily_drawdown_pct": self.daily_drawdown_pct,
   |

gal_friday/models/portfolio_snapshot.py:39:100: E501 Line too long (100 > 99)
   |
37 |             "weekly_drawdown_pct": self.weekly_drawdown_pct,
38 |             "total_drawdown_pct": self.total_drawdown_pct,
39 |             "positions": self.positions, # Assuming positions is already a dict or JSON-serializable
   |                                                                                                    ^ E501
40 |         }
   |

gal_friday/models/signal.py:1:1: D100 Missing docstring in public module
gal_friday/models/signal.py:20:7: D101 Missing docstring in public class
   |
20 | class Signal(Base):
   |       ^^^^^^ D101
21 |     __tablename__ = "signals"
   |

gal_friday/models/signal.py:23:100: E501 Line too long (109 > 99)
   |
21 |     __tablename__ = "signals"
22 |
23 |     signal_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
   |                                                                                                    ^^^^^^^^^^ E501
24 |     trading_pair: Mapped[str] = mapped_column(String(16), nullable=False)
25 |     exchange: Mapped[str] = mapped_column(String(32), nullable=False)
   |

gal_friday/models/signal.py:32:100: E501 Line too long (103 > 99)
   |
30 |     proposed_sl_price: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False)
31 |     proposed_tp_price: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False)
32 |     prediction_event_id: Mapped[uuid.UUID | None] = mapped_column(PG_UUID(as_uuid=True), nullable=True)
   |                                                                                                    ^^^^ E501
33 |     prediction_value: Mapped[float | None] = mapped_column(Float, nullable=True)
34 |     status: Mapped[str] = mapped_column(String(10), nullable=False)
   |

gal_friday/models/signal.py:37:100: E501 Line too long (128 > 99)
   |
35 |     rejection_reason: Mapped[str | None] = mapped_column(Text, nullable=True)
36 |     risk_check_details: Mapped[dict[str, Any] | None] = mapped_column(JSON, nullable=True)
37 |     created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, server_default=func.now(), index=True)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
38 |
39 |     # Relationships
   |

gal_friday/models/signal.py:40:100: E501 Line too long (112 > 99)
   |
39 |     # Relationships
40 |     orders: Mapped[list["Order"]] = relationship("Order", back_populates="signal", cascade="all, delete-orphan")
   |                                                                                                    ^^^^^^^^^^^^^ E501
41 |     trade: Mapped["Trade | None"] = relationship("Trade", back_populates="signal", uselist=False, cascade="all, delete-orphan")
   |

gal_friday/models/signal.py:41:100: E501 Line too long (127 > 99)
   |
39 |     # Relationships
40 |     orders: Mapped[list["Order"]] = relationship("Order", back_populates="signal", cascade="all, delete-orphan")
41 |     trade: Mapped["Trade | None"] = relationship("Trade", back_populates="signal", uselist=False, cascade="all, delete-orphan")
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
42 |
43 |     def __repr__(self) -> str: # Added -> str
   |

gal_friday/models/signal.py:43:9: D105 Missing docstring in magic method
   |
41 |     trade: Mapped["Trade | None"] = relationship("Trade", back_populates="signal", uselist=False, cascade="all, delete-orphan")
42 |
43 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
44 |         return (
45 |             f"<Signal(signal_id={self.signal_id}, trading_pair='{self.trading_pair}', "
   |

gal_friday/models/signal.py:57:9: F841 Local variable `event_data` is assigned to but never used
   |
55 |         # from gal_friday.core.events import TradeSignalProposedEvent
56 |
57 |         event_data = {
   |         ^^^^^^^^^^ F841
58 |             "source_module": self.__class__.__name__,
59 |             "event_id": uuid.uuid4(), # New event ID
   |
   = help: Remove assignment to unused variable `event_data`

gal_friday/models/signal.py:72:100: E501 Line too long (117 > 99)
   |
70 |             "triggering_prediction_event_id": self.prediction_event_id,
71 |             # 'triggering_prediction' field in event might need more data if available
72 |             "triggering_prediction": {"value": self.prediction_value} if self.prediction_value is not None else None,
   |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
73 |         }
74 |         # In a real implementation:
   |

gal_friday/models/signal.py:96:100: E501 Line too long (114 > 99)
   |
94 |             strategy_id=self.strategy_id,
95 |             triggering_prediction_event_id=self.prediction_event_id, # Ensure uuid.UUID | None
96 |             triggering_prediction={"value": self.prediction_value} if self.prediction_value is not None else None,
   |                                                                                                    ^^^^^^^^^^^^^^^ E501
97 |         )
   |

gal_friday/models/system_log.py:1:1: D100 Missing docstring in public module
gal_friday/models/system_log.py:15:7: D101 Missing docstring in public class
   |
15 | class SystemLog(Base):
   |       ^^^^^^^^^ D101
16 |     __tablename__ = "system_logs"
   |

gal_friday/models/system_log.py:19:100: E501 Line too long (131 > 99)
   |
18 |     log_pk: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
19 |     log_timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, server_default=func.now(), index=True)
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
20 |     source_module: Mapped[str] = mapped_column(String(64), nullable=False, index=True)
21 |     log_level: Mapped[str] = mapped_column(String(10), nullable=False, index=True)
   |

gal_friday/models/system_log.py:31:100: E501 Line too long (112 > 99)
   |
29 |     exception_type: Mapped[str | None] = mapped_column(Text, nullable=True)
30 |     stack_trace: Mapped[str | None] = mapped_column(Text, nullable=True)
31 |     # Using generic JSON for broader compatibility, can be switched to JSONB if PG-specific features are needed.
   |                                                                                                    ^^^^^^^^^^^^^ E501
32 |     context: Mapped[dict[str, Any] | None] = mapped_column(JSON, nullable=True)
   |

gal_friday/models/system_log.py:34:9: D105 Missing docstring in magic method
   |
32 |     context: Mapped[dict[str, Any] | None] = mapped_column(JSON, nullable=True)
33 |
34 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
35 |         return (
36 |             f"<SystemLog(log_pk={self.log_pk}, source_module='{self.source_module}', "
   |

gal_friday/models/system_log.py:65:100: E501 Line too long (101 > 99)
   |
63 |             source_module=self.source_module,
64 |             event_id=uuid.uuid4(),  # Generate a new UUID for this event instance
65 |             timestamp=self.log_timestamp or datetime.utcnow(), # Use the log's timestamp if available
   |                                                                                                    ^^ E501
66 |             level=self.log_level.upper(),
67 |             message=self.message,
   |

gal_friday/models/trade.py:1:1: D100 Missing docstring in public module
gal_friday/models/trade.py:19:7: D101 Missing docstring in public class
   |
19 | class Trade(Base):
   |       ^^^^^ D101
20 |     __tablename__ = "trades"
   |

gal_friday/models/trade.py:23:100: E501 Line too long (131 > 99)
   |
22 | primary_key=True, autoincrement=True)
23 | UUID(as_uuid=True), unique=True, nullable=False, default=uuid.uuid4, index=True)
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
24 | lumn(PG_UUID(as_uuid=True), ForeignKey("signals.signal_id"), index=True, nullable=True)
   |

gal_friday/models/trade.py:24:100: E501 Line too long (138 > 99)
   |
22 | ary_key=True, autoincrement=True)
23 | (as_uuid=True), unique=True, nullable=False, default=uuid.uuid4, index=True)
24 | (PG_UUID(as_uuid=True), ForeignKey("signals.signal_id"), index=True, nullable=True)
   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
25 | 
26 | ), nullable=False, index=True)
   |

gal_friday/models/trade.py:31:100: E501 Line too long (109 > 99)
   |
29 |     side: Mapped[str] = mapped_column(String(4), nullable=False)  # Side of the entry
30 |
31 |     entry_order_pk: Mapped[int | None] = mapped_column(Integer, ForeignKey("orders.order_pk"), nullable=True)
   |                                                                                                    ^^^^^^^^^^ E501
32 |     exit_order_pk: Mapped[int | None] = mapped_column(Integer, ForeignKey("orders.order_pk"), nullable=True)
   |

gal_friday/models/trade.py:32:100: E501 Line too long (108 > 99)
   |
31 |     entry_order_pk: Mapped[int | None] = mapped_column(Integer, ForeignKey("orders.order_pk"), nullable=True)
32 |     exit_order_pk: Mapped[int | None] = mapped_column(Integer, ForeignKey("orders.order_pk"), nullable=True)
   |                                                                                                    ^^^^^^^^^ E501
33 |
34 |     entry_timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True)
   |

gal_friday/models/trade.py:34:100: E501 Line too long (106 > 99)
   |
32 |     exit_order_pk: Mapped[int | None] = mapped_column(Integer, ForeignKey("orders.order_pk"), nullable=True)
33 |
34 |     entry_timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True)
   |                                                                                                    ^^^^^^^ E501
35 |     exit_timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True)
   |

gal_friday/models/trade.py:35:100: E501 Line too long (105 > 99)
   |
34 |     entry_timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True)
35 |     exit_timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True)
   |                                                                                                    ^^^^^^ E501
36 |
37 |     quantity: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False)
   |

gal_friday/models/trade.py:40:100: E501 Line too long (115 > 99)
   |
38 |     average_entry_price: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False)
39 |     average_exit_price: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False)
40 |     total_commission: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False) # Should be in quote currency
   |                                                                                                    ^^^^^^^^^^^^^^^^ E501
41 |     realized_pnl: Mapped[Decimal] = mapped_column(Numeric(18, 8), nullable=False) # Quote currency
42 |     realized_pnl_pct: Mapped[float] = mapped_column(Float, nullable=False)
   |

gal_friday/models/trade.py:51:100: E501 Line too long (100 > 99)
   |
49 |         "Order",
50 |         foreign_keys=[entry_order_pk],
51 |         backref="trade_as_entry", # Use backref to avoid conflict if Order directly relates to Trade
   |                                                                                                    ^ E501
52 |         # Or ensure Order.trade_entry uses a specific foreign_keys if defined there
53 |     )
   |

gal_friday/models/trade.py:60:9: D105 Missing docstring in magic method
   |
58 |     )
59 |
60 |     def __repr__(self) -> str: # Added -> str
   |         ^^^^^^^^ D105
61 |         return (
62 |             f"<Trade(trade_id={self.trade_id}, trading_pair='{self.trading_pair}', "
   |

gal_friday/models/trade.py:67:9: D205 1 blank line required between summary line and description
   |
66 |       def to_event(self) -> "MarketDataTradeEvent": # Added to_event with type hints
67 | /         """Converts the Trade object to a MarketDataTradeEvent.
68 | |         This represents the entry part of the trade as a market event.
69 | |         Exit would be a separate event if needed.
70 | |         """
   | |___________^ D205
71 |           # Assuming MarketDataTradeEvent is importable from gal_friday.core.events
72 |           # import uuid # Already imported
   |
   = help: Insert single blank line

gal_friday/models/trade.py:80:100: E501 Line too long (103 > 99)
   |
78 |         # A MarketDataTradeEvent typically represents a single execution (fill).
79 |         # Here, we can represent the entry fill as an example.
80 |         # A more complete system might generate two MarketDataTradeEvents (one for entry, one for exit)
   |                                                                                                    ^^^^ E501
81 |         # or use a different event type for completed round-trip trades.
   |

gal_friday/models/trade.py:83:9: F841 Local variable `event_data` is assigned to but never used
   |
81 |         # or use a different event type for completed round-trip trades.
82 |
83 |         event_data = {
   |         ^^^^^^^^^^ F841
84 |             "source_module": self.__class__.__name__,
85 |             "event_id": uuid.uuid4(), # New event ID for this specific event
   |
   = help: Remove assignment to unused variable `event_data`

gal_friday/monitoring/alerting_system.py:597:17: S101 Use of `assert` detected
    |
595 |             if account_sid and auth_token and from_number: # Using individual checks for clarity
596 |                 # Assertions to help mypy confirm the types are strings
597 |                 assert isinstance(account_sid, str), "TWILIO_ACCOUNT_SID must be a non-empty string"
    |                 ^^^^^^ S101
598 |                 assert isinstance(auth_token, str), "TWILIO_AUTH_TOKEN must be a non-empty string"
599 |                 assert isinstance(from_number, str), "alerting.sms.from_number must be a non-empty string"
    |

gal_friday/monitoring/alerting_system.py:597:100: E501 Line too long (100 > 99)
    |
595 |             if account_sid and auth_token and from_number: # Using individual checks for clarity
596 |                 # Assertions to help mypy confirm the types are strings
597 |                 assert isinstance(account_sid, str), "TWILIO_ACCOUNT_SID must be a non-empty string"
    |                                                                                                    ^ E501
598 |                 assert isinstance(auth_token, str), "TWILIO_AUTH_TOKEN must be a non-empty string"
599 |                 assert isinstance(from_number, str), "alerting.sms.from_number must be a non-empty string"
    |

gal_friday/monitoring/alerting_system.py:598:17: S101 Use of `assert` detected
    |
596 |                 # Assertions to help mypy confirm the types are strings
597 |                 assert isinstance(account_sid, str), "TWILIO_ACCOUNT_SID must be a non-empty string"
598 |                 assert isinstance(auth_token, str), "TWILIO_AUTH_TOKEN must be a non-empty string"
    |                 ^^^^^^ S101
599 |                 assert isinstance(from_number, str), "alerting.sms.from_number must be a non-empty string"
    |

gal_friday/monitoring/alerting_system.py:599:17: S101 Use of `assert` detected
    |
597 |                 assert isinstance(account_sid, str), "TWILIO_ACCOUNT_SID must be a non-empty string"
598 |                 assert isinstance(auth_token, str), "TWILIO_AUTH_TOKEN must be a non-empty string"
599 |                 assert isinstance(from_number, str), "alerting.sms.from_number must be a non-empty string"
    |                 ^^^^^^ S101
600 |
601 |                 self.channels[AlertChannel.SMS] = SMSChannel(
    |

gal_friday/monitoring/alerting_system.py:599:100: E501 Line too long (106 > 99)
    |
597 |                 assert isinstance(account_sid, str), "TWILIO_ACCOUNT_SID must be a non-empty string"
598 |                 assert isinstance(auth_token, str), "TWILIO_AUTH_TOKEN must be a non-empty string"
599 |                 assert isinstance(from_number, str), "alerting.sms.from_number must be a non-empty string"
    |                                                                                                    ^^^^^^^ E501
600 |
601 |                 self.channels[AlertChannel.SMS] = SMSChannel(
    |

gal_friday/monitoring/alerting_system.py:611:100: E501 Line too long (107 > 99)
    |
609 |                 self.logger.warning(
610 |                     "SMS alerting enabled but missing one or more required configurations "
611 |                     "(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, or alerting.sms.from_number was empty/None). "
    |                                                                                                    ^^^^^^^^ E501
612 |                     "SMS channel will not be initialized.",
613 |                     source_module=self._source_module,
    |

gal_friday/monitoring/dashboard_pages.py:25:100: E501 Line too long (118 > 99)
   |
23 |     DASHBOARD_CSS = """
24 |     <style>
25 |     body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background: #f5f7fa; }
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
26 |     .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
27 |     .header { background: #2c3e50; color: white; padding: 1rem; border-radius: 5px 5px 0 0; margin-bottom: 1rem; }
   |

gal_friday/monitoring/dashboard_pages.py:27:100: E501 Line too long (114 > 99)
   |
25 |     body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background: #f5f7fa; }
26 |     .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
27 |     .header { background: #2c3e50; color: white; padding: 1rem; border-radius: 5px 5px 0 0; margin-bottom: 1rem; }
   |                                                                                                    ^^^^^^^^^^^^^^^ E501
28 |     .card { background: white; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 1rem; padding: 1rem; }
29 |     .row { display: flex; flex-wrap: wrap; margin: 0 -10px; }
   |

gal_friday/monitoring/dashboard_pages.py:28:100: E501 Line too long (127 > 99)
   |
26 |     .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
27 |     .header { background: #2c3e50; color: white; padding: 1rem; border-radius: 5px 5px 0 0; margin-bottom: 1rem; }
28 |     .card { background: white; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 1rem; padding: 1rem; }
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
29 |     .row { display: flex; flex-wrap: wrap; margin: 0 -10px; }
30 |     .col { flex: 1; padding: 0 10px; min-width: 250px; }
   |

gal_friday/monitoring/dashboard_pages.py:38:100: E501 Line too long (110 > 99)
   |
36 |     .alert-warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
37 |     .alert-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
38 |     .metric-card { padding: 15px; border-radius: 4px; margin-bottom: 10px; color: white; text-align: center; }
   |                                                                                                    ^^^^^^^^^^^ E501
39 |     .metric-card h3 { margin-top: 0; }
40 |     .metric-card p { font-size: 1.8rem; font-weight: bold; margin: 10px 0; }
   |

gal_friday/monitoring/dashboard_pages.py:46:100: E501 Line too long (125 > 99)
   |
44 | 
45 | 
46 | hite; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; }
   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
47 | 00; text-align: center; white-space: nowrap; vertical-align: middle; user-select: none; border: 1px solid transparent; padding: .375r
48 | : #4e73df; border-color: #4e73df; }
   |

gal_friday/monitoring/dashboard_pages.py:47:100: E501 Line too long (379 > 99)
   |
45 | 
46 | radius: 3px; cursor: pointer; }
47 | ertical-align: middle; user-select: none; border: 1px solid transparent; padding: .375rem .75rem; font-size: 1rem; line-height: 1.5; border-radius: .25rem; transition: color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out; }
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
48 | 
49 | 
   |

gal_friday/monitoring/dashboard_pages.py:53:100: E501 Line too long (152 > 99)
   |
51 | ; width: 60px; height: 34px; }
52 | 
53 | t: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
54 | 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
55 | 
   |

gal_friday/monitoring/dashboard_pages.py:54:100: E501 Line too long (168 > 99)
   |
52 | 
53 | ght: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
54 | dth: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
55 | 
56 | 
   |

gal_friday/monitoring/dashboard_pages.py:313:100: E501 Line too long (132 > 99)
    |
311 |                 </div>
312 |                 <p><strong>Description:</strong> {model.description or 'No description'}</p>
313 |                 <p><strong>Last Updated:</strong> {(model.updated_at.strftime('%Y-%m-%d %H:%M') if model.updated_at else 'N/A')}</p>
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
314 |                 <p><strong>Training Data:</strong> {model.training_data_path or 'N/A'}</p>
315 |                 <p><strong>Pairs:</strong> {
    |

gal_friday/portfolio/funds_manager.py:41:24: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `session_maker`
   |
39 |         self,
40 |         logger_service: LoggerService,
41 |         session_maker: Any, # async_sessionmaker | None = None, for consistency, but unused
   |                        ^^^ ANN401
42 |         valuation_currency: str = "USD",
43 |     ) -> None:
   |

gal_friday/portfolio/funds_manager.py:49:100: E501 Line too long (101 > 99)
   |
47 |         ----
48 |             logger_service: Service for logging.
49 |             session_maker: SQLAlchemy async_sessionmaker (unused in this class, for API consistency).
   |                                                                                                    ^^ E501
50 |             valuation_currency: The currency for overall valuation (default: "USD").
51 |         """
   |

gal_friday/portfolio/position_manager.py:38:100: E501 Line too long (102 > 99)
   |
38 | # PositionInfo dataclass might be replaced by the Position SQLAlchemy model for direct DB interaction.
   |                                                                                                    ^^^ E501
39 | # However, it can still be useful for business logic or as a DTO if its structure differs
40 | # from the DB model or if we want to decouple business logic from DB schema.
   |

gal_friday/portfolio/position_manager.py:44:100: E501 Line too long (106 > 99)
   |
43 | class PositionManager:
44 |     """Manages trading positions, including updates from trades and PnL calculations, using SQLAlchemy."""
   |                                                                                                    ^^^^^^^ E501
45 |
46 |     def __init__(
   |

gal_friday/portfolio/position_manager.py:66:100: E501 Line too long (123 > 99)
   |
64 |         self.config_manager = config_manager
65 |         # self._positions: dict[str, PositionInfo] = {} # In-memory store removed
66 |         self._lock = asyncio.Lock() # Lock can still be useful for critical async operations on a single position if needed
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
67 |
68 |     # The `positions` property and `get_open_positions` will now fetch from DB.
   |

gal_friday/portfolio/position_manager.py:82:100: E501 Line too long (115 > 99)
   |
80 |     async def get_position(self, trading_pair: str) -> PositionModel | None:
81 |         """Get a specific active position by trading_pair from the database."""
82 |         self.logger.debug(f"Fetching position for trading_pair: {trading_pair}", source_module=self._source_module)
   |                                                                                                    ^^^^^^^^^^^^^^^^ E501
83 |         return await self.position_repository.get_position_by_pair(trading_pair)
84 |         # If PositionInfo DTO is still desired:
   |

gal_friday/portfolio/position_manager.py:91:100: E501 Line too long (111 > 99)
   |
89 |         self,
90 |         # initial_positions: dict[str, dict[str, Any]], # This would now be pre-loading DB
91 |         # split_symbol_func: Callable[[str], tuple[str, str]], # Asset splitting can be internal or from config
   |                                                                                                    ^^^^^^^^^^^^ E501
92 |     ) -> None:
93 |         """Initializes positions by loading them from the database.
   |

gal_friday/portfolio/position_manager.py:93:9: D205 1 blank line required between summary line and description
    |
 91 |           # split_symbol_func: Callable[[str], tuple[str, str]], # Asset splitting can be internal or from config
 92 |       ) -> None:
 93 | /         """Initializes positions by loading them from the database.
 94 | |         The concept of initializing from a config dict is replaced by ensuring
 95 | |         positions are correctly populated in the DB, possibly by a seeding process
 96 | |         or by prior application state. This method could verify DB connection
 97 | |         or log current position count.
 98 | |         """
    | |___________^ D205
 99 |           # This method might no longer be needed if positions are purely DB driven.
100 |           # Or, it could be used to load positions from DB into a cache if desired,
    |
    = help: Insert single blank line

gal_friday/portfolio/position_manager.py:180:100: E501 Line too long (130 > 99)
    |
178 |             commission_arg = kwargs.get("commission", Decimal(0))
179 |
180 |             # Ensure required fields are present (those not in _UpdatePositionKwargs or without defaults in _UpdatePositionParams)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
181 |             # 'trading_pair', 'side', 'timestamp', 'trade_id' are required by _UpdatePositionKwargs if total=True,
182 |             # or by _UpdatePositionParams if they have no defaults.
    |

gal_friday/portfolio/position_manager.py:181:100: E501 Line too long (114 > 99)
    |
180 |             # Ensure required fields are present (those not in _UpdatePositionKwargs or without defaults in _UpdatePositionParams)
181 |             # 'trading_pair', 'side', 'timestamp', 'trade_id' are required by _UpdatePositionKwargs if total=True,
    |                                                                                                    ^^^^^^^^^^^^^^^ E501
182 |             # or by _UpdatePositionParams if they have no defaults.
183 |             # Assuming they are always provided as per TypedDict or dataclass requirements.
    |

gal_friday/portfolio/position_manager.py:196:100: E501 Line too long (119 > 99)
    |
194 |                 fee=Decimal(str(fee_arg)) if not isinstance(fee_arg, Decimal) else fee_arg,
195 |                 fee_currency=kwargs.get("fee_currency"),
196 |                 commission=Decimal(str(commission_arg)) if not isinstance(commission_arg, Decimal) else commission_arg,
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
197 |                 commission_asset=kwargs.get("commission_asset"),
198 |             )
    |

gal_friday/portfolio/position_manager.py:200:100: E501 Line too long (138 > 99)
    |
198 | 
199 | # Added KeyError for direct kwargs access
200 | update_position_for_trade: {e}", source_module=self._source_module, context=kwargs)
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
201 | 
    |

gal_friday/portfolio/position_manager.py:238:100: E501 Line too long (100 > 99)
    |
237 |         async with self._lock: # Lock to ensure atomic read-modify-write for a given trading_pair
238 |             position_model = await self._get_or_create_db_position(params.trading_pair, params.side)
    |                                                                                                    ^ E501
239 |
240 |             # Trade history is not directly part of the PositionModel in the schema.
    |

gal_friday/portfolio/position_manager.py:254:100: E501 Line too long (104 > 99)
    |
252 |                 # old_value = avg_entry_price * current_quantity
253 |                 # new_value = params.price * params.quantity
254 |                 new_total_cost = (avg_entry_price * current_quantity) + (params.price * params.quantity)
    |                                                                                                    ^^^^^ E501
255 |                 new_quantity = current_quantity + params.quantity
    |

gal_friday/portfolio/position_manager.py:267:100: E501 Line too long (123 > 99)
    |
265 |                 if current_quantity < params.quantity:
266 |                     self.logger.warning(
267 |                         f"Selling {params.quantity} of {params.trading_pair}, but current position is {current_quantity}. "
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
268 |                         "Position will go negative or this represents a short sale opening/extension.",
269 |                         source_module=self._source_module,
    |

gal_friday/portfolio/position_manager.py:268:100: E501 Line too long (103 > 99)
    |
266 |                     self.logger.warning(
267 |                         f"Selling {params.quantity} of {params.trading_pair}, but current position is {current_quantity}. "
268 |                         "Position will go negative or this represents a short sale opening/extension.",
    |                                                                                                    ^^^^ E501
269 |                         source_module=self._source_module,
270 |                     )
    |

gal_friday/portfolio/position_manager.py:274:100: E501 Line too long (110 > 99)
    |
272 |                 # Realized PnL = (sell_price - avg_entry_price) * sell_quantity
273 |                 realized_pnl_trade = (params.price - avg_entry_price) * params.quantity
274 |                 position_model.realized_pnl = (position_model.realized_pnl or Decimal(0)) + realized_pnl_trade
    |                                                                                                    ^^^^^^^^^^^ E501
275 |                 new_quantity = current_quantity - params.quantity
276 |                 position_model.quantity = new_quantity
    |

gal_friday/portfolio/position_manager.py:282:100: E501 Line too long (123 > 99)
    |
280 |                     position_model.is_active = False # Close position if quantity is zero
281 |                     position_model.closed_at = params.timestamp # Record closing time
282 |                 # If new_quantity is < 0 (short position), AEP logic might need adjustment based on strategy for short AEP.
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
283 |                 # Current AEP calculation is simplified for long positions.
    |

gal_friday/portfolio/position_manager.py:286:100: E501 Line too long (106 > 99)
    |
285 |             else: # Should be caught by _validate_trade_params
286 |                 self.logger.error(f"Invalid trade side: {params.side}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^ E501
287 |                 return Decimal(0), None
    |

gal_friday/portfolio/position_manager.py:292:100: E501 Line too long (131 > 99)
    |
291 |             try:
292 |                 updated_pos = await self.position_repository.update(str(position_model.id), position_model.to_dict(exclude={"id"}))
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
293 |                 if not updated_pos: # Should not happen if ID is correct and row exists
294 |                     self.logger.error(f"Failed to update position {position_model.id} in DB.", source_module=self._source_module)
    |

gal_friday/portfolio/position_manager.py:294:100: E501 Line too long (129 > 99)
    |
292 |                 updated_pos = await self.position_repository.update(str(position_model.id), position_model.to_dict(exclude={"id"}))
293 |                 if not updated_pos: # Should not happen if ID is correct and row exists
294 |                     self.logger.error(f"Failed to update position {position_model.id} in DB.", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
295 |                     return realized_pnl_trade, None # Or raise an error
    |

gal_friday/portfolio/position_manager.py:306:100: E501 Line too long (137 > 99)
    |
304 | 
305 | 
306 | position in DB for {params.trading_pair}: {e}", source_module=self._source_module)
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
307 | 
    |

gal_friday/portfolio/position_manager.py:331:100: E501 Line too long (106 > 99)
    |
330 |     # _get_or_create_position needs to interact with the database now.
331 |     async def _get_or_create_db_position(self, trading_pair: str, side_if_creating: str) -> PositionModel:
    |                                                                                                    ^^^^^^^ E501
332 |         """Get existing active position from DB or create a new one if it doesn't exist."""
333 |         position = await self.position_repository.get_position_by_pair(trading_pair)
    |

gal_friday/portfolio/position_manager.py:336:100: E501 Line too long (161 > 99)
    |
334 | 
335 | tion? Or new one?
336 | exists but is inactive. Treating as new for this context.", source_module=self._source_module)
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
337 | tivate or error?
338 | ing is inactive.
    |

gal_friday/portfolio/position_manager.py:339:100: E501 Line too long (112 > 99)
    |
337 |                  # This logic might need refinement: should we reactivate or error?
338 |                  # For now, assume we create a new one if the existing is inactive.
339 |                  # This implies `get_position_by_pair` should only return active ones, or this logic handles it.
    |                                                                                                    ^^^^^^^^^^^^^ E501
340 |                  # If `get_position_by_pair` already filters by is_active=True, then this `if` is for a case
341 |                  # where an inactive one was somehow fetched, or if we want to prevent re-opening.
    |

gal_friday/portfolio/position_manager.py:340:100: E501 Line too long (108 > 99)
    |
338 |                  # For now, assume we create a new one if the existing is inactive.
339 |                  # This implies `get_position_by_pair` should only return active ones, or this logic handles it.
340 |                  # If `get_position_by_pair` already filters by is_active=True, then this `if` is for a case
    |                                                                                                    ^^^^^^^^^ E501
341 |                  # where an inactive one was somehow fetched, or if we want to prevent re-opening.
342 |                  # Let's assume get_position_by_pair returns only active.
    |

gal_friday/portfolio/position_manager.py:348:100: E501 Line too long (126 > 99)
    |
347 |         # Position not found or inactive, create a new one
348 |         self.logger.info(f"No active position found for {trading_pair}. Creating new one.", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
349 |
350 |         # Asset splitting logic - assuming it's from config or a utility
    |

gal_friday/portfolio/position_manager.py:357:100: E501 Line too long (106 > 99)
    |
355 |         # Or, if it's a short, it's 'SHORT', if long, it's 'LONG'. This is simplified here.
356 |         # The PositionModel has `side` (LONG/SHORT). A trade has `side` (BUY/SELL).
357 |         # This needs careful mapping. If first trade is BUY, position is LONG. If SELL, position is SHORT.
    |                                                                                                    ^^^^^^^ E501
358 |         # The `side_if_creating` argument would be the intended position side (LONG/SHORT).
    |

gal_friday/portfolio/position_manager.py:374:100: E501 Line too long (143 > 99)
    |
372 | 
373 | ory.create(new_pos_data)
374 | for {trading_pair} with ID {created_position.id}", source_module=self._source_module)
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
375 | 
376 | 
    |

gal_friday/portfolio/position_manager.py:377:100: E501 Line too long (130 > 99)
    |
375 |             return created_position
376 |         except Exception as e:
377 |             self.logger.exception(f"Error creating new position in DB for {trading_pair}: {e}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
378 |             # Decide on error handling: re-raise, or return a specific error object/None
379 |             raise # Re-raise for now
    |

gal_friday/portfolio/position_manager.py:391:100: E501 Line too long (119 > 99)
    |
390 |         # For all pairs:
391 |         all_positions = await self.position_repository.find_all(filters={"is_active": True}) # Or all, including closed
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
392 |         total_pnl = sum((pos.realized_pnl for pos in all_positions if pos.realized_pnl is not None), Decimal(0))
393 |         return total_pnl
    |

gal_friday/portfolio/position_manager.py:392:100: E501 Line too long (112 > 99)
    |
390 |         # For all pairs:
391 |         all_positions = await self.position_repository.find_all(filters={"is_active": True}) # Or all, including closed
392 |         total_pnl = sum((pos.realized_pnl for pos in all_positions if pos.realized_pnl is not None), Decimal(0))
    |                                                                                                    ^^^^^^^^^^^^^ E501
393 |         return total_pnl
    |

gal_friday/portfolio/position_manager.py:393:16: RET504 Unnecessary assignment to `total_pnl` before `return` statement
    |
391 |         all_positions = await self.position_repository.find_all(filters={"is_active": True}) # Or all, including closed
392 |         total_pnl = sum((pos.realized_pnl for pos in all_positions if pos.realized_pnl is not None), Decimal(0))
393 |         return total_pnl
    |                ^^^^^^^^^ RET504
394 |
395 |     # _TradeRecordParams and _TradeRecordKwargs might be less relevant if TradeInfo is not directly stored with PositionModel
    |
    = help: Remove unnecessary assignment

gal_friday/portfolio/position_manager.py:395:100: E501 Line too long (125 > 99)
    |
393 |         return total_pnl
394 |
395 |     # _TradeRecordParams and _TradeRecordKwargs might be less relevant if TradeInfo is not directly stored with PositionModel
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
396 |     # or if trade recording is handled by a separate TradeRepository.
397 |     # For now, keeping if the internal logic still uses them to construct TradeInfo objects if needed.
    |

gal_friday/portfolio/position_manager.py:397:100: E501 Line too long (102 > 99)
    |
395 |     # _TradeRecordParams and _TradeRecordKwargs might be less relevant if TradeInfo is not directly stored with PositionModel
396 |     # or if trade recording is handled by a separate TradeRepository.
397 |     # For now, keeping if the internal logic still uses them to construct TradeInfo objects if needed.
    |                                                                                                    ^^^ E501
398 |     @dataclass
399 |     class _TradeRecordParams: # Can remain for internal use if TradeInfo objects are constructed
    |

gal_friday/portfolio/reconciliation_service.py:6:29: TC003 Move standard library import `collections.abc.Sequence` into a type-checking block
  |
4 | import contextlib
5 | import uuid
6 | from collections.abc import Sequence  # Added Sequence
  |                             ^^^^^^^^ TC003
7 | from dataclasses import dataclass, field
8 | from datetime import UTC, datetime, timedelta
  |
  = help: Move into type-checking block

gal_friday/portfolio/reconciliation_service.py:145:100: E501 Line too long (108 > 99)
    |
143 |     def __init__(self,
144 |                  config_manager: ConfigManager, # Renamed for clarity
145 |                  portfolio_manager: PortfolioManager, # Stays as is, its internal methods will be refactored
    |                                                                                                    ^^^^^^^^^ E501
146 |                  execution_handler: ExecutionHandler, # Stays as is
147 |                  alerting_system: AlertingSystem, # Renamed for clarity
    |

gal_friday/portfolio/reconciliation_service.py:296:100: E501 Line too long (102 > 99)
    |
294 |             )
295 |             # Attempt to save the failed report
296 |             await self._save_reconciliation_event_and_adjustments(report) # Adjustments might be empty
    |                                                                                                    ^^^ E501
297 |             await self._send_critical_alert(f"Reconciliation failed: {e!s}")
    |

gal_friday/portfolio/reconciliation_service.py:305:100: E501 Line too long (107 > 99)
    |
303 |         try:
304 |             # Get positions from both sources
305 |             # Assuming portfolio_manager.get_all_db_positions() is refactored to return List[PositionModel]
    |                                                                                                    ^^^^^^^^ E501
306 |             internal_positions_models: Sequence[PositionModel] = await self.portfolio_manager.get_all_db_positions() # type: ignore
307 |             exchange_positions_data = await self.execution_handler.get_exchange_positions() # type: ignore
    |

gal_friday/portfolio/reconciliation_service.py:306:100: E501 Line too long (116 > 99)
    |
304 |             # Get positions from both sources
305 |             # Assuming portfolio_manager.get_all_db_positions() is refactored to return List[PositionModel]
306 |             internal_positions_models: Sequence[PositionModel] = await self.portfolio_manager.get_all_db_positions() # type: ignore
    |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
307 |             exchange_positions_data = await self.execution_handler.get_exchange_positions() # type: ignore
    |

gal_friday/portfolio/reconciliation_service.py:309:100: E501 Line too long (100 > 99)
    |
307 |             exchange_positions_data = await self.execution_handler.get_exchange_positions() # type: ignore
308 |
309 |             report.positions_checked = len(internal_positions_models) + len(exchange_positions_data)
    |                                                                                                    ^ E501
310 |
311 |             # Create position maps
    |

gal_friday/portfolio/reconciliation_service.py:348:100: E501 Line too long (116 > 99)
    |
346 |                     report.position_discrepancies.append(discrepancy)
347 |
348 |                     if self._can_auto_correct(exchange_qty): # Check if the exchange quantity itself is small enough
    |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
349 |                         await self._add_missing_db_position(pair, exchange_pos_data, report)
350 |                     else:
    |

gal_friday/portfolio/reconciliation_service.py:373:100: E501 Line too long (103 > 99)
    |
372 |                         if self._can_auto_correct(qty_diff):
373 |                             await self._adjust_db_position_quantity(internal_pos, exchange_qty, report)
    |                                                                                                    ^^^^ E501
374 |                         else:
375 |                             report.manual_review_required.append({
    |

gal_friday/portfolio/reconciliation_service.py:381:100: E501 Line too long (108 > 99)
    |
379 |                             })
380 |         except Exception as e:
381 |             self.logger.exception("Error during position reconciliation", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^ E501
382 |             report.error_messages.append(f"Position reconciliation error: {e!s}")
383 |             raise
    |

gal_friday/portfolio/reconciliation_service.py:442:100: E501 Line too long (104 > 99)
    |
441 |                 # Check if order exists in our system using OrderRepository
442 |                 tracked_order_model = await self.order_repository.find_by_exchange_id(exchange_order_id)
    |                                                                                                    ^^^^^ E501
443 |
444 |                 if not tracked_order_model:
    |

gal_friday/portfolio/reconciliation_service.py:457:100: E501 Line too long (105 > 99)
    |
455 |                         })
456 |         except Exception as e:
457 |             self.logger.exception("Error during order reconciliation", source_module=self._source_module)
    |                                                                                                    ^^^^^^ E501
458 |             report.error_messages.append(f"Order reconciliation error: {e!s}")
459 |             raise
    |

gal_friday/portfolio/reconciliation_service.py:537:100: E501 Line too long (104 > 99)
    |
535 |                     )
536 |
537 |                 # Recording of adjustments will be handled by _save_reconciliation_event_and_adjustments
    |                                                                                                    ^^^^^ E501
538 |             except Exception as e:
539 |                 self.logger.error(
    |

gal_friday/portfolio/reconciliation_service.py:548:100: E501 Line too long (119 > 99)
    |
546 |                 )
547 |
548 |     async def _add_missing_db_position(self, pair: str, exchange_pos_data: dict, report: ReconciliationReport) -> None:
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
549 |         """Marks for auto-correction: Add position that exists on exchange but not internally.
550 |         Actual DB write happens via portfolio_manager or directly if this service owns position creation logic.
    |

gal_friday/portfolio/reconciliation_service.py:549:9: D205 1 blank line required between summary line and description
    |
548 |       async def _add_missing_db_position(self, pair: str, exchange_pos_data: dict, report: ReconciliationReport) -> None:
549 | /         """Marks for auto-correction: Add position that exists on exchange but not internally.
550 | |         Actual DB write happens via portfolio_manager or directly if this service owns position creation logic.
551 | |         For now, this method prepares the 'correction' dict for the report.
552 | |         """
    | |___________^ D205
553 |           # This method now just prepares the correction for the report.
554 |           # The actual DB creation should be handled by PortfolioManager or a dedicated method
    |
    = help: Insert single blank line

gal_friday/portfolio/reconciliation_service.py:550:100: E501 Line too long (111 > 99)
    |
548 |     async def _add_missing_db_position(self, pair: str, exchange_pos_data: dict, report: ReconciliationReport) -> None:
549 |         """Marks for auto-correction: Add position that exists on exchange but not internally.
550 |         Actual DB write happens via portfolio_manager or directly if this service owns position creation logic.
    |                                                                                                    ^^^^^^^^^^^^ E501
551 |         For now, this method prepares the 'correction' dict for the report.
552 |         """
    |

gal_friday/portfolio/reconciliation_service.py:556:100: E501 Line too long (104 > 99)
    |
554 |         # The actual DB creation should be handled by PortfolioManager or a dedicated method
555 |         # that uses self.position_repository.create()
556 |         # For this refactor, we assume `portfolio_manager.create_new_position_from_exchange_data` exists
    |                                                                                                    ^^^^^ E501
557 |         # or this is noted for `_apply_auto_corrections`.
    |

gal_friday/portfolio/reconciliation_service.py:570:100: E501 Line too long (117 > 99)
    |
568 |         }
569 |         report.auto_corrections.append(correction_data)
570 |         self.logger.info(f"Marked missing position for {pair} for auto-creation.", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
    |

gal_friday/portfolio/reconciliation_service.py:574:100: E501 Line too long (101 > 99)
    |
573 |     async def _adjust_db_position_quantity(
574 |         self, internal_pos_model: PositionModel, exchange_qty: Decimal, report: ReconciliationReport,
    |                                                                                                    ^^ E501
575 |     ) -> None:
576 |         """Marks for auto-correction: Adjust internal position quantity to match exchange."""
    |

gal_friday/portfolio/reconciliation_service.py:588:100: E501 Line too long (138 > 99)
    |
586 | 
587 | 
588 | s_model.trading_pair} for quantity adjustment.", source_module=self._source_module)
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
589 | 
590 | action is via PortfolioManager
    |

gal_friday/portfolio/reconciliation_service.py:591:100: E501 Line too long (112 > 99)
    |
590 |     async def _adjust_balance( # This method's DB interaction is via PortfolioManager
591 |         self, currency: str, internal_balance: Decimal, exchange_balance: Decimal, report: ReconciliationReport,
    |                                                                                                    ^^^^^^^^^^^^^ E501
592 |     ) -> None:
593 |         """Marks for auto-correction: Adjust internal balance to match exchange."""
    |

gal_friday/portfolio/reconciliation_service.py:605:100: E501 Line too long (109 > 99)
    |
603 |         }
604 |         report.auto_corrections.append(correction_data)
605 |         self.logger.info(f"Marked balance for {currency} for adjustment.", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^ E501
606 |
607 |     async def _save_reconciliation_event_and_adjustments(self, report: ReconciliationReport) -> None:
    |

gal_friday/portfolio/reconciliation_service.py:607:100: E501 Line too long (101 > 99)
    |
605 |         self.logger.info(f"Marked balance for {currency} for adjustment.", source_module=self._source_module)
606 |
607 |     async def _save_reconciliation_event_and_adjustments(self, report: ReconciliationReport) -> None:
    |                                                                                                    ^^ E501
608 |         """Saves the main reconciliation event and all its adjustments to the database."""
609 |         try:
    |

gal_friday/portfolio/reconciliation_service.py:619:100: E501 Line too long (123 > 99)
    |
617 |                 "manual_review_required": len(report.manual_review_required),
618 |                 "report": report.to_dict(), # Full report as JSON
619 |                 "duration_seconds": Decimal(str(report.duration_seconds)) if report.duration_seconds is not None else None,
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
620 |             }
621 |             created_event = await self.reconciliation_repository.save_reconciliation_event(event_data)
    |

gal_friday/portfolio/reconciliation_service.py:621:100: E501 Line too long (102 > 99)
    |
619 |                 "duration_seconds": Decimal(str(report.duration_seconds)) if report.duration_seconds is not None else None,
620 |             }
621 |             created_event = await self.reconciliation_repository.save_reconciliation_event(event_data)
    |                                                                                                    ^^^ E501
622 |             self.logger.info(f"Saved reconciliation event {created_event.reconciliation_id}", source_module=self._source_module)
    |

gal_friday/portfolio/reconciliation_service.py:622:100: E501 Line too long (128 > 99)
    |
620 |             }
621 |             created_event = await self.reconciliation_repository.save_reconciliation_event(event_data)
622 |             self.logger.info(f"Saved reconciliation event {created_event.reconciliation_id}", source_module=self._source_module)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
623 |
624 |             # Save all adjustments (auto-corrections and those needing manual review if they are stored)
    |

gal_friday/portfolio/reconciliation_service.py:624:100: E501 Line too long (104 > 99)
    |
622 |             self.logger.info(f"Saved reconciliation event {created_event.reconciliation_id}", source_module=self._source_module)
623 |
624 |             # Save all adjustments (auto-corrections and those needing manual review if they are stored)
    |                                                                                                    ^^^^^ E501
625 |             # For now, only saving auto_corrections as explicit adjustments.
626 |             for adj_data in report.auto_corrections:
    |

gal_friday/portfolio/reconciliation_service.py:630:100: E501 Line too long (101 > 99)
    |
628 |                 adjustment_to_save = {
629 |                     "reconciliation_id": created_event.reconciliation_id,
630 |                     "trading_pair": adj_data.get("pair") or adj_data.get("currency", "UNKNOWN_PAIR"),
    |                                                                                                    ^^ E501
631 |                     "adjustment_type": adj_data.get("adjustment_type", "UNKNOWN_ADJUSTMENT"),
632 |                     "old_value": adj_data.get("old_value"), # Should be Decimal or None
    |

gal_friday/portfolio/reconciliation_service.py:643:100: E501 Line too long (160 > 99)
    |
642 | _adjustment(adjustment_to_save)
643 | } adjustments for event {created_event.reconciliation_id}", source_module=self._source_module)
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
644 | 
645 | 
    |

gal_friday/portfolio/reconciliation_service.py:646:100: E501 Line too long (161 > 99)
    |
645 | 
646 | ort/adjustments for event {report.reconciliation_id}: {e}", source_module=self._source_module)
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
647 | 
    |

gal_friday/portfolio/reconciliation_service.py:721:100: E501 Line too long (118 > 99)
    |
719 |             # Ideally, repo methods return SQLAlchemy models.
720 |             # Get the most recent reconciliation event (limit to 1 day for efficiency)
721 |             recent_events = await self.reconciliation_repository.get_recent_reconciliation_events(days=1, status=None)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
722 |             latest_event_model = recent_events[0] if recent_events else None
723 |             if latest_event_model:
    |

gal_friday/portfolio/reconciliation_service.py:723:13: SIM108 Use ternary operator `last_report_data = latest_event_model.report if latest_event_model else None` instead of `if`-`else`-block
    |
721 |               recent_events = await self.reconciliation_repository.get_recent_reconciliation_events(days=1, status=None)
722 |               latest_event_model = recent_events[0] if recent_events else None
723 | /             if latest_event_model:
724 | |                 # Convert model to dict for status, or use a Pydantic model constructed from it
725 | |                 last_report_data = latest_event_model.report # The JSONB field
726 | |             else:
727 | |                 last_report_data = None
    | |_______________________________________^ SIM108
728 |           else:
729 |               last_report_data = None
    |
    = help: Replace `if`-`else`-block with `last_report_data = latest_event_model.report if latest_event_model else None`

gal_friday/portfolio/reconciliation_service.py:729:13: F841 Local variable `last_report_data` is assigned to but never used
    |
727 |                 last_report_data = None
728 |         else:
729 |             last_report_data = None
    |             ^^^^^^^^^^^^^^^^ F841
730 |
731 |         last_run = (
    |
    = help: Remove assignment to unused variable `last_report_data`

gal_friday/portfolio_manager.py:74:9: D417 Missing argument description in the docstring for `__init__`: `session_maker`
   |
72 |     """
73 |
74 |     def __init__(
   |         ^^^^^^^^ D417
75 |         self,
76 |         *,  # Force keyword arguments for better readability
   |

gal_friday/portfolio_manager.py:105:100: E501 Line too long (135 > 99)
    |
103 | 
104 | ce, self.valuation_currency)
105 | _service, session_maker, config_manager) # Added session_maker and config_manager
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
106 | 
107 | 
    |

gal_friday/portfolio_manager.py:147:13: F841 Local variable `initial_positions_config` is assigned to but never used
    |
145 |             await self.funds_manager.initialize_funds(initial_capital)
146 |
147 |             initial_positions_config = self.config_manager.get("portfolio.initial_positions", {})
    |             ^^^^^^^^^^^^^^^^^^^^^^^^ F841
148 |             await self.position_manager.initialize_positions() # Removed arguments
    |
    = help: Remove assignment to unused variable `initial_positions_config`

gal_friday/portfolio_manager.py:164:100: E501 Line too long (125 > 99)
    |
162 |             self.logger.info(
163 |                 "Initial Positions: %s",
164 |                 {p: {"qty": str(info.quantity), "aep": str(info.entry_price)} for p, info in self._cached_positions.items()},
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
165 |                 source_module=self._source_module,
166 |             )
    |

gal_friday/portfolio_manager.py:399:100: E501 Line too long (114 > 99)
    |
397 |                     else: # Position closed or inactive
398 |                         self._cached_positions.pop(updated_pos_model.trading_pair, None)
399 |             elif event.order_status in ["FILLED", "PARTIALLY_FILLED"]: # If update failed but should have happened
    |                                                                                                    ^^^^^^^^^^^^^^^ E501
400 |                 self.logger.warning(
401 |                     f"Position model for {event.trading_pair} was not updated in cache after trade {event.exchange_order_id}.",
    |

gal_friday/portfolio_manager.py:401:100: E501 Line too long (127 > 99)
    |
399 |             elif event.order_status in ["FILLED", "PARTIALLY_FILLED"]: # If update failed but should have happened
400 |                 self.logger.warning(
401 |                     f"Position model for {event.trading_pair} was not updated in cache after trade {event.exchange_order_id}.",
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
402 |                     source_module=self._source_module,
403 |                 )
    |

gal_friday/portfolio_manager.py:551:100: E501 Line too long (104 > 99)
    |
549 |         }
550 |         positions_str = {}
551 |         # Create a shallow copy for safe iteration, as self._cached_positions might be updated elsewhere
    |                                                                                                    ^^^^^ E501
552 |         # by async methods. This is a synchronous method.
553 |         cached_positions_copy = self._cached_positions.copy()
    |

gal_friday/portfolio_manager.py:600:100: E501 Line too long (106 > 99)
    |
599 |         positions_dict = {}
600 |         # Create a shallow copy for safe iteration if self._cached_positions can be modified by async code
    |                                                                                                    ^^^^^^^ E501
601 |         cached_positions_copy = self._cached_positions.copy()
602 |         for pair, pos_model in cached_positions_copy.items(): # Use cache
    |

gal_friday/portfolio_manager.py:612:100: E501 Line too long (101 > 99)
    |
610 |                     market_value = pos_model.quantity * latest_price
611 |                     if (
612 |                         pos_model.entry_price > 0 or pos_model.quantity != 0 # Changed to entry_price
    |                                                                                                    ^^ E501
613 |                     ):  # Avoid PNL calc on zero avg price unless qty exists
614 |                         unrealized_pnl = (
    |

gal_friday/portfolio_manager.py:628:100: E501 Line too long (100 > 99)
    |
626 |                     "unrealized_pnl": str(unrealized_pnl) if unrealized_pnl is not None else None,
627 |                     "realized_pnl": str(pos_model.realized_pnl),
628 |                     "trade_count": 0, # PositionModel does not have trade_history, using placeholder
    |                                                                                                    ^ E501
629 |                 }
    |

gal_friday/portfolio_manager.py:697:100: E501 Line too long (102 > 99)
    |
695 |             List of historical trades for the specified pair
696 |         """
697 |         position_model = await self.position_manager.get_position(pair)  # Await and get PositionModel
    |                                                                                                    ^^^ E501
698 |         if not position_model:
699 |             return []
    |

gal_friday/portfolio_manager.py:702:100: E501 Line too long (100 > 99)
    |
701 |         # PositionModel does not have a direct 'trade_history' attribute.
702 |         # This would need to be fetched from a TradeRepository based on position_id or trading_pair.
    |                                                                                                    ^ E501
703 |         # For now, returning empty list to fix attr-defined.
704 |         self.logger.debug( # Changed to debug as this is an expected temporary state
    |

gal_friday/portfolio_manager.py:705:100: E501 Line too long (111 > 99)
    |
703 |         # For now, returning empty list to fix attr-defined.
704 |         self.logger.debug( # Changed to debug as this is an expected temporary state
705 |             f"Trade history retrieval for PositionModel is not fully implemented. Returning empty for {pair}.",
    |                                                                                                    ^^^^^^^^^^^^ E501
706 |             source_module=self._source_module,
707 |         )
    |

gal_friday/portfolio_manager.py:708:100: E501 Line too long (101 > 99)
    |
706 |             source_module=self._source_module,
707 |         )
708 |         actual_trade_history: list[Any] = [] # Placeholder, assuming trades would be dicts or objects
    |                                                                                                    ^^ E501
709 |
710 |         result = []
    |

gal_friday/portfolio_manager.py:712:100: E501 Line too long (111 > 99)
    |
710 |         result = []
711 |         for trade in actual_trade_history: # This loop won't run with placeholder
712 |             # Assuming 'trade' object would have timestamp, side, quantity, price, commission, commission_asset
    |                                                                                                    ^^^^^^^^^^^^ E501
713 |             result.append(
714 |                 {
    |

gal_friday/portfolio_manager.py:733:100: E501 Line too long (104 > 99)
    |
731 |         """
732 |         # Since we're making this method async and the position manager likely has an async method
733 |         # we can properly await it. If position_manager.get_open_positions is sync, we'd need to adjust.
    |                                                                                                    ^^^^^ E501
734 |         # Based on the file structure, this is likely async
735 |         return list(await self.position_manager.get_open_positions())
    |

gal_friday/prediction_service.py:1053:100: E501 Line too long (115 > 99)
     |
1051 |                 ),
1052 |                 associated_features={
1053 |                     "triggering_features": event.features, # dict[str, float] from PublishedFeaturesV1.model_dump()
     |                                                                                                    ^^^^^^^^^^^^^^^^ E501
1054 |                     "metadata": {
1055 |                         "source_feature_event_id": str(event.event_id),
     |

gal_friday/prediction_service.py:1192:100: E501 Line too long (103 > 99)
     |
1190 |         missing_features_log: list[str] = []
1191 |         # Type errors are less likely now as Pydantic handles validation in FeatureEngine
1192 |         # but keeping the log list in case of unexpected issues or if event_features bypasses Pydantic.
     |                                                                                                    ^^^^ E501
1193 |         type_errors_log: list[str] = []
     |

gal_friday/prediction_service.py:1203:100: E501 Line too long (100 > 99)
     |
1201 |                 continue
1202 |
1203 |             # Check for NaN explicitly, as Pydantic allows NaN for float if not otherwise restricted
     |                                                                                                    ^ E501
1204 |             if np.isnan(value):
1205 |                 # This case means the feature was present but its value was NaN.
     |

gal_friday/predictors/lstm_predictor.py:54:1: E402 Module level import not at top of file
   |
54 | import torch  # Add import for torch.Tensor
   | ^^^^^^^^^^^^ E402
   |

gal_friday/predictors/lstm_predictor.py:427:100: E501 Line too long (112 > 99)
    |
425 |         cls,
426 |         feature_sequence: np.ndarray, # Expected to be pre-scaled
427 |         scaler_asset: object | joblib.scaler.StandardScaler | None, # Kept for compatibility, but should be None
    |                                                                                                    ^^^^^^^^^^^^^ E501
428 |         model_id: str,
429 |         logger: logging.Logger,
    |

gal_friday/predictors/lstm_predictor.py:533:100: E501 Line too long (110 > 99)
    |
531 |             if model_framework == "tf":
532 |                 result = cls._load_tf_model(model_path, model_id, logger)
533 |             elif model_framework == "pt": # Corrected from 'pytorch' to 'pt' for consistency if used elsewhere
    |                                                                                                    ^^^^^^^^^^^ E501
534 |                 result = cls._load_pytorch_model(
535 |                     model_path,
    |

gal_friday/predictors/sklearn_predictor.py:117:100: E501 Line too long (109 > 99)
    |
115 |             model_id: Unique identifier for this model.
116 |             config: Additional configuration parameters for this model.
117 |                     Expected to contain 'model_feature_names': List[str] (if not in model.feature_names_in_).
    |                                                                                                    ^^^^^^^^^^ E501
118 |                     'scaler_path' is no longer used as features are expected pre-scaled.
119 |         """
    |

gal_friday/predictors/sklearn_predictor.py:187:9: D205 1 blank line required between summary line and description
    |
186 |       def predict(self, features: np.ndarray) -> np.ndarray:
187 | /         """Generate predictions using the scikit-learn model.
188 | |         Features are expected to be pre-scaled by the FeatureEngine.
189 | |
190 | |         Args:
191 | |         ----
192 | |             features: A 1D numpy array of pre-scaled, ordered feature values.
193 | |
194 | |         Returns:
195 | |         -------
196 | |             Prediction results as a numpy array.
197 | |             For classifiers with predict_proba, returns class probabilities
198 | |             (typically of the positive class). For regressors or
199 | |             classifiers without predict_proba, returns predicted values.
200 | |
201 | |         Raises:
202 | |         ------
203 | |             ValueError: If features have wrong shape or contain invalid values.
204 | |             TypeError: If model is not properly loaded or is of an unexpected type.
205 | |             Exception: If prediction fails for any other reason.
206 | |         """
    | |___________^ D205
207 |           if self.model is None:
208 |               error_msg = "Model not loaded"
    |
    = help: Insert single blank line

gal_friday/predictors/sklearn_predictor.py:508:13: F841 Local variable `scaler` is assigned to but never used
    |
506 |             if request.scaler_path:
507 |                 logger.info("scaler_path provided in InferenceRequest but will be ignored.")
508 |             scaler = None # Explicitly set to None as it's not used.
    |             ^^^^^^ F841
509 |
510 |             # 3. Prepare features - Scaling part of _prepare_features is effectively bypassed.
    |
    = help: Remove assignment to unused variable `scaler`

gal_friday/predictors/sklearn_predictor.py:514:100: E501 Line too long (113 > 99)
    |
512 |             # Now, features are pre-scaled, so just reshape.
513 |             if request.feature_vector.ndim != 1:
514 |                 error_dict = {"error": "Feature vector must be 1D for processing.", "model_id": request.model_id}
    |                                                                                                    ^^^^^^^^^^^^^^ E501
515 |                 result.update(error_dict)
516 |                 cls._raise_with_result(result, cls._ERROR_MSG_FEATURE_PREP)
    |

gal_friday/predictors/xgboost_predictor.py:92:9: D205 1 blank line required between summary line and description
    |
 91 |       def predict(self, features: np.ndarray) -> np.ndarray:
 92 | /         """Generate predictions using the XGBoost model.
 93 | |         Features are expected to be pre-scaled by the FeatureEngine.
 94 | |
 95 | |         Args:
 96 | |         ----
 97 | |             features: A 1D numpy array of pre-scaled, ordered feature values.
 98 | |
 99 | |         Returns:
100 | |         -------
101 | |             Prediction results as a numpy array (usually probabilities for binary:logistic)
102 | |
103 | |         Raises:
104 | |         ------
105 | |             ValueError: If features have wrong shape or contain invalid values.
106 | |             TypeError: If model is not properly loaded.
107 | |             xgb.core.XGBoostError: If prediction fails.
108 | |         """
    | |___________^ D205
109 |           if self.model is None:
110 |               msg = "XGBoost model is not loaded."
    |
    = help: Insert single blank line

gal_friday/predictors/xgboost_predictor.py:327:100: E501 Line too long (108 > 99)
    |
325 |             #         return result
326 |             if scaler_path:
327 |                 logger.info("scaler_path provided but will be ignored as features are expected pre-scaled.")
    |                                                                                                    ^^^^^^^^^ E501
    |

gal_friday/predictors/xgboost_predictor.py:340:100: E501 Line too long (111 > 99)
    |
339 |             # 4. Make prediction if no errors so far
340 |             if processed_features is not None and model is not None: # Error condition for ndim already handled
    |                                                                                                    ^^^^^^^^^^^^ E501
341 |                 prediction_result = cls._make_prediction(
342 |                     model=model,
    |

gal_friday/risk_manager.py:343:100: E501 Line too long (103 > 99)
    |
341 |     - Performing pre-trade checks like fat-finger validation and ensuring sufficient balance.
342 |     - Optionally, dynamically adjusting `risk_per_trade_pct` based on market volatility.
343 |       This dynamic adjustment can be driven by a configured volatility feature (e.g., "atr_14_default")
    |                                                                                                    ^^^^ E501
344 |       received from `FeatureEngine` via `FeatureEvent`s (payload: `dict[str, float]`).
345 |       A baseline "normal" volatility for selected pairs is calibrated on startup using
    |

gal_friday/risk_manager.py:485:100: E501 Line too long (107 > 99)
    |
484 |         # New: Config for dynamic risk adjustment via FeatureEngine features
485 |         self._dynamic_risk_volatility_feature_key = self._config.get("dynamic_risk_volatility_feature_key")
    |                                                                                                    ^^^^^^^^ E501
486 |         self._dynamic_risk_target_pairs = self._config.get("dynamic_risk_target_pairs", [])
    |

gal_friday/risk_manager.py:491:100: E501 Line too long (101 > 99)
    |
489 |             self.logger.warning(
490 |                 "Dynamic risk adjustment is enabled, but no 'dynamic_risk_volatility_feature_key' "
491 |                 "is configured. Dynamic adjustments based on FeatureEngine features will not occur.",
    |                                                                                                    ^^ E501
492 |             )
493 |         if self._enable_dynamic_risk_adjustment and not self._dynamic_risk_target_pairs:
    |

gal_friday/risk_manager.py:504:100: E501 Line too long (104 > 99)
    |
502 |                 self.logger.warning(
503 |                     "FeatureRegistryClient not available or not loaded. "
504 |                     "Cannot validate 'dynamic_risk_volatility_feature_key': '%s' against the registry.",
    |                                                                                                    ^^^^^ E501
505 |                     self._dynamic_risk_volatility_feature_key,
506 |                     source_module=self._source_module,
    |

gal_friday/risk_manager.py:509:100: E501 Line too long (123 > 99)
    |
507 |                 )
508 |             else:
509 |                 definition = self.feature_registry_client.get_feature_definition(self._dynamic_risk_volatility_feature_key)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
510 |                 if definition is None:
511 |                     self.logger.warning(
    |

gal_friday/risk_manager.py:512:100: E501 Line too long (124 > 99)
    |
510 |                 if definition is None:
511 |                     self.logger.warning(
512 |                         "The configured 'dynamic_risk_volatility_feature_key': '%s' was not found in the Feature Registry. "
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
513 |                         "Dynamic risk adjustment based on this feature may not work as expected.",
514 |                         self._dynamic_risk_volatility_feature_key,
    |

gal_friday/risk_manager.py:625:100: E501 Line too long (134 > 99)
    |
623 |             # Otherwise, dynamic adjustments are primarily event-driven by _handle_feature_event.
624 |             if not self._dynamic_risk_volatility_feature_key:
625 |                 self.logger.info("No dynamic_risk_volatility_feature_key configured. Starting fallback dynamic risk adjustment loop.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
626 |                 self._dynamic_risk_adjustment_task = asyncio.create_task(
627 |                     self._dynamic_risk_adjustment_loop_fallback(),
    |

gal_friday/risk_manager.py:630:100: E501 Line too long (168 > 99)
    |
628 | 
629 | 
630 | with feature key: {self._dynamic_risk_volatility_feature_key}. Adjustments will be event-driven.")
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
631 | 
632 | 
    |

gal_friday/risk_manager.py:636:100: E501 Line too long (100 > 99)
    |
635 |         # Start risk metrics calculation task
636 |         self._risk_metrics_task = asyncio.create_task(self._risk_metrics_loop()) # Explicitly re-set
    |                                                                                                    ^ E501
637 |
638 |         self._is_running = True
    |

gal_friday/risk_manager.py:659:100: E501 Line too long (102 > 99)
    |
657 |             self.pubsub.unsubscribe(EventType.FEATURES_CALCULATED, self._feature_event_handler)
658 |             self.logger.info(
659 |                 "Unsubscribed from TRADE_SIGNAL_PROPOSED, EXECUTION_REPORT, and FEATURES_CALCULATED.",
    |                                                                                                    ^^^ E501
660 |                 source_module=self._source_module,
661 |             )
    |

gal_friday/risk_manager.py:702:9: D205 1 blank line required between summary line and description
    |
701 |       async def _handle_feature_event(self, event_dict: dict[str, Any]) -> None:
702 | /         """Handles incoming `FeatureEvent`s (payload expected as `dict[str, float]`)
703 | |         to update latest volatility data for dynamic risk adjustment.
704 | |
705 | |         If dynamic risk adjustment is enabled, this method checks if the received
706 | |         feature event corresponds to one of the `_dynamic_risk_target_pairs` and
707 | |         if the event payload contains the `_dynamic_risk_volatility_feature_key`.
708 | |         If so, it extracts the float value of this feature, stores it in
709 | |         `_latest_volatility_features`, and then calls
710 | |         `_update_risk_parameters_based_on_volatility` for the specific trading pair.
711 | |         """
    | |___________^ D205
712 |           if not self._is_running or not self._enable_dynamic_risk_adjustment or \
713 |              not self._dynamic_risk_volatility_feature_key:
    |
    = help: Insert single blank line

gal_friday/risk_manager.py:727:100: E501 Line too long (109 > 99)
    |
726 |             if not trading_pair or not features_data or not isinstance(features_data, dict):
727 |                 self.logger.warning("FEATURES_CALCULATED event missing trading_pair or valid features dict.")
    |                                                                                                    ^^^^^^^^^^ E501
728 |                 return
    |

gal_friday/risk_manager.py:733:53: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
731 |                 volatility_value = features_data.get(self._dynamic_risk_volatility_feature_key)
732 |
733 |                 if volatility_value is not None and isinstance(volatility_value, (float, int)): # Check type
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
734 |                     if np.isnan(volatility_value):
735 |                         self.logger.debug(
    |
    = help: Convert to `X | Y`

gal_friday/risk_manager.py:733:100: E501 Line too long (108 > 99)
    |
731 |                 volatility_value = features_data.get(self._dynamic_risk_volatility_feature_key)
732 |
733 |                 if volatility_value is not None and isinstance(volatility_value, (float, int)): # Check type
    |                                                                                                    ^^^^^^^^^ E501
734 |                     if np.isnan(volatility_value):
735 |                         self.logger.debug(
    |

gal_friday/risk_manager.py:742:100: E501 Line too long (101 > 99)
    |
741 |                     self.logger.debug(
742 |                         f"Received volatility feature '{self._dynamic_risk_volatility_feature_key}' "
    |                                                                                                    ^^ E501
743 |                         f"value {volatility_value:.4f} for {trading_pair}.",
744 |                     )
    |

gal_friday/risk_manager.py:750:100: E501 Line too long (109 > 99)
    |
748 |                     self.logger.debug(
749 |                         f"Volatility feature '{self._dynamic_risk_volatility_feature_key}' "
750 |                         f"not found or invalid type ({type(volatility_value)}) in event for {trading_pair}.",
    |                                                                                                    ^^^^^^^^^^ E501
751 |                     )
    |

gal_friday/risk_manager.py:754:9: D205 1 blank line required between summary line and description
    |
753 |       async def _dynamic_risk_adjustment_loop_fallback(self) -> None:
754 | /         """Fallback loop for dynamic risk adjustment if FeatureEngine-based feature
755 | |         is not configured. This uses MarketPriceService.get_volatility directly.
756 | |         This method might be deprecated or removed if feature-based adjustment is primary.
757 | |         """
    | |___________^ D205
758 |           self.logger.info("Using fallback dynamic risk adjustment loop (MarketPriceService.get_volatility).")
759 |           while self._is_running:
    |
    = help: Insert single blank line

gal_friday/risk_manager.py:758:100: E501 Line too long (108 > 99)
    |
756 |         This method might be deprecated or removed if feature-based adjustment is primary.
757 |         """
758 |         self.logger.info("Using fallback dynamic risk adjustment loop (MarketPriceService.get_volatility).")
    |                                                                                                    ^^^^^^^^^ E501
759 |         while self._is_running:
760 |             try:
    |

gal_friday/risk_manager.py:774:100: E501 Line too long (136 > 99)
    |
772 |                      # so that _update_risk_parameters_based_on_volatility can use it.
773 |                      if np.isnan(volatility_raw):
774 |                          self.logger.debug(f"Fallback: MarketPriceService returned NaN volatility for {trading_pair}. Skipping.")
    |                                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
775 |                          continue
    |

gal_friday/risk_manager.py:778:100: E501 Line too long (153 > 99)
    |
777 | ading_pair] = float(volatility_raw)
778 | ed latest volatility for {trading_pair} to {volatility_raw:.4f} from MarketPriceService.")
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
779 | based_on_volatility(trading_pair)
780 | 
    |

gal_friday/risk_manager.py:781:100: E501 Line too long (123 > 99)
    |
779 |                             await self._update_risk_parameters_based_on_volatility(trading_pair)
780 |                         else:
781 |                             self.logger.debug(f"Fallback: MarketPriceService returned None volatility for {trading_pair}.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
782 |
783 |                     except AttributeError:
    |

gal_friday/risk_manager.py:784:100: E501 Line too long (123 > 99)
    |
783 |                     except AttributeError:
784 |                         self.logger.warning("MarketPriceService does not implement get_volatility method (fallback loop).")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
785 |                         return # Stop this loop if service doesn't support it
786 |                     except Exception:
    |

gal_friday/risk_manager.py:787:100: E501 Line too long (123 > 99)
    |
785 |                         return # Stop this loop if service doesn't support it
786 |                     except Exception:
787 |                         self.logger.exception(f"Error fetching/processing volatility in fallback loop for {trading_pair}.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
788 |             except asyncio.CancelledError:
789 |                 break
    |

gal_friday/risk_manager.py:865:13: S101 Use of `assert` detected
    |
864 |             # Type assertions for mypy - after the validation above, these cannot be None
865 |             assert ref_entry_for_calculation is not None
    |             ^^^^^^ S101
866 |             assert final_rounded_entry_price is not None
    |

gal_friday/risk_manager.py:866:13: S101 Use of `assert` detected
    |
864 |             # Type assertions for mypy - after the validation above, these cannot be None
865 |             assert ref_entry_for_calculation is not None
866 |             assert final_rounded_entry_price is not None
    |             ^^^^^^ S101
867 |
868 |             # --- Stage 3: Position Sizing & Portfolio Checks (Portfolio/Equity checks first) ---
    |

gal_friday/risk_manager.py:922:100: E501 Line too long (115 > 99)
    |
920 |                 portfolio_state=portfolio_state,
921 |             )
922 |             initial_rounded_calculated_qty, state_values = await self._stage3_position_sizing_and_portfolio_checks(
    |                                                                                                    ^^^^^^^^^^^^^^^^ E501
923 |                 stage3_ctx,
924 |             )
    |

gal_friday/risk_manager.py:1299:15: PLR0912 Too many branches (13 > 12)
     |
1297 |         return True
1298 |
1299 |     async def _update_risk_parameters_based_on_volatility(
     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
1300 |         self,
1301 |         trading_pair: str,
     |

gal_friday/risk_manager.py:1312:100: E501 Line too long (102 > 99)
     |
1310 |         standard deviation).
1311 |
1312 |         - If current volatility is significantly higher than normal, `_risk_per_trade_pct` is reduced.
     |                                                                                                    ^^^ E501
1313 |         - If current volatility is significantly lower than normal, `_risk_per_trade_pct` is
1314 |           increased (capped at the original statically configured maximum).
     |

gal_friday/risk_manager.py:1327:100: E501 Line too long (104 > 99)
     |
1325 |         if current_volatility_float is None:
1326 |             self.logger.debug(
1327 |                 "No live volatility feature value available for %s to perform dynamic risk adjustment.",
     |                                                                                                    ^^^^^ E501
1328 |                 trading_pair,
1329 |             )
     |

gal_friday/risk_manager.py:1336:100: E501 Line too long (104 > 99)
     |
1334 |         except InvalidOperation:
1335 |             self.logger.warning(
1336 |                 "Invalid volatility feature value '%s' for %s. Cannot perform dynamic risk adjustment.",
     |                                                                                                    ^^^^^ E501
1337 |                 current_volatility_float, trading_pair,
1338 |             )
     |

gal_friday/risk_manager.py:1359:100: E501 Line too long (150 > 99)
     |
1357 | 
1358 | olatility "
1359 | mal ~{normal_vol:.4f}). Volatility feature: {self._dynamic_risk_volatility_feature_key}"
     |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1360 | 
1361 | 
     |

gal_friday/risk_manager.py:1378:100: E501 Line too long (139 > 99)
     |
1376 |          f"for {trading_pair} due to low volatility "
1377 |          f"({current_volatility:.4f} vs normal ~{normal_vol:.4f}). "
1378 |          f"Capped at {static_configured_risk_pct:.3f}%. Volatility feature: {self._dynamic_risk_volatility_feature_key}"
     |                                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1379 |      ),
1380 |      source_module=self._source_module,
     |

gal_friday/risk_manager.py:1384:100: E501 Line too long (128 > 99)
     |
1382 |                     self._risk_per_trade_pct = new_risk_pct
1383 |
1384 |             elif self._risk_per_trade_pct != static_configured_risk_pct: # Volatility is normal, ensure risk is at static config
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1385 |                 self.logger.info(
1386 |                     (
     |

gal_friday/risk_manager.py:1390:100: E501 Line too long (146 > 99)
     |
1388 | l ~{normal_vol:.4f}). "
1389 | f._risk_per_trade_pct:.3f}% "
1390 | gured_risk_pct:.3f}%. Volatility feature: {self._dynamic_risk_volatility_feature_key}"
     |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1391 | 
1392 | 
     |

gal_friday/risk_manager.py:1430:100: E501 Line too long (104 > 99)
     |
1429 |     async def _calibrate_normal_volatility(self) -> None:
1430 |         """Calibrates and stores a baseline "normal" historical volatility for configured trading pairs.
     |                                                                                                    ^^^^^ E501
1431 |
1432 |         This method is typically called during startup if dynamic risk adjustment is enabled.
     |

gal_friday/risk_manager.py:1654:100: E501 Line too long (116 > 99)
     |
1652 |             if rounded_entry_price is not None:
1653 |                 if ctx.side == "BUY":
1654 |                     ctx.sl_price = rounded_entry_price * (Decimal("1") - self._min_sl_distance_pct / Decimal("100"))
     |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
1655 |                 else:  # SELL
1656 |                     ctx.sl_price = rounded_entry_price * (Decimal("1") + self._min_sl_distance_pct / Decimal("100"))
     |

gal_friday/risk_manager.py:1656:100: E501 Line too long (116 > 99)
     |
1654 |                     ctx.sl_price = rounded_entry_price * (Decimal("1") - self._min_sl_distance_pct / Decimal("100"))
1655 |                 else:  # SELL
1656 |                     ctx.sl_price = rounded_entry_price * (Decimal("1") + self._min_sl_distance_pct / Decimal("100"))
     |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
1657 |             else:
1658 |                 return False, "Cannot calculate SL without entry price", None, None, None
     |

gal_friday/risk_manager.py:1664:100: E501 Line too long (114 > 99)
     |
1662 |         # Validate SL distance
1663 |         if rounded_entry_price is not None and rounded_sl_price is not None:
1664 |             sl_distance_pct = abs((rounded_sl_price - rounded_entry_price) / rounded_entry_price) * Decimal("100")
     |                                                                                                    ^^^^^^^^^^^^^^^ E501
1665 |             if sl_distance_pct < self._min_sl_distance_pct:
1666 |                 return False, f"SL distance {sl_distance_pct:.2f}% below minimum {self._min_sl_distance_pct}%", None, None, None
     |

gal_friday/risk_manager.py:1666:100: E501 Line too long (128 > 99)
     |
1664 |             sl_distance_pct = abs((rounded_sl_price - rounded_entry_price) / rounded_entry_price) * Decimal("100")
1665 |             if sl_distance_pct < self._min_sl_distance_pct:
1666 |                 return False, f"SL distance {sl_distance_pct:.2f}% below minimum {self._min_sl_distance_pct}%", None, None, None
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1667 |
1668 |         # Calculate TP if not provided
     |

gal_friday/risk_manager.py:1708:100: E501 Line too long (115 > 99)
     |
1706 |         try:
1707 |             if tick_size and tick_size > 0:
1708 |                 result_price: Decimal = (price / tick_size).quantize(Decimal("1"), rounding=ROUND_DOWN) * tick_size
     |                                                                                                    ^^^^^^^^^^^^^^^^ E501
1709 |                 return result_price
1710 |             return price
     |

gal_friday/risk_manager.py:1715:100: E501 Line too long (112 > 99)
     |
1713 |                 f"Error rounding price to tick size for {trading_pair}",
1714 |                 source_module=self._source_module,
1715 |                 context={"trading_pair": trading_pair, "price": price, "tick_size": tick_size, "error": str(e)},
     |                                                                                                    ^^^^^^^^^^^^^ E501
1716 |             )
1717 |             return None
     |

gal_friday/risk_manager.py:1725:100: E501 Line too long (118 > 99)
     |
1723 |         """Validate prices for fat finger and stop loss distance."""
1724 |         # Fat finger check for limit orders
1725 |         if ctx.entry_type == "LIMIT" and ctx.current_market_price is not None and ctx.rounded_entry_price is not None:
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
1726 |             deviation_pct = abs((ctx.rounded_entry_price - ctx.current_market_price) / ctx.current_market_price) * Decimal("100")
1727 |             if deviation_pct > self._fat_finger_max_deviation_pct:
     |

gal_friday/risk_manager.py:1726:100: E501 Line too long (129 > 99)
     |
1724 |         # Fat finger check for limit orders
1725 |         if ctx.entry_type == "LIMIT" and ctx.current_market_price is not None and ctx.rounded_entry_price is not None:
1726 |             deviation_pct = abs((ctx.rounded_entry_price - ctx.current_market_price) / ctx.current_market_price) * Decimal("100")
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1727 |             if deviation_pct > self._fat_finger_max_deviation_pct:
1728 |                 return False, f"Entry price deviates {deviation_pct:.2f}% from market (max {self._fat_finger_max_deviation_pct}%)"
     |

gal_friday/risk_manager.py:1728:100: E501 Line too long (130 > 99)
     |
1726 |             deviation_pct = abs((ctx.rounded_entry_price - ctx.current_market_price) / ctx.current_market_price) * Decimal("100")
1727 |             if deviation_pct > self._fat_finger_max_deviation_pct:
1728 |                 return False, f"Entry price deviates {deviation_pct:.2f}% from market (max {self._fat_finger_max_deviation_pct}%)"
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1729 |
1730 |         # Validate SL distance
     |

gal_friday/risk_manager.py:1733:100: E501 Line too long (110 > 99)
     |
1731 |         effective_entry = ctx.rounded_entry_price or ctx.effective_entry_price_for_non_limit
1732 |         if effective_entry is not None:
1733 |             sl_distance_pct = abs((ctx.rounded_sl_price - effective_entry) / effective_entry) * Decimal("100")
     |                                                                                                    ^^^^^^^^^^^ E501
1734 |             if sl_distance_pct < self._min_sl_distance_pct:
1735 |                 return False, f"SL distance {sl_distance_pct:.2f}% below minimum {self._min_sl_distance_pct}%"
     |

gal_friday/risk_manager.py:1735:100: E501 Line too long (110 > 99)
     |
1733 |             sl_distance_pct = abs((ctx.rounded_sl_price - effective_entry) / effective_entry) * Decimal("100")
1734 |             if sl_distance_pct < self._min_sl_distance_pct:
1735 |                 return False, f"SL distance {sl_distance_pct:.2f}% below minimum {self._min_sl_distance_pct}%"
     |                                                                                                    ^^^^^^^^^^^ E501
1736 |
1737 |             # Validate SL is on correct side
     |

gal_friday/risk_manager.py:1796:100: E501 Line too long (110 > 99)
     |
1794 |                     return SizingResult(
1795 |                         is_valid=False,
1796 |                         rejection_reason=f"Position value exceeds max order size ${self._max_order_size_usd}",
     |                                                                                                    ^^^^^^^^^^^ E501
1797 |                     )
1798 |                 position_value = rounded_quantity * ref_entry_price
     |

gal_friday/risk_manager.py:1805:100: E501 Line too long (119 > 99)
     |
1803 |                 return SizingResult(
1804 |                     is_valid=False,
1805 |                     rejection_reason=f"Position size {position_pct:.2f}% exceeds max {self._max_single_position_pct}%",
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
1806 |                 )
     |

gal_friday/risk_manager.py:1826:9: PLR0911 Too many return statements (7 > 6)
     |
1824 |             )
1825 |
1826 |     def _check_position_scaling(
     |         ^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
1827 |         self,
1828 |         ctx: PositionScalingContext,
     |

gal_friday/risk_manager.py:1852:100: E501 Line too long (156 > 99)
     |
1850 | t_pct:
1851 | 
1852 | * self._max_exposure_per_asset_pct / Decimal("100")) - (existing_qty * ctx.ref_entry_price)
     |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1853 | 
1854 | ximum exposure", None, None
     |

gal_friday/risk_manager.py:1857:100: E501 Line too long (108 > 99)
     |
1856 |                         scaled_qty = max_additional_value / ctx.ref_entry_price
1857 |                         scaled_qty, _ = self._calculate_lot_size_with_fallback(scaled_qty, ctx.trading_pair)
     |                                                                                                    ^^^^^^^^^ E501
1858 |
1859 |                         if scaled_qty <= 0:
     |

gal_friday/risk_manager.py:1906:13: SIM105 Use `contextlib.suppress(InvalidOperation, ValueError)` instead of `try`-`except`-`pass`
     |
1904 |           # Handle special cases
1905 |           if "current_equity_usd" not in portfolio_state and "equity" in portfolio_state:
1906 | /             try:
1907 | |                 extracted["current_equity_usd"] = Decimal(str(portfolio_state["equity"]))
1908 | |             except (InvalidOperation, ValueError):
1909 | |                 pass
     | |____________________^ SIM105
1910 |
1911 |           # Calculate total exposure if not provided
     |
     = help: Replace with `contextlib.suppress(InvalidOperation, ValueError)`

gal_friday/risk_manager.py:1982:100: E501 Line too long (125 > 99)
     |
1980 |         """Stage 1: Initial validation and price rounding."""
1981 |         # TODO: Implement initial validation and price rounding
1982 |         return ctx.proposed_entry_price_decimal, ctx.proposed_sl_price_decimal or Decimal("0"), ctx.proposed_tp_price_decimal
     |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1983 |
1984 |     async def _get_current_market_price(self, trading_pair: str) -> Decimal | None:
     |

gal_friday/risk_manager.py:1994:100: E501 Line too long (104 > 99)
     |
1992 |         """Stage 2: Market price dependent checks (fat finger, SL distance)."""
1993 |         # TODO: Implement market price dependent checks
1994 |         return ctx.current_market_price_for_validation, ctx.rounded_entry_price, ctx.rounded_entry_price
     |                                                                                                    ^^^^^ E501
1995 |
1996 |     def _validate_and_raise_if_error(
     |

gal_friday/strategy_arbitrator.py:35:5: D205 1 blank line required between summary line and description
   |
33 |   # --- StrategyArbitrator Class ---
34 |   class StrategyArbitrator:
35 | /     """Consumes prediction events from models, applies trading strategy logic, and
36 | |     produces proposed trade signals.
37 | |
38 | |     The arbitrator supports configurable threshold-based strategies with secondary
39 | |     confirmation rules. These rules can leverage features published by the
40 | |     `FeatureEngine`. The `StrategyArbitrator` uses an injected `FeatureRegistryClient`
41 | |     to validate that feature names specified in confirmation rules exist in the
42 | |     Feature Registry during its configuration validation phase.
43 | |
44 | |     During live operation, it expects `PredictionEvent`s to carry the necessary
45 | |     `triggering_features` (as a `dict[str, float]`) within their
46 | |     `associated_features` payload, which are then used to evaluate the
47 | |     confirmation rules.
48 | |     """
   | |_______^ D205
49 |
50 |       def __init__(
   |
   = help: Insert single blank line

gal_friday/strategy_arbitrator.py:74:100: E501 Line too long (101 > 99)
   |
72 |             logger_service (LoggerService): The shared logger instance.
73 |             market_price_service (MarketPriceService): Service to get market prices.
74 |             feature_registry_client (FeatureRegistryClient): Instance of the feature registry client.
   |                                                                                                    ^^ E501
75 |         """
76 |         self._config = config.get("strategy_arbitrator", {})
   |

gal_friday/strategy_arbitrator.py:233:9: D205 1 blank line required between summary line and description
    |
232 |       def _validate_confirmation_rules_config(self) -> None:
233 | /         """Validate the structure of confirmation rules and check if feature names
234 | |         exist in the Feature Registry.
235 | |         """
    | |___________^ D205
236 |           if not self.feature_registry_client or not self.feature_registry_client.is_loaded():
237 |               self.logger.warning(
    |
    = help: Insert single blank line

gal_friday/strategy_arbitrator.py:251:100: E501 Line too long (133 > 99)
    |
249 |                         source_module=self._source_module,
250 |                     )
251 |                     raise StrategyConfigurationError(f"Invalid confirmation rule structure for strategy {self._strategy_id}: {rule}")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
252 |             return
    |

gal_friday/strategy_arbitrator.py:261:100: E501 Line too long (129 > 99)
    |
259 |                     source_module=self._source_module,
260 |                 )
261 |                 raise StrategyConfigurationError(f"Invalid confirmation rule structure for strategy {self._strategy_id}: {rule}")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
262 |
263 |             feature_name = rule.get("feature")
    |

gal_friday/strategy_arbitrator.py:276:100: E501 Line too long (111 > 99)
    |
274 |                 else:
275 |                     self.logger.debug(
276 |                         "Confirmation rule feature '%s' for strategy '%s' validated against Feature Registry.",
    |                                                                                                    ^^^^^^^^^^^^ E501
277 |                         feature_name, self._strategy_id,
278 |                         source_module=self._source_module,
    |

gal_friday/strategy_arbitrator.py:280:100: E501 Line too long (103 > 99)
    |
278 |                         source_module=self._source_module,
279 |                     )
280 |             # If feature_name is None or empty, the structural check above would have already caught it
    |                                                                                                    ^^^^ E501
281 |             # if 'feature' was a required key with a non-empty value.
282 |             # The current structural check `all(k in rule for k in ["feature", ...])` ensures 'feature' key exists.
    |

gal_friday/strategy_arbitrator.py:282:100: E501 Line too long (115 > 99)
    |
280 |             # If feature_name is None or empty, the structural check above would have already caught it
281 |             # if 'feature' was a required key with a non-empty value.
282 |             # The current structural check `all(k in rule for k in ["feature", ...])` ensures 'feature' key exists.
    |                                                                                                    ^^^^^^^^^^^^^^^^ E501
283 |             # An additional check for empty feature_name string might be useful if desired.
    |

gal_friday/strategy_arbitrator.py:610:100: E501 Line too long (108 > 99)
    |
608 |         # Optional: Validate feature_name against registry if desired for stricter checks
609 |         # if not self.feature_registry_client.get_feature_definition(feature_name):
610 |         #     self.logger.warning(f"Feature '{feature_name}' in rule not found in registry. Rule may fail.")
    |                                                                                                    ^^^^^^^^^ E501
611 |
612 |         feature_value_float = features.get(feature_name)
    |

gal_friday/strategy_arbitrator.py:695:100: E501 Line too long (119 > 99)
    |
693 |             raw_features = associated_payload.get("triggering_features")
694 |
695 |         if not raw_features or not isinstance(raw_features, dict): # Check if raw_features is None, empty or not a dict
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
696 |             self.logger.warning(
697 |                 "No valid 'triggering_features' (dict[str, float]) found in PredictionEvent %s for %s on %s.",
    |

gal_friday/strategy_arbitrator.py:697:100: E501 Line too long (110 > 99)
    |
695 |         if not raw_features or not isinstance(raw_features, dict): # Check if raw_features is None, empty or not a dict
696 |             self.logger.warning(
697 |                 "No valid 'triggering_features' (dict[str, float]) found in PredictionEvent %s for %s on %s.",
    |                                                                                                    ^^^^^^^^^^^ E501
698 |                 prediction_event.event_id,
699 |                 primary_side,
    |

scripts/train_initial_model.py:55:100: E501 Line too long (107 > 99)
   |
53 |     if "logging" in sys.modules:
54 |         logging.error(f"Error importing ConfigManager: {e}")
55 |         logging.error("Ensure the script is run from the project root or the PYTHONPATH is set correctly.")
   |                                                                                                    ^^^^^^^^ E501
56 |     else:
57 |         sys.stderr.write(f"Error importing ConfigManager: {e}\n")
   |

scripts/train_initial_model.py:58:100: E501 Line too long (112 > 99)
   |
56 |     else:
57 |         sys.stderr.write(f"Error importing ConfigManager: {e}\n")
58 |         sys.stderr.write("Ensure the script is run from the project root or the PYTHONPATH is set correctly.\n")
   |                                                                                                    ^^^^^^^^^^^^^ E501
59 |     sys.exit(1)
   |

scripts/train_initial_model.py:378:5: D417 Missing argument descriptions in the docstring for `train_model`: `x_test`, `x_train`
    |
378 | def train_model(
    |     ^^^^^^^^^^^ D417
379 |     x_train: pd.DataFrame,
380 |     y_train: pd.Series,
    |

tests/__init__.py:1:1: D104 Missing docstring in public package
tests/conftest.py:171:100: E501 Line too long (104 > 99)
    |
169 |             """Get decimal configuration value."""
170 |             value = self.get(key, default)
171 |             return Decimal(str(value)) if value is not None else (Decimal(default) if default else None)
    |                                                                                                    ^^^^^ E501
172 |
173 |         def get_list(self, key, default=None):
    |

tests/conftest.py:299:56: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
297 |             # Add some variation based on features
298 |             base = self.default_prediction
299 |             if "rsi" in features and features["rsi"] < 30:
    |                                                        ^^ PLR2004
300 |                 base += 0.1  # Oversold, likely to go up
301 |             elif "rsi" in features and features["rsi"] > 70:
    |

tests/conftest.py:301:58: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
299 |             if "rsi" in features and features["rsi"] < 30:
300 |                 base += 0.1  # Oversold, likely to go up
301 |             elif "rsi" in features and features["rsi"] > 70:
    |                                                          ^^ PLR2004
302 |                 base -= 0.1  # Overbought, likely to go down
    |

tests/dal/test_connection_pool.py:1:1: D100 Missing docstring in public module
tests/dal/test_connection_pool.py:13:5: D103 Missing docstring in public function
   |
12 | @pytest.fixture
13 | def mock_config():
   |     ^^^^^^^^^^^ D103
14 |     mock = MagicMock(spec=ConfigManager)
15 |     mock.get.side_effect = lambda key, default=None: {
   |

tests/dal/test_connection_pool.py:29:5: D103 Missing docstring in public function
   |
28 | @pytest.fixture
29 | def mock_logger():
   |     ^^^^^^^^^^^ D103
30 |     # Use a real logger instance but with a mock handler or spy on its methods
31 |     # For simplicity here, MagicMock is fine for checking calls.
   |

tests/dal/test_connection_pool.py:42:11: D103 Missing docstring in public function
   |
40 | @pytest.mark.asyncio
41 | @patch("gal_friday.dal.connection_pool.create_async_engine", autospec=True)
42 | async def test_initialize_success(mock_create_engine, mock_config, mock_logger):
   |           ^^^^^^^^^^^^^^^^^^^^^^^ D103
43 |     mock_engine_instance = AsyncMock()
44 |     mock_create_engine.return_value = mock_engine_instance
   |

tests/dal/test_connection_pool.py:55:9: S106 Possible hardcoded password assigned to argument: "password"
   |
53 |         drivername="postgresql+asyncpg",
54 |         username="test",
55 |         password="test",
   |         ^^^^^^^^^^^^^^^ S106
56 |         host="localhost",
57 |         database="testdb",
   |

tests/dal/test_connection_pool.py:64:40: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
63 |     assert str(call_args[0]) == str(expected_url)
64 |     assert call_kwargs["pool_size"] == 5
   |                                        ^ PLR2004
65 |     assert call_kwargs["max_overflow"] == 5 # 10 (max_size) - 5 (min_size)
66 |     assert call_kwargs["echo"] is False
   |

tests/dal/test_connection_pool.py:65:43: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
63 |     assert str(call_args[0]) == str(expected_url)
64 |     assert call_kwargs["pool_size"] == 5
65 |     assert call_kwargs["max_overflow"] == 5 # 10 (max_size) - 5 (min_size)
   |                                           ^ PLR2004
66 |     assert call_kwargs["echo"] is False
67 |     assert call_kwargs["pool_recycle"] == 300
   |

tests/dal/test_connection_pool.py:67:43: PLR2004 Magic value used in comparison, consider replacing `300` with a constant variable
   |
65 |     assert call_kwargs["max_overflow"] == 5 # 10 (max_size) - 5 (min_size)
66 |     assert call_kwargs["echo"] is False
67 |     assert call_kwargs["pool_recycle"] == 300
   |                                           ^^^ PLR2004
68 |     assert call_kwargs["pool_timeout"] == 10
   |

tests/dal/test_connection_pool.py:68:43: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
66 |     assert call_kwargs["echo"] is False
67 |     assert call_kwargs["pool_recycle"] == 300
68 |     assert call_kwargs["pool_timeout"] == 10
   |                                           ^^ PLR2004
   |

tests/dal/test_connection_pool.py:77:11: D103 Missing docstring in public function
   |
76 | @pytest.mark.asyncio
77 | async def test_initialize_failure_no_url(mock_config, mock_logger):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
78 |     # mock_config.get("database.connection_string") should return "" or None
79 |     # Make sure other keys still return their defaults if get() is called for them.
   |

tests/dal/test_connection_pool.py:102:11: D103 Missing docstring in public function
    |
100 | @pytest.mark.asyncio
101 | @patch("gal_friday.dal.connection_pool.create_async_engine", autospec=True)
102 | async def test_acquire_session(mock_create_engine, mock_config, mock_logger):
    |           ^^^^^^^^^^^^^^^^^^^^ D103
103 |     mock_engine_instance = AsyncMock()
104 |     mock_create_engine.return_value = mock_engine_instance
    |

tests/dal/test_connection_pool.py:117:100: E501 Line too long (145 > 99)
    |
115 | 
116 | nmaker)
117 | nstance # When mock_sm_instance_for_pool() is called, it returns mock_session_instance
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
118 | 
    |

tests/dal/test_connection_pool.py:126:100: E501 Line too long (107 > 99)
    |
125 |     mock_sm_instance_for_pool.assert_called_once() # Assert our mock session_maker was used
126 |     mock_session_instance.close.assert_called_once() # Assert session.close() was called by context manager
    |                                                                                                    ^^^^^^^^ E501
127 |     mock_session_instance.rollback.assert_not_called() # Assert rollback was not called for success path
    |

tests/dal/test_connection_pool.py:127:100: E501 Line too long (104 > 99)
    |
125 |     mock_sm_instance_for_pool.assert_called_once() # Assert our mock session_maker was used
126 |     mock_session_instance.close.assert_called_once() # Assert session.close() was called by context manager
127 |     mock_session_instance.rollback.assert_not_called() # Assert rollback was not called for success path
    |                                                                                                    ^^^^^ E501
128 |
129 |     pool._session_maker = original_session_maker # Restore original session_maker
    |

tests/dal/test_connection_pool.py:132:11: D103 Missing docstring in public function
    |
131 | @pytest.mark.asyncio
132 | async def test_acquire_before_initialize(mock_config, mock_logger):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
133 |     pool = DatabaseConnectionPool(config=mock_config, logger=mock_logger)
134 |     with pytest.raises(RuntimeError, match="Session maker is not initialized. Call initialize() first."):
    |

tests/dal/test_connection_pool.py:134:100: E501 Line too long (105 > 99)
    |
132 | async def test_acquire_before_initialize(mock_config, mock_logger):
133 |     pool = DatabaseConnectionPool(config=mock_config, logger=mock_logger)
134 |     with pytest.raises(RuntimeError, match="Session maker is not initialized. Call initialize() first."):
    |                                                                                                    ^^^^^^ E501
135 |         async with pool.acquire():
136 |             pass # This code should not be reached
    |

tests/dal/test_connection_pool.py:140:11: D103 Missing docstring in public function
    |
138 | @pytest.mark.asyncio
139 | @patch("gal_friday.dal.connection_pool.create_async_engine", autospec=True)
140 | async def test_close_pool(mock_create_engine, mock_config, mock_logger):
    |           ^^^^^^^^^^^^^^^ D103
141 |     mock_engine_instance = AsyncMock()
142 |     # We need to mock the dispose method on the instance that will be stored in _engine
    |

tests/dal/test_connection_pool.py:163:11: D103 Missing docstring in public function
    |
161 | @pytest.mark.asyncio
162 | @patch("gal_friday.dal.connection_pool.create_async_engine", autospec=True)
163 | async def test_acquire_session_handles_exception(mock_create_engine, mock_config, mock_logger):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
164 |     mock_engine_instance = AsyncMock()
165 |     mock_create_engine.return_value = mock_engine_instance
    |

tests/integration/test_backtesting_engine_feature_flow.py:1:1: D100 Missing docstring in public module
tests/integration/test_backtesting_engine_feature_flow.py:64:7: D101 Missing docstring in public class
   |
62 | """
63 |
64 | class MockPredictionService:
   |       ^^^^^^^^^^^^^^^^^^^^^ D101
65 |     def __init__(self, config: dict, pubsub_manager: PubSubManager, logger_service: LoggerService):
66 |         self.config = config
   |

tests/integration/test_backtesting_engine_feature_flow.py:65:9: D107 Missing docstring in `__init__`
   |
64 | class MockPredictionService:
65 |     def __init__(self, config: dict, pubsub_manager: PubSubManager, logger_service: LoggerService):
   |         ^^^^^^^^ D107
66 |         self.config = config
67 |         self.pubsub = pubsub_manager
   |

tests/integration/test_backtesting_engine_feature_flow.py:74:15: D102 Missing docstring in public method
   |
72 |         self.published_predictions_count = 0
73 |
74 |     async def start(self):
   |               ^^^^^ D102
75 |         self._is_running = True
76 |         await self.pubsub.subscribe(EventType.FEATURES_CALCULATED, self.handle_feature_event)
   |

tests/integration/test_backtesting_engine_feature_flow.py:79:15: D102 Missing docstring in public method
   |
77 |         self.logger.info(f"{self.source_module} started and subscribed to FEATURES_CALCULATED.")
78 |
79 |     async def stop(self):
   |               ^^^^ D102
80 |         self._is_running = False
81 |         # In a real scenario, ensure unsubscribe happens cleanly
   |

tests/integration/test_backtesting_engine_feature_flow.py:85:15: D102 Missing docstring in public method
   |
83 |         self.logger.info(f"{self.source_module} stopped.")
84 |
85 |     async def handle_feature_event(self, event_dict: dict): # PubSub delivers dicts
   |               ^^^^^^^^^^^^^^^^^^^^ D102
86 |         if not self._is_running:
87 |             return
   |

tests/integration/test_backtesting_engine_feature_flow.py:89:100: E501 Line too long (110 > 99)
   |
87 |             return
88 |
89 |         self.logger.debug(f"{self.source_module} received feature event dict: {event_dict.get('event_type')}")
   |                                                                                                    ^^^^^^^^^^^ E501
90 |
91 |         # Reconstruct the FeatureEvent if necessary, or just grab the payload
   |

tests/integration/test_backtesting_engine_feature_flow.py:94:100: E501 Line too long (116 > 99)
   |
92 |         # For this mock, we'll assume the payload is what we need
93 |         if event_dict.get("event_type") != EventType.FEATURES_CALCULATED.name:
94 |             self.logger.warning(f"MockPredictionService received non-feature event: {event_dict.get('event_type')}")
   |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
95 |             return
   |

tests/integration/test_backtesting_engine_feature_flow.py:108:100: E501 Line too long (107 > 99)
    |
107 |         if not features or not trading_pair or not timestamp_features_for_str:
108 |             self.logger.error("Essential data missing in feature event payload for prediction generation.")
    |                                                                                                    ^^^^^^^^ E501
109 |             return
    |

tests/integration/test_backtesting_engine_feature_flow.py:118:100: E501 Line too long (112 > 99)
    |
117 |         try:
118 |             timestamp_prediction_for = datetime.fromisoformat(timestamp_features_for_str.replace("Z", "+00:00"))
    |                                                                                                    ^^^^^^^^^^^^^ E501
119 |         except ValueError:
120 |             self.logger.error(f"Could not parse timestamp_features_for: {timestamp_features_for_str}")
    |

tests/integration/test_backtesting_engine_feature_flow.py:120:100: E501 Line too long (102 > 99)
    |
118 |             timestamp_prediction_for = datetime.fromisoformat(timestamp_features_for_str.replace("Z", "+00:00"))
119 |         except ValueError:
120 |             self.logger.error(f"Could not parse timestamp_features_for: {timestamp_features_for_str}")
    |                                                                                                    ^^^ E501
121 |             return
    |

tests/integration/test_backtesting_engine_feature_flow.py:134:100: E501 Line too long (100 > 99)
    |
132 |             prediction_value=dummy_prediction_value,
133 |             confidence=0.9,
134 |             associated_features={"triggering_features": features}, # Key part for StrategyArbitrator
    |                                                                                                    ^ E501
135 |         )
    |

tests/integration/test_backtesting_engine_feature_flow.py:139:100: E501 Line too long (124 > 99)
    |
137 |         await self.pubsub.publish(prediction_event)
138 |         self.published_predictions_count += 1
139 |         self.logger.info(f"{self.source_module} published PredictionEvent for {trading_pair} at {timestamp_prediction_for}")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
    |

tests/integration/test_backtesting_engine_feature_flow.py:142:7: D101 Missing docstring in public class
    |
142 | class TestBacktestingEngineFeatureFlow(unittest.IsolatedAsyncioTestCase):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D101
143 |
144 |     @classmethod
    |

tests/integration/test_backtesting_engine_feature_flow.py:145:9: D102 Missing docstring in public method
    |
144 |     @classmethod
145 |     def setUpClass(cls):
    |         ^^^^^^^^^^ D102
146 |         # Create dummy feature registry file
147 |         cls.feature_registry_path = TEST_TEMP_DIR / "feature_registry.yaml"
    |

tests/integration/test_backtesting_engine_feature_flow.py:148:14: PTH123 `open()` should be replaced by `Path.open()`
    |
146 |         # Create dummy feature registry file
147 |         cls.feature_registry_path = TEST_TEMP_DIR / "feature_registry.yaml"
148 |         with open(cls.feature_registry_path, "w") as f:
    |              ^^^^ PTH123
149 |             f.write(SAMPLE_FEATURE_REGISTRY_YAML)
    |

tests/integration/test_backtesting_engine_feature_flow.py:153:14: PTH123 `open()` should be replaced by `Path.open()`
    |
151 |         # Create dummy historical data file
152 |         cls.historical_data_path = TEST_TEMP_DIR / "historical_data.csv"
153 |         with open(cls.historical_data_path, "w") as f:
    |              ^^^^ PTH123
154 |             f.write(SAMPLE_HISTORICAL_DATA_CSV)
    |

tests/integration/test_backtesting_engine_feature_flow.py:157:9: D102 Missing docstring in public method
    |
156 |     @classmethod
157 |     def tearDownClass(cls):
    |         ^^^^^^^^^^^^^ D102
158 |         # Clean up dummy files
159 |         if cls.feature_registry_path.exists():
    |

tests/integration/test_backtesting_engine_feature_flow.py:160:13: PTH107 `os.remove()` should be replaced by `Path.unlink()`
    |
158 |         # Clean up dummy files
159 |         if cls.feature_registry_path.exists():
160 |             os.remove(cls.feature_registry_path)
    |             ^^^^^^^^^ PTH107
161 |         if cls.historical_data_path.exists():
162 |             os.remove(cls.historical_data_path)
    |

tests/integration/test_backtesting_engine_feature_flow.py:162:13: PTH107 `os.remove()` should be replaced by `Path.unlink()`
    |
160 |             os.remove(cls.feature_registry_path)
161 |         if cls.historical_data_path.exists():
162 |             os.remove(cls.historical_data_path)
    |             ^^^^^^^^^ PTH107
163 |         # Could remove TEST_TEMP_DIR if empty and desired
    |

tests/integration/test_backtesting_engine_feature_flow.py:165:15: PLR0915 Too many statements (55 > 50)
    |
163 |         # Could remove TEST_TEMP_DIR if empty and desired
164 |
165 |     async def test_features_flow_to_strategy_arbitrator(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0915
166 |         # 1. Setup Configuration
167 |         app_config = {
    |

tests/integration/test_backtesting_engine_feature_flow.py:165:15: D102 Missing docstring in public method
    |
163 |         # Could remove TEST_TEMP_DIR if empty and desired
164 |
165 |     async def test_features_flow_to_strategy_arbitrator(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
166 |         # 1. Setup Configuration
167 |         app_config = {
    |

tests/integration/test_backtesting_engine_feature_flow.py:172:100: E501 Line too long (109 > 99)
    |
170 |                 "version": 1,
171 |                 "disable_existing_loggers": False,
172 |                 "formatters": {"simple": {"format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s"}},
    |                                                                                                    ^^^^^^^^^^ E501
173 |                 "handlers": {"console": {"class": "logging.StreamHandler", "formatter": "simple", "level": "DEBUG"}},
174 |                 "root": {"handlers": ["console"], "level": "INFO"},
    |

tests/integration/test_backtesting_engine_feature_flow.py:173:100: E501 Line too long (117 > 99)
    |
171 |                 "disable_existing_loggers": False,
172 |                 "formatters": {"simple": {"format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s"}},
173 |                 "handlers": {"console": {"class": "logging.StreamHandler", "formatter": "simple", "level": "DEBUG"}},
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
174 |                 "root": {"handlers": ["console"], "level": "INFO"},
175 |                 "loggers": {"gal_friday": {"level": "DEBUG", "propagate": False, "handlers": ["console"]}},
    |

tests/integration/test_backtesting_engine_feature_flow.py:175:100: E501 Line too long (107 > 99)
    |
173 |                 "handlers": {"console": {"class": "logging.StreamHandler", "formatter": "simple", "level": "DEBUG"}},
174 |                 "root": {"handlers": ["console"], "level": "INFO"},
175 |                 "loggers": {"gal_friday": {"level": "DEBUG", "propagate": False, "handlers": ["console"]}},
    |                                                                                                    ^^^^^^^^ E501
176 |             },
177 |             "feature_engine": {
    |

tests/integration/test_backtesting_engine_feature_flow.py:200:100: E501 Line too long (124 > 99)
    |
198 |                     "confirmation_rules": [
199 |                         {"feature": "rsi_14_default", "condition": "lt", "threshold": 70},
200 |                         {"feature": "macd_default_MACD_12_26_9", "condition": "gt", "threshold": -10}, # Ensure it's a float
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
201 |                     ],
202 |                 }],
    |

tests/integration/test_backtesting_engine_feature_flow.py:230:14: PTH123 `open()` should be replaced by `Path.open()`
    |
228 |         temp_app_config_path = TEST_TEMP_DIR / "temp_app_config.yaml"
229 |         import yaml  # Ensure yaml is imported
230 |         with open(temp_app_config_path, "w") as f:
    |              ^^^^ PTH123
231 |             yaml.dump(app_config, f)
    |

tests/integration/test_backtesting_engine_feature_flow.py:235:100: E501 Line too long (105 > 99)
    |
233 |         config_manager = ConfigManager(config_path=str(temp_app_config_path))
234 |
235 |         # 2. Initialize services that BacktestingEngine doesn't create internally for _execute_simulation
    |                                                                                                    ^^^^^^ E501
236 |         # First PubSubManager, then LoggerService that might use it (or at least needs config_manager)
237 |         # LoggerService needs pubsub_manager for event handling, and config_manager for its own config.
    |

tests/integration/test_backtesting_engine_feature_flow.py:236:100: E501 Line too long (102 > 99)
    |
235 |         # 2. Initialize services that BacktestingEngine doesn't create internally for _execute_simulation
236 |         # First PubSubManager, then LoggerService that might use it (or at least needs config_manager)
    |                                                                                                    ^^^ E501
237 |         # LoggerService needs pubsub_manager for event handling, and config_manager for its own config.
238 |         # PubSubManager needs a logger_service. This is a bit of a startup order puzzle.
    |

tests/integration/test_backtesting_engine_feature_flow.py:237:100: E501 Line too long (103 > 99)
    |
235 |         # 2. Initialize services that BacktestingEngine doesn't create internally for _execute_simulation
236 |         # First PubSubManager, then LoggerService that might use it (or at least needs config_manager)
237 |         # LoggerService needs pubsub_manager for event handling, and config_manager for its own config.
    |                                                                                                    ^^^^ E501
238 |         # PubSubManager needs a logger_service. This is a bit of a startup order puzzle.
239 |         # Let's assume PubSubManager can be initialized with a placeholder/basic logger first,
    |

tests/integration/test_backtesting_engine_feature_flow.py:244:100: E501 Line too long (101 > 99)
    |
243 |         # Simplest for test: Create a basic logger for PubSubManager if strict typing demands it,
244 |         # then create the full logger_service, then ensure PubSubManager uses the full one if needed.
    |                                                                                                    ^^ E501
245 |         # However, PubSubManager's __init__ takes logger_service.
246 |         # So, LoggerService must be created first.
    |

tests/integration/test_backtesting_engine_feature_flow.py:256:100: E501 Line too long (108 > 99)
    |
255 |         # Let's look at BacktestingEngine._initialize_services:
256 |         # 1. self.logger_service = LoggerService(config=log_config, is_backtest=True) # This was the old way
    |                                                                                                    ^^^^^^^^^ E501
257 |         # 2. self.pubsub_manager = PubSubManager(logger_service=self.logger_service)
258 |         # This order worked because LoggerService didn't used to take pubsub_manager.
    |

tests/integration/test_backtesting_engine_feature_flow.py:260:100: E501 Line too long (111 > 99)
    |
258 |         # This order worked because LoggerService didn't used to take pubsub_manager.
259 |
260 |         # Current LoggerService signature: LoggerService(config_manager, pubsub_manager, db_session_maker=None)
    |                                                                                                    ^^^^^^^^^^^^ E501
261 |         # Current PubSubManager signature: PubSubManager(logger_service)
    |

tests/integration/test_backtesting_engine_feature_flow.py:270:100: E501 Line too long (100 > 99)
    |
268 |         pubsub_manager = PubSubManager(logger=test_pubsub_logger, config_manager=config_manager)
269 |         # 4. LoggerService (full service)
270 |         logger_service = LoggerService(config_manager=config_manager, pubsub_manager=pubsub_manager)
    |                                                                                                    ^ E501
271 |
272 |         # Now, services that depend on logger_service (like the one used by BacktestingEngine internally)
    |

tests/integration/test_backtesting_engine_feature_flow.py:272:100: E501 Line too long (105 > 99)
    |
270 |         logger_service = LoggerService(config_manager=config_manager, pubsub_manager=pubsub_manager)
271 |
272 |         # Now, services that depend on logger_service (like the one used by BacktestingEngine internally)
    |                                                                                                    ^^^^^^ E501
273 |         # or pubsub_manager can use these fully initialized instances.
    |

tests/integration/test_backtesting_engine_feature_flow.py:276:100: E501 Line too long (100 > 99)
    |
275 |         # Feature Registry Client for StrategyArbitrator
276 |         feature_registry_client = FeatureRegistryClient(config_path=str(self.feature_registry_path))
    |                                                                                                    ^ E501
277 |
278 |         # ExchangeInfoService and SimulatedMarketPriceService for StrategyArbitrator
    |

tests/integration/test_backtesting_engine_feature_flow.py:279:100: E501 Line too long (104 > 99)
    |
278 |         # ExchangeInfoService and SimulatedMarketPriceService for StrategyArbitrator
279 |         # exchange_info_svc_config = config_manager.get("exchange_info_service", {}) # Config can remain
    |                                                                                                    ^^^^^ E501
280 |         # exchange_info_service = ExchangeInfoService(config=exchange_info_svc_config) # Cannot instantiate ABC
    |

tests/integration/test_backtesting_engine_feature_flow.py:280:100: E501 Line too long (111 > 99)
    |
278 |         # ExchangeInfoService and SimulatedMarketPriceService for StrategyArbitrator
279 |         # exchange_info_svc_config = config_manager.get("exchange_info_service", {}) # Config can remain
280 |         # exchange_info_service = ExchangeInfoService(config=exchange_info_svc_config) # Cannot instantiate ABC
    |                                                                                                    ^^^^^^^^^^^^ E501
281 |
282 |         # SimulatedMarketPriceService needs historical data provider, BacktestingEngine creates one internally
    |

tests/integration/test_backtesting_engine_feature_flow.py:282:100: E501 Line too long (110 > 99)
    |
280 |         # exchange_info_service = ExchangeInfoService(config=exchange_info_svc_config) # Cannot instantiate ABC
281 |
282 |         # SimulatedMarketPriceService needs historical data provider, BacktestingEngine creates one internally
    |                                                                                                    ^^^^^^^^^^^ E501
283 |         # but StrategyArbitrator needs a MarketPriceService instance.
284 |         # We'll create a simple one for StrategyArbitrator.
    |

tests/integration/test_backtesting_engine_feature_flow.py:297:100: E501 Line too long (107 > 99)
    |
295 |         # instance that StrategyArbitrator uses.
296 |         mock_market_price_service = AsyncMock(spec=MarketPriceService)
297 |         mock_market_price_service.get_latest_price = AsyncMock(return_value=Decimal("105.0")) # Dummy price
    |                                                                                                    ^^^^^^^^ E501
298 |
299 |         # MockPredictionService
    |

tests/integration/test_backtesting_engine_feature_flow.py:321:100: E501 Line too long (105 > 99)
    |
320 |         backtest_services_for_simulation = {
321 |             "logger_service": logger_service, # For consistency, though BE might manage its own primarily
    |                                                                                                    ^^^^^^ E501
322 |             "pubsub_manager": pubsub_manager, # Crucial: must be the same instance
323 |             # "historical_data_provider": created by BE
    |

tests/integration/test_backtesting_engine_feature_flow.py:335:100: E501 Line too long (111 > 99)
    |
334 |         # 3. Patch StrategyArbitrator._validate_confirmation_rule
335 |         # We use `gal_friday.strategy_arbitrator.StrategyArbitrator` because that's where the class is defined.
    |                                                                                                    ^^^^^^^^^^^^ E501
336 |         with patch("gal_friday.strategy_arbitrator.StrategyArbitrator._validate_confirmation_rule",
337 |                    wraps=strategy_arbitrator._validate_confirmation_rule) as mock_validate_rule:
    |

tests/integration/test_backtesting_engine_feature_flow.py:366:13: PT009 Use a regular `assert` instead of unittest-style `assertIsNotNone`
    |
365 |             raw_data = backtesting_engine._load_raw_data(str(self.historical_data_path))
366 |             self.assertIsNotNone(raw_data, "Failed to load raw data for backtest.")
    |             ^^^^^^^^^^^^^^^^^^^^ PT009
367 |
368 |             backtest_run_config = backtesting_engine._get_backtest_config()
    |
    = help: Replace `assertIsNotNone(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:369:13: PT009 Use a regular `assert` instead of unittest-style `assertTrue`
    |
368 |             backtest_run_config = backtesting_engine._get_backtest_config()
369 |             self.assertTrue(backtesting_engine._validate_config(backtest_run_config), "Backtest config validation failed.")
    |             ^^^^^^^^^^^^^^^ PT009
370 |
371 |             cleaned_data = backtesting_engine._clean_and_validate_data(
    |
    = help: Replace `assertTrue(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:369:100: E501 Line too long (123 > 99)
    |
368 |             backtest_run_config = backtesting_engine._get_backtest_config()
369 |             self.assertTrue(backtesting_engine._validate_config(backtest_run_config), "Backtest config validation failed.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
370 |
371 |             cleaned_data = backtesting_engine._clean_and_validate_data(
    |

tests/integration/test_backtesting_engine_feature_flow.py:376:13: PT009 Use a regular `assert` instead of unittest-style `assertIsNotNone`
    |
374 |                 backtest_run_config["end_date"],
375 |             )
376 |             self.assertIsNotNone(cleaned_data, "Data cleaning failed.")
    |             ^^^^^^^^^^^^^^^^^^^^ PT009
377 |
378 |             processed_data = backtesting_engine._process_pairs_data(cleaned_data)
    |
    = help: Replace `assertIsNotNone(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:379:13: PT009 Use a regular `assert` instead of unittest-style `assertIsNotNone`
    |
378 |             processed_data = backtesting_engine._process_pairs_data(cleaned_data)
379 |             self.assertIsNotNone(processed_data, "Data processing failed.")
    |             ^^^^^^^^^^^^^^^^^^^^ PT009
380 |             backtesting_engine._data = processed_data # Set the data for the engine
    |
    = help: Replace `assertIsNotNone(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:389:13: PT009 Use a regular `assert` instead of unittest-style `assertTrue`
    |
388 |             # 5. Assertions
389 |             self.assertTrue(mock_validate_rule.called, "StrategyArbitrator._validate_confirmation_rule was not called.")
    |             ^^^^^^^^^^^^^^^ PT009
390 |
391 |             self.assertGreater(mock_prediction_service.received_features_count, 0, "MockPredictionService did not receive features.")
    |
    = help: Replace `assertTrue(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:389:100: E501 Line too long (120 > 99)
    |
388 |             # 5. Assertions
389 |             self.assertTrue(mock_validate_rule.called, "StrategyArbitrator._validate_confirmation_rule was not called.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^ E501
390 |
391 |             self.assertGreater(mock_prediction_service.received_features_count, 0, "MockPredictionService did not receive features.")
    |

tests/integration/test_backtesting_engine_feature_flow.py:391:13: PT009 Use a regular `assert` instead of unittest-style `assertGreater`
    |
389 |             self.assertTrue(mock_validate_rule.called, "StrategyArbitrator._validate_confirmation_rule was not called.")
390 |
391 |             self.assertGreater(mock_prediction_service.received_features_count, 0, "MockPredictionService did not receive features.")
    |             ^^^^^^^^^^^^^^^^^^ PT009
392 |             self.assertGreater(mock_prediction_service.published_predictions_count, 0, "MockPredictionService did not publish predict
    |
    = help: Replace `assertGreater(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:391:100: E501 Line too long (133 > 99)
    |
389 | , "StrategyArbitrator._validate_confirmation_rule was not called.")
390 | 
391 | e.received_features_count, 0, "MockPredictionService did not receive features.")
    |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
392 | e.published_predictions_count, 0, "MockPredictionService did not publish predictions.")
    |

tests/integration/test_backtesting_engine_feature_flow.py:392:13: PT009 Use a regular `assert` instead of unittest-style `assertGreater`
    |
391 |             self.assertGreater(mock_prediction_service.received_features_count, 0, "MockPredictionService did not receive features.")
392 |             self.assertGreater(mock_prediction_service.published_predictions_count, 0, "MockPredictionService did not publish predict
    |             ^^^^^^^^^^^^^^^^^^ PT009
393 |
394 |             # Inspect calls to _validate_confirmation_rule
    |
    = help: Replace `assertGreater(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:392:100: E501 Line too long (140 > 99)
    |
391 | eceived_features_count, 0, "MockPredictionService did not receive features.")
392 | ublished_predictions_count, 0, "MockPredictionService did not publish predictions.")
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
393 | 
394 | le
    |

tests/integration/test_backtesting_engine_feature_flow.py:395:100: E501 Line too long (115 > 99)
    |
394 |             # Inspect calls to _validate_confirmation_rule
395 |             # Each call to _validate_confirmation_rule has args: (self, rule, features, trading_pair, primary_side)
    |                                                                                                    ^^^^^^^^^^^^^^^^ E501
396 |             # We are interested in the `features` argument (positional index 2 in args, or keyword 'features')
397 |             found_rsi = False
    |

tests/integration/test_backtesting_engine_feature_flow.py:396:100: E501 Line too long (110 > 99)
    |
394 |             # Inspect calls to _validate_confirmation_rule
395 |             # Each call to _validate_confirmation_rule has args: (self, rule, features, trading_pair, primary_side)
396 |             # We are interested in the `features` argument (positional index 2 in args, or keyword 'features')
    |                                                                                                    ^^^^^^^^^^^ E501
397 |             found_rsi = False
398 |             found_macd = False
    |

tests/integration/test_backtesting_engine_feature_flow.py:407:100: E501 Line too long (126 > 99)
    |
405 |                 # Let's inspect by looking for the features dict passed to the *original* method.
406 |                 # The `call_args` for a wrapped method might be tricky.
407 |                 # An alternative: patch the *caller* of `_validate_confirmation_rule` which is `_apply_secondary_confirmation`
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
408 |                 # or make `_validate_confirmation_rule` store its received features.
    |

tests/integration/test_backtesting_engine_feature_flow.py:410:100: E501 Line too long (106 > 99)
    |
408 |                 # or make `_validate_confirmation_rule` store its received features.
409 |
410 |                 # Simpler: Check what the mock_prediction_service published, as that's what SA should get.
    |                                                                                                    ^^^^^^^ E501
411 |                 # This is already implicitly tested by mock_validate_rule being called,
412 |                 # if the rules use features that were indeed published.
    |

tests/integration/test_backtesting_engine_feature_flow.py:415:100: E501 Line too long (111 > 99)
    |
414 |                 # Let's verify the content of features passed to the rule validation.
415 |                 # The wrapped function's call args might be just `(rule, features, trading_pair, primary_side)`
    |                                                                                                    ^^^^^^^^^^^^ E501
416 |                 # if the `self` is bound.
    |

tests/integration/test_backtesting_engine_feature_flow.py:425:100: E501 Line too long (124 > 99)
    |
423 |                 # `self` is not part of `*args` in `call_args`.
424 |
425 |                 # Example: strategy_arbitrator_instance._validate_confirmation_rule(rule_dict, features_dict, "pair", "BUY")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
426 |                 # call_args.args = (rule_dict, features_dict, "pair", "BUY")
    |

tests/integration/test_backtesting_engine_feature_flow.py:433:17: PT009 Use a regular `assert` instead of unittest-style `assertIsInstance`
    |
432 |                 received_rule_features = call_args.args[1] # This should be the `features` dict
433 |                 self.assertIsInstance(received_rule_features, dict, "Features argument to _validate_confirmation_rule was not a dict.
    |                 ^^^^^^^^^^^^^^^^^^^^^ PT009
434 |
435 |                 if "rsi_14_default" in received_rule_features:
    |
    = help: Replace `assertIsInstance(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:433:100: E501 Line too long (135 > 99)
    |
432 | s[1] # This should be the `features` dict
433 | atures, dict, "Features argument to _validate_confirmation_rule was not a dict.")
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
434 | 
435 | eatures:
    |

tests/integration/test_backtesting_engine_feature_flow.py:437:21: PT009 Use a regular `assert` instead of unittest-style `assertIsInstance`
    |
435 |                 if "rsi_14_default" in received_rule_features:
436 |                     found_rsi = True
437 |                     self.assertIsInstance(received_rule_features["rsi_14_default"], float, "RSI feature is not a float.")
    |                     ^^^^^^^^^^^^^^^^^^^^^ PT009
438 |                 if "macd_default_MACD_12_26_9" in received_rule_features:
439 |                     found_macd = True
    |
    = help: Replace `assertIsInstance(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:437:100: E501 Line too long (121 > 99)
    |
435 |                 if "rsi_14_default" in received_rule_features:
436 |                     found_rsi = True
437 |                     self.assertIsInstance(received_rule_features["rsi_14_default"], float, "RSI feature is not a float.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
438 |                 if "macd_default_MACD_12_26_9" in received_rule_features:
439 |                     found_macd = True
    |

tests/integration/test_backtesting_engine_feature_flow.py:440:21: PT009 Use a regular `assert` instead of unittest-style `assertIsInstance`
    |
438 |                 if "macd_default_MACD_12_26_9" in received_rule_features:
439 |                     found_macd = True
440 |                     self.assertIsInstance(received_rule_features["macd_default_MACD_12_26_9"], float, "MACD feature is not a float.")
    |                     ^^^^^^^^^^^^^^^^^^^^^ PT009
441 |
442 |             self.assertTrue(found_rsi, "RSI feature was not found in features passed to _validate_confirmation_rule.")
    |
    = help: Replace `assertIsInstance(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:440:100: E501 Line too long (133 > 99)
    |
438 |                 if "macd_default_MACD_12_26_9" in received_rule_features:
439 |                     found_macd = True
440 |                     self.assertIsInstance(received_rule_features["macd_default_MACD_12_26_9"], float, "MACD feature is not a float.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
441 |
442 |             self.assertTrue(found_rsi, "RSI feature was not found in features passed to _validate_confirmation_rule.")
    |

tests/integration/test_backtesting_engine_feature_flow.py:442:13: PT009 Use a regular `assert` instead of unittest-style `assertTrue`
    |
440 |                     self.assertIsInstance(received_rule_features["macd_default_MACD_12_26_9"], float, "MACD feature is not a float.")
441 |
442 |             self.assertTrue(found_rsi, "RSI feature was not found in features passed to _validate_confirmation_rule.")
    |             ^^^^^^^^^^^^^^^ PT009
443 |             self.assertTrue(found_macd, "MACD feature was not found in features passed to _validate_confirmation_rule.")
    |
    = help: Replace `assertTrue(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:442:100: E501 Line too long (118 > 99)
    |
440 |                     self.assertIsInstance(received_rule_features["macd_default_MACD_12_26_9"], float, "MACD feature is not a float.")
441 |
442 |             self.assertTrue(found_rsi, "RSI feature was not found in features passed to _validate_confirmation_rule.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
443 |             self.assertTrue(found_macd, "MACD feature was not found in features passed to _validate_confirmation_rule.")
    |

tests/integration/test_backtesting_engine_feature_flow.py:443:13: PT009 Use a regular `assert` instead of unittest-style `assertTrue`
    |
442 |             self.assertTrue(found_rsi, "RSI feature was not found in features passed to _validate_confirmation_rule.")
443 |             self.assertTrue(found_macd, "MACD feature was not found in features passed to _validate_confirmation_rule.")
    |             ^^^^^^^^^^^^^^^ PT009
444 |
445 |             # Additional check: FeatureEngine's own capture within BacktestingEngine
    |
    = help: Replace `assertTrue(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:443:100: E501 Line too long (120 > 99)
    |
442 |             self.assertTrue(found_rsi, "RSI feature was not found in features passed to _validate_confirmation_rule.")
443 |             self.assertTrue(found_macd, "MACD feature was not found in features passed to _validate_confirmation_rule.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^ E501
444 |
445 |             # Additional check: FeatureEngine's own capture within BacktestingEngine
    |

tests/integration/test_backtesting_engine_feature_flow.py:448:13: PT009 Use a regular `assert` instead of unittest-style `assertIsNotNone`
    |
446 |             # This ensures FeatureEngine produced something sensible.
447 |             # backtesting_engine.current_features would hold the *last* set of features.
448 |             self.assertIsNotNone(backtesting_engine.current_features, "BacktestingEngine did not capture any features.")
    |             ^^^^^^^^^^^^^^^^^^^^ PT009
449 |             if backtesting_engine.current_features: # Check if not None
450 |                 self.assertIn("rsi_14_default", backtesting_engine.current_features)
    |
    = help: Replace `assertIsNotNone(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:448:100: E501 Line too long (120 > 99)
    |
446 |             # This ensures FeatureEngine produced something sensible.
447 |             # backtesting_engine.current_features would hold the *last* set of features.
448 |             self.assertIsNotNone(backtesting_engine.current_features, "BacktestingEngine did not capture any features.")
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^ E501
449 |             if backtesting_engine.current_features: # Check if not None
450 |                 self.assertIn("rsi_14_default", backtesting_engine.current_features)
    |

tests/integration/test_backtesting_engine_feature_flow.py:450:17: PT009 Use a regular `assert` instead of unittest-style `assertIn`
    |
448 |             self.assertIsNotNone(backtesting_engine.current_features, "BacktestingEngine did not capture any features.")
449 |             if backtesting_engine.current_features: # Check if not None
450 |                 self.assertIn("rsi_14_default", backtesting_engine.current_features)
    |                 ^^^^^^^^^^^^^ PT009
451 |                 self.assertIsInstance(backtesting_engine.current_features["rsi_14_default"], float)
452 |                 self.assertIn("macd_default_MACD_12_26_9", backtesting_engine.current_features)
    |
    = help: Replace `assertIn(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:451:17: PT009 Use a regular `assert` instead of unittest-style `assertIsInstance`
    |
449 |             if backtesting_engine.current_features: # Check if not None
450 |                 self.assertIn("rsi_14_default", backtesting_engine.current_features)
451 |                 self.assertIsInstance(backtesting_engine.current_features["rsi_14_default"], float)
    |                 ^^^^^^^^^^^^^^^^^^^^^ PT009
452 |                 self.assertIn("macd_default_MACD_12_26_9", backtesting_engine.current_features)
453 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACD_12_26_9"], float)
    |
    = help: Replace `assertIsInstance(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:452:17: PT009 Use a regular `assert` instead of unittest-style `assertIn`
    |
450 |                 self.assertIn("rsi_14_default", backtesting_engine.current_features)
451 |                 self.assertIsInstance(backtesting_engine.current_features["rsi_14_default"], float)
452 |                 self.assertIn("macd_default_MACD_12_26_9", backtesting_engine.current_features)
    |                 ^^^^^^^^^^^^^ PT009
453 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACD_12_26_9"], float)
454 |                 self.assertIn("macd_default_MACDh_12_26_9", backtesting_engine.current_features)
    |
    = help: Replace `assertIn(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:453:17: PT009 Use a regular `assert` instead of unittest-style `assertIsInstance`
    |
451 |                 self.assertIsInstance(backtesting_engine.current_features["rsi_14_default"], float)
452 |                 self.assertIn("macd_default_MACD_12_26_9", backtesting_engine.current_features)
453 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACD_12_26_9"], float)
    |                 ^^^^^^^^^^^^^^^^^^^^^ PT009
454 |                 self.assertIn("macd_default_MACDh_12_26_9", backtesting_engine.current_features)
455 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDh_12_26_9"], float)
    |
    = help: Replace `assertIsInstance(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:453:100: E501 Line too long (110 > 99)
    |
451 |                 self.assertIsInstance(backtesting_engine.current_features["rsi_14_default"], float)
452 |                 self.assertIn("macd_default_MACD_12_26_9", backtesting_engine.current_features)
453 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACD_12_26_9"], float)
    |                                                                                                    ^^^^^^^^^^^ E501
454 |                 self.assertIn("macd_default_MACDh_12_26_9", backtesting_engine.current_features)
455 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDh_12_26_9"], float)
    |

tests/integration/test_backtesting_engine_feature_flow.py:454:17: PT009 Use a regular `assert` instead of unittest-style `assertIn`
    |
452 |                 self.assertIn("macd_default_MACD_12_26_9", backtesting_engine.current_features)
453 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACD_12_26_9"], float)
454 |                 self.assertIn("macd_default_MACDh_12_26_9", backtesting_engine.current_features)
    |                 ^^^^^^^^^^^^^ PT009
455 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDh_12_26_9"], float)
456 |                 self.assertIn("macd_default_MACDs_12_26_9", backtesting_engine.current_features)
    |
    = help: Replace `assertIn(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:455:17: PT009 Use a regular `assert` instead of unittest-style `assertIsInstance`
    |
453 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACD_12_26_9"], float)
454 |                 self.assertIn("macd_default_MACDh_12_26_9", backtesting_engine.current_features)
455 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDh_12_26_9"], float)
    |                 ^^^^^^^^^^^^^^^^^^^^^ PT009
456 |                 self.assertIn("macd_default_MACDs_12_26_9", backtesting_engine.current_features)
457 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDs_12_26_9"], float)
    |
    = help: Replace `assertIsInstance(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:455:100: E501 Line too long (111 > 99)
    |
453 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACD_12_26_9"], float)
454 |                 self.assertIn("macd_default_MACDh_12_26_9", backtesting_engine.current_features)
455 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDh_12_26_9"], float)
    |                                                                                                    ^^^^^^^^^^^^ E501
456 |                 self.assertIn("macd_default_MACDs_12_26_9", backtesting_engine.current_features)
457 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDs_12_26_9"], float)
    |

tests/integration/test_backtesting_engine_feature_flow.py:456:17: PT009 Use a regular `assert` instead of unittest-style `assertIn`
    |
454 |                 self.assertIn("macd_default_MACDh_12_26_9", backtesting_engine.current_features)
455 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDh_12_26_9"], float)
456 |                 self.assertIn("macd_default_MACDs_12_26_9", backtesting_engine.current_features)
    |                 ^^^^^^^^^^^^^ PT009
457 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDs_12_26_9"], float)
    |
    = help: Replace `assertIn(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:457:17: PT009 Use a regular `assert` instead of unittest-style `assertIsInstance`
    |
455 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDh_12_26_9"], float)
456 |                 self.assertIn("macd_default_MACDs_12_26_9", backtesting_engine.current_features)
457 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDs_12_26_9"], float)
    |                 ^^^^^^^^^^^^^^^^^^^^^ PT009
458 |
459 |                 # Basic sanity check for RSI value (MinMax scaled 0-100)
    |
    = help: Replace `assertIsInstance(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:457:100: E501 Line too long (111 > 99)
    |
455 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDh_12_26_9"], float)
456 |                 self.assertIn("macd_default_MACDs_12_26_9", backtesting_engine.current_features)
457 |                 self.assertIsInstance(backtesting_engine.current_features["macd_default_MACDs_12_26_9"], float)
    |                                                                                                    ^^^^^^^^^^^^ E501
458 |
459 |                 # Basic sanity check for RSI value (MinMax scaled 0-100)
    |

tests/integration/test_backtesting_engine_feature_flow.py:461:17: PT009 Use a regular `assert` instead of unittest-style `assertTrue`
    |
459 |                 # Basic sanity check for RSI value (MinMax scaled 0-100)
460 |                 rsi_val = backtesting_engine.current_features["rsi_14_default"]
461 |                 self.assertTrue(0.0 <= rsi_val <= 100.0, f"RSI value {rsi_val} out of expected 0-100 range.")
    |                 ^^^^^^^^^^^^^^^ PT009
462 |
463 | if __name__ == "__main__":
    |
    = help: Replace `assertTrue(...)` with `assert ...`

tests/integration/test_backtesting_engine_feature_flow.py:461:51: PLR2004 Magic value used in comparison, consider replacing `100.0` with a constant variable
    |
459 |                 # Basic sanity check for RSI value (MinMax scaled 0-100)
460 |                 rsi_val = backtesting_engine.current_features["rsi_14_default"]
461 |                 self.assertTrue(0.0 <= rsi_val <= 100.0, f"RSI value {rsi_val} out of expected 0-100 range.")
    |                                                   ^^^^^ PLR2004
462 |
463 | if __name__ == "__main__":
    |

tests/integration/test_backtesting_engine_feature_flow.py:461:100: E501 Line too long (109 > 99)
    |
459 |                 # Basic sanity check for RSI value (MinMax scaled 0-100)
460 |                 rsi_val = backtesting_engine.current_features["rsi_14_default"]
461 |                 self.assertTrue(0.0 <= rsi_val <= 100.0, f"RSI value {rsi_val} out of expected 0-100 range.")
    |                                                                                                    ^^^^^^^^^^ E501
462 |
463 | if __name__ == "__main__":
    |

tests/integration/test_feature_engine_integration.py:17:7: D101 Missing docstring in public class
   |
15 | # --- Mocks and Helpers ---
16 |
17 | class MockPubSubManager:
   |       ^^^^^^^^^^^^^^^^^ D101
18 |     def __init__(self):
19 |         self.subscriptions = {}
   |

tests/integration/test_feature_engine_integration.py:18:9: D107 Missing docstring in `__init__`
   |
17 | class MockPubSubManager:
18 |     def __init__(self):
   |         ^^^^^^^^ D107
19 |         self.subscriptions = {}
20 |         self.published_events = []
   |

tests/integration/test_feature_engine_integration.py:22:9: D102 Missing docstring in public method
   |
20 |         self.published_events = []
21 |
22 |     def subscribe(self, event_type: EventType, handler):
   |         ^^^^^^^^^ D102
23 |         if event_type not in self.subscriptions:
24 |             self.subscriptions[event_type] = []
   |

tests/integration/test_feature_engine_integration.py:27:9: D102 Missing docstring in public method
   |
25 |         self.subscriptions[event_type].append(handler)
26 |
27 |     def unsubscribe(self, event_type: EventType, handler):
   |         ^^^^^^^^^^^ D102
28 |         if event_type in self.subscriptions:
29 |             self.subscriptions[event_type].remove(handler)
   |

tests/integration/test_feature_engine_integration.py:31:15: D102 Missing docstring in public method
   |
29 |             self.subscriptions[event_type].remove(handler)
30 |
31 |     async def publish(self, event: dict):
   |               ^^^^^^^ D102
32 |         self.published_events.append(event)
33 |         event_type_str = event.get("event_type")
   |

tests/integration/test_feature_engine_integration.py:49:9: D102 Missing docstring in public method
   |
47 |                 pass # Or log a warning
48 |
49 |     def get_last_published_event(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^ D102
50 |         return self.published_events[-1] if self.published_events else None
   |

tests/integration/test_feature_engine_integration.py:53:5: D103 Missing docstring in public function
   |
52 | @pytest.fixture
53 | def mock_logger():
   |     ^^^^^^^^^^^ D103
54 |     return MagicMock()
   |

tests/integration/test_feature_engine_integration.py:57:5: D103 Missing docstring in public function
   |
56 | @pytest.fixture
57 | def mock_pubsub():
   |     ^^^^^^^^^^^ D103
58 |     return MockPubSubManager()
   |

tests/integration/test_feature_engine_integration.py:77:100: E501 Line too long (104 > 99)
   |
75 |         },
76 |         "l2_spread_test": {
77 |             "calculator_type": "l2_spread", "input_type": "l2_book_series", "category": "L2_ORDER_BOOK",
   |                                                                                                    ^^^^^ E501
78 |             "imputation": {"strategy": "mean"}, # Fill NaNs with mean of spread values
79 |             "scaling": None, # Default (StandardScaler)
   |

tests/integration/test_feature_engine_integration.py:82:100: E501 Line too long (111 > 99)
   |
80 |         },
81 |         "vol_delta_60s": {
82 |             "calculator_type": "volume_delta", "input_type": "trades_and_bar_starts", "category": "TRADE_DATA",
   |                                                                                                    ^^^^^^^^^^^^ E501
83 |             "parameters": {"bar_interval_seconds": 60},
84 |             "imputation": "passthrough", # Test passthrough, expect 0.0 for no trades or actual delta
   |

tests/integration/test_feature_engine_integration.py:84:100: E501 Line too long (101 > 99)
   |
82 |             "calculator_type": "volume_delta", "input_type": "trades_and_bar_starts", "category": "TRADE_DATA",
83 |             "parameters": {"bar_interval_seconds": 60},
84 |             "imputation": "passthrough", # Test passthrough, expect 0.0 for no trades or actual delta
   |                                                                                                    ^^ E501
85 |         },
86 |     }
   |

tests/integration/test_feature_engine_integration.py:101:5: D103 Missing docstring in public function
    |
 99 |     await engine.stop() # Cleans up subscriptions
100 |
101 | def create_ohlcv_event(trading_pair: str, timestamp: datetime, o: float, h: float, l: float, c: float, v: float) -> dict:
    |     ^^^^^^^^^^^^^^^^^^ D103
102 |     return {
103 |         "event_type": EventType.MARKET_DATA_OHLCV.name, # Ensure name for string comparison
    |

tests/integration/test_feature_engine_integration.py:101:84: E741 Ambiguous variable name: `l`
    |
 99 |     await engine.stop() # Cleans up subscriptions
100 |
101 | def create_ohlcv_event(trading_pair: str, timestamp: datetime, o: float, h: float, l: float, c: float, v: float) -> dict:
    |                                                                                    ^ E741
102 |     return {
103 |         "event_type": EventType.MARKET_DATA_OHLCV.name, # Ensure name for string comparison
    |

tests/integration/test_feature_engine_integration.py:101:100: E501 Line too long (121 > 99)
    |
 99 |     await engine.stop() # Cleans up subscriptions
100 |
101 | def create_ohlcv_event(trading_pair: str, timestamp: datetime, o: float, h: float, l: float, c: float, v: float) -> dict:
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^ E501
102 |     return {
103 |         "event_type": EventType.MARKET_DATA_OHLCV.name, # Ensure name for string comparison
    |

tests/integration/test_feature_engine_integration.py:112:5: D103 Missing docstring in public function
    |
110 |     }
111 |
112 | def create_l2_event(trading_pair: str, timestamp: datetime, bids: list, asks: list) -> dict:
    |     ^^^^^^^^^^^^^^^ D103
113 |     return {
114 |         "event_type": EventType.MARKET_DATA_L2.name,
    |

tests/integration/test_feature_engine_integration.py:124:5: D103 Missing docstring in public function
    |
122 |     }
123 |
124 | def create_trade_event(trading_pair: str, timestamp: datetime, price: Decimal, volume: Decimal, side: str) -> dict:
    |     ^^^^^^^^^^^^^^^^^^ D103
125 |     return {
126 |         "event_type": EventType.MARKET_DATA_TRADE.name,
    |

tests/integration/test_feature_engine_integration.py:124:100: E501 Line too long (115 > 99)
    |
122 |     }
123 |
124 | def create_trade_event(trading_pair: str, timestamp: datetime, price: Decimal, volume: Decimal, side: str) -> dict:
    |                                                                                                    ^^^^^^^^^^^^^^^^ E501
125 |     return {
126 |         "event_type": EventType.MARKET_DATA_TRADE.name,
    |

tests/integration/test_feature_engine_integration.py:138:11: D103 Missing docstring in public function
    |
137 | @pytest.mark.asyncio
138 | async def test_end_to_end_feature_calculation_single_bar(initialized_feature_engine, mock_pubsub):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
139 |     engine = initialized_feature_engine
140 |     trading_pair = "BTC/USD"
    |

tests/integration/test_feature_engine_integration.py:155:100: E501 Line too long (111 > 99)
    |
153 |     l2_ts = base_time + timedelta(minutes=1, seconds=50) # Just before OHLCV bar close
154 |     l2_event = create_l2_event(trading_pair, l2_ts,
155 |                                bids=[[Decimal("130.00"), Decimal("1.0")], [Decimal("129.95"), Decimal("2.0")]],
    |                                                                                                    ^^^^^^^^^^^^ E501
156 |                                asks=[[Decimal("130.05"), Decimal("0.5")], [Decimal("130.10"), Decimal("1.5")]])
157 |     engine._handle_l2_update(trading_pair, l2_event["payload"])
    |

tests/integration/test_feature_engine_integration.py:156:100: E501 Line too long (111 > 99)
    |
154 |     l2_event = create_l2_event(trading_pair, l2_ts,
155 |                                bids=[[Decimal("130.00"), Decimal("1.0")], [Decimal("129.95"), Decimal("2.0")]],
156 |                                asks=[[Decimal("130.05"), Decimal("0.5")], [Decimal("130.10"), Decimal("1.5")]])
    |                                                                                                    ^^^^^^^^^^^^ E501
157 |     engine._handle_l2_update(trading_pair, l2_event["payload"])
    |

tests/integration/test_feature_engine_integration.py:177:100: E501 Line too long (103 > 99)
    |
175 |     mock_pubsub.published_events.clear()
176 |
177 |     await engine.process_market_data(ohlcv_event) # This should trigger _calculate_and_publish_features
    |                                                                                                    ^^^^ E501
178 |
179 |     # --- Assertions ---
    |

tests/integration/test_feature_engine_integration.py:190:5: T201 `print` found
    |
189 |     features = payload["features"]
190 |     print("Generated features:", features) # For debugging in test runner
    |     ^^^^^ T201
191 |
192 |     # Check presence of all configured features (names are based on pipeline_name.replace('_pipeline',''))
    |
    = help: Remove `print`

tests/integration/test_feature_engine_integration.py:192:100: E501 Line too long (106 > 99)
    |
190 |     print("Generated features:", features) # For debugging in test runner
191 |
192 |     # Check presence of all configured features (names are based on pipeline_name.replace('_pipeline',''))
    |                                                                                                    ^^^^^^^ E501
193 |     assert "rsi_14" in features # From rsi_14_custom_pipeline
194 |     assert "macd_default_MACD_12_26_9" in features # From macd_default_pipeline + column name
    |

tests/integration/test_feature_engine_integration.py:204:28: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
202 |     # RSI (scaled 0-100)
203 |     rsi_val = float(features["rsi_14"])
204 |     assert 0 <= rsi_val <= 100
    |                            ^^^ PLR2004
205 |
206 |     # MACD (passthrough scaling, so raw values from ta lib, then fillna(0))
    |

tests/integration/test_feature_engine_integration.py:223:11: D103 Missing docstring in public function
    |
222 | @pytest.mark.asyncio
223 | async def test_feature_calculation_with_passthrough_imputation(initialized_feature_engine, mock_pubsub):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
224 |     engine = initialized_feature_engine # Uses sample_feature_config
225 |     trading_pair = "ETH/USD"
    |

tests/integration/test_feature_engine_integration.py:223:100: E501 Line too long (104 > 99)
    |
222 | @pytest.mark.asyncio
223 | async def test_feature_calculation_with_passthrough_imputation(initialized_feature_engine, mock_pubsub):
    |                                                                                                    ^^^^^ E501
224 |     engine = initialized_feature_engine # Uses sample_feature_config
225 |     trading_pair = "ETH/USD"
    |

tests/integration/test_feature_engine_integration.py:276:100: E501 Line too long (113 > 99)
    |
274 |     features_no_l2 = published_event_no_l2["payload"]["features"]
275 |
276 |     # l2_spread_test has mean imputation. Since there's no data to compute a mean from (single event processing),
    |                                                                                                    ^^^^^^^^^^^^^^ E501
277 |     # its fillna(df.mean()) will result in NaNs for the means themselves, so the output is NaN.
278 |     # This would then be filtered out by `if pd.notna(val)` before formatting.
    |

tests/integration/test_feature_engine_integration.py:279:100: E501 Line too long (101 > 99)
    |
277 |     # its fillna(df.mean()) will result in NaNs for the means themselves, so the output is NaN.
278 |     # This would then be filtered out by `if pd.notna(val)` before formatting.
279 |     assert "l2_spread_test_abs_spread" not in features_no_l2 # Because it became NaN and was filtered
    |                                                                                                    ^^ E501
280 |     assert "l2_spread_test_pct_spread" not in features_no_l2
    |

tests/test_data_ingestion.py:61:35: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
60 |         assert event.trading_pair == "XRP/USD"
61 |         assert len(event.bids) == 3
   |                                   ^ PLR2004
62 |         assert len(event.asks) == 3
63 |         assert event.bids[0][0] == Decimal("0.5000")
   |

tests/test_data_ingestion.py:62:35: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
60 |         assert event.trading_pair == "XRP/USD"
61 |         assert len(event.bids) == 3
62 |         assert len(event.asks) == 3
   |                                   ^ PLR2004
63 |         assert event.bids[0][0] == Decimal("0.5000")
   |

tests/test_data_ingestion.py:68:9: F841 Local variable `processor` is assigned to but never used
   |
66 |     async def test_order_book_depth_calculation(self, sample_l2_data):
67 |         """Test order book depth calculations."""
68 |         processor = MarketDataProcessor()
   |         ^^^^^^^^^ F841
69 |
70 |         # Calculate bid/ask depth
   |
   = help: Remove assignment to unused variable `processor`

tests/test_data_ingestion.py:233:39: PLR2004 Magic value used in comparison, consider replacing `120` with a constant variable
    |
231 |         gaps = processor.detect_data_gaps(timestamps, expected_interval=60)
232 |         assert len(gaps) == 1
233 |         assert gaps[0]["duration"] == 120  # 2 minutes
    |                                       ^^^ PLR2004
234 |
235 |     @pytest.mark.asyncio
    |

tests/test_data_ingestion.py:238:9: F841 Local variable `validator` is assigned to but never used
    |
236 |     async def test_corrupt_data_detection(self):
237 |         """Test detection and handling of corrupt data."""
238 |         validator = DataValidator()
    |         ^^^^^^^^^ F841
239 |
240 |         corrupt_scenarios = [
    |
    = help: Remove assignment to unused variable `validator`

tests/test_data_ingestion.py:277:16: E712 Avoid equality comparisons to `False`; use `not processor.is_duplicate(event1):` for false checks
    |
275 |         )
276 |
277 |         assert processor.is_duplicate(event1) == False
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E712
278 |         processor.mark_processed(event1)
279 |         assert processor.is_duplicate(event2) == True
    |
    = help: Replace with `not processor.is_duplicate(event1)`

tests/test_data_ingestion.py:279:16: E712 Avoid equality comparisons to `True`; use `processor.is_duplicate(event2):` for truth checks
    |
277 |         assert processor.is_duplicate(event1) == False
278 |         processor.mark_processed(event1)
279 |         assert processor.is_duplicate(event2) == True
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E712
    |
    = help: Replace with `processor.is_duplicate(event2)`

tests/test_data_ingestion.py:312:34: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
310 |             p99_latency = sorted(latencies)[int(len(latencies) * 0.99)]
311 |
312 |             assert avg_latency < 10  # Average < 10ms
    |                                  ^^ PLR2004
313 |             assert p99_latency < 50  # 99th percentile < 50ms
314 |             assert max_latency < 100  # Max < 100ms
    |

tests/test_data_ingestion.py:313:34: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
312 |             assert avg_latency < 10  # Average < 10ms
313 |             assert p99_latency < 50  # 99th percentile < 50ms
    |                                  ^^ PLR2004
314 |             assert max_latency < 100  # Max < 100ms
    |

tests/test_data_ingestion.py:314:34: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
312 |             assert avg_latency < 10  # Average < 10ms
313 |             assert p99_latency < 50  # 99th percentile < 50ms
314 |             assert max_latency < 100  # Max < 100ms
    |                                  ^^^ PLR2004
315 |
316 |     @pytest.mark.asyncio
    |

tests/test_data_ingestion.py:347:29: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
346 |         assert processed_count >= target_events * 0.99  # 99% processed
347 |         assert throughput > 100  # > 100 events/second
    |                             ^^^ PLR2004
348 |
349 |     @pytest.mark.asyncio
    |

tests/test_data_ingestion.py:382:32: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
380 |         memory_leaked = final_memory - baseline_memory
381 |
382 |         assert memory_growth < 100  # Less than 100MB growth
    |                                ^^^ PLR2004
383 |         assert memory_leaked < 10   # Less than 10MB leaked
    |

tests/test_data_ingestion.py:383:32: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
382 |         assert memory_growth < 100  # Less than 100MB growth
383 |         assert memory_leaked < 10   # Less than 10MB leaked
    |                                ^^ PLR2004
    |

tests/test_data_ingestion.py:386:7: F811 Redefinition of unused `MarketDataProcessor` from line 21
    |
386 | class MarketDataProcessor:
    |       ^^^^^^^^^^^^^^^^^^^ F811
387 |     """Mock market data processor for testing."""
    |
    = help: Remove definition: `MarketDataProcessor`

tests/test_data_ingestion.py:389:9: D107 Missing docstring in `__init__`
    |
387 |     """Mock market data processor for testing."""
388 |
389 |     def __init__(self):
    |         ^^^^^^^^ D107
390 |         self.processed_sequences = set()
    |

tests/test_data_ingestion.py:434:7: F811 Redefinition of unused `DataValidator` from line 20
    |
434 | class DataValidator:
    |       ^^^^^^^^^^^^^ F811
435 |     """Mock data validator for testing."""
    |
    = help: Remove definition: `DataValidator`

tests/test_data_ingestion.py:454:9: SIM110 Use `return all(not (ask[0] <= 0 or ask[1] <= 0) for ask in data.get("asks", []))` instead of `for` loop
    |
452 |                   return False
453 |
454 | /         for ask in data.get("asks", []):
455 | |             if ask[0] <= 0 or ask[1] <= 0:
456 | |                 return False
457 | |
458 | |         return True
    | |___________________^ SIM110
459 |
460 |       def validate_ohlcv_data(self, data: dict) -> bool:
    |
    = help: Replace with `return all(not (ask[0] <= 0 or ask[1] <= 0) for ask in data.get("asks", []))`

tests/test_data_ingestion.py:476:9: SIM103 Return the negated condition directly
    |
474 |               return False
475 |
476 | /         if any(data[k] < 0 for k in ["open", "high", "low", "close"]):
477 | |             return False
478 | |
479 | |         return True
    | |___________________^ SIM103
    |
    = help: Inline condition

tests/test_data_ingestion.py:500:100: E501 Line too long (117 > 99)
    |
499 | # Monkey patch for testing
500 | MarketDataL2Event.create_test_event = classmethod(lambda cls, pair, **kwargs: create_test_event(cls, pair, **kwargs))
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
    |

tests/test_end_to_end_integration.py:35:9: D107 Missing docstring in `__init__`
   |
33 |     """Mock Kraken client for testing."""
34 |
35 |     def __init__(self):
   |         ^^^^^^^^ D107
36 |         self.positions = {
37 |             "XRP/USD": {"amount": Decimal("1000"), "avg_price": Decimal("0.5")},
   |

tests/test_execution_handler.py:29:9: D107 Missing docstring in `__init__`
   |
27 |     """Comprehensive mock of Kraken API for testing."""
28 |
29 |     def __init__(self):
   |         ^^^^^^^^ D107
30 |         self.orders = {}
31 |         self.order_counter = 1000
   |

tests/test_execution_handler.py:76:100: E501 Line too long (115 > 99)
   |
74 |                 "ordertype": params["ordertype"],
75 |                 "price": params.get("price", "0"),
76 |                 "order": f"{params['type']} {params['volume']} {params['pair']} @ {params.get('price', 'market')}",
   |                                                                                                    ^^^^^^^^^^^^^^^^ E501
77 |             },
78 |             "vol": params["volume"],
   |

tests/test_execution_handler.py:112:62: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
111 |         # Auto-fill market orders quickly
112 |         if order["descr"]["ordertype"] == "market" and age > 0.5:
    |                                                              ^^^ PLR2004
113 |             self._fill_order(txid)
    |

tests/test_execution_handler.py:117:22: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
115 |         # Partially fill limit orders over time
116 |         elif order["descr"]["ordertype"] == "limit" and order["status"] == "open":
117 |             if age > 2:
    |                      ^ PLR2004
118 |                 self._partially_fill_order(txid, Decimal("0.3"))
119 |             if age > 5:
    |

tests/test_execution_handler.py:119:22: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
117 |             if age > 2:
118 |                 self._partially_fill_order(txid, Decimal("0.3"))
119 |             if age > 5:
    |                      ^ PLR2004
120 |                 self._partially_fill_order(txid, Decimal("0.7"))
121 |             if age > 10:
    |

tests/test_execution_handler.py:121:22: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
119 |             if age > 5:
120 |                 self._partially_fill_order(txid, Decimal("0.7"))
121 |             if age > 10:
    |                      ^^ PLR2004
122 |                 self._fill_order(txid)
    |

tests/test_execution_handler.py:202:100: E501 Line too long (103 > 99)
    |
200 |             # Add some slippage for market orders
201 |             if order["descr"]["ordertype"] == "market":
202 |                 slippage = Decimal("0.0001") if order["descr"]["type"] == "buy" else Decimal("-0.0001")
    |                                                                                                    ^^^^ E501
203 |                 order["price"] = str(base_price + slippage)
204 |             else:
    |

tests/test_execution_handler.py:384:100: E501 Line too long (110 > 99)
    |
383 |         # Check for partial fill reports
384 |         partial_reports = [r for r in execution_reports if r.order_status == "OPEN" and r.quantity_filled > 0]
    |                                                                                                    ^^^^^^^^^^^ E501
385 |         assert len(partial_reports) > 0
386 |         assert partial_reports[0].quantity_filled < partial_reports[0].quantity_ordered
    |

tests/test_execution_handler.py:466:13: B007 Loop control variable `i` not used within loop body
    |
464 |         # Send multiple orders rapidly
465 |         signals = []
466 |         for i in range(5):
    |             ^ B007
467 |             signal = TradeSignalApprovedEvent.create_test_signal(
468 |                 pair="XRP/USD",
    |
    = help: Rename unused `i` to `_i`

tests/test_execution_handler.py:482:28: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
480 |         # Should take at least 4 seconds due to rate limiting (1 call/second)
481 |         duration = end_time - start_time
482 |         assert duration >= 3  # Allow some tolerance
    |                            ^ PLR2004
483 |
484 |     @pytest.mark.asyncio
    |

tests/test_halt_mechanism.py:20:100: E501 Line too long (101 > 99)
   |
18 |     """Test suite for HaltCoordinator functionality."""
19 |
20 |     def test_halt_coordinator_initialization(self, mock_config_manager, pubsub_manager, mock_logger):
   |                                                                                                    ^^ E501
21 |         """Test HALT coordinator initializes with correct conditions."""
22 |         coordinator = HaltCoordinator(mock_config_manager, pubsub_manager, mock_logger)
   |

tests/test_halt_mechanism.py:119:37: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
117 |         # Should be halted
118 |         assert monitoring.is_halted()
119 |         assert len(state_events) >= 2  # RUNNING + HALTED
    |                                     ^ PLR2004
120 |         assert state_events[-1].new_state == "HALTED"
121 |         assert "drawdown" in state_events[-1].reason.lower()
    |

tests/test_halt_mechanism.py:250:39: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
249 |         # Should have commands for both positions
250 |         assert len(close_commands) == 2
    |                                       ^ PLR2004
251 |
252 |         # Check XRP position closure
    |

tests/test_integration.py:44:16: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
   |
42 |         # Set up event capture
43 |         async def capture_market_data(event):
44 |             if isinstance(event, (MarketDataL2Event, MarketDataOHLCVEvent)):
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
45 |                 events_captured["market_data"].append(event)
   |
   = help: Convert to `X | Y`

tests/test_integration.py:66:100: E501 Line too long (101 > 99)
   |
64 |         integrated_system.pubsub.subscribe(EventType.MARKET_DATA_L2, capture_market_data)
65 |         integrated_system.pubsub.subscribe(EventType.PREDICTION, capture_predictions)
66 |         integrated_system.pubsub.subscribe(EventType.TRADE_SIGNAL_PROPOSED, capture_proposed_signals)
   |                                                                                                    ^^ E501
67 |         integrated_system.pubsub.subscribe(EventType.TRADE_SIGNAL_APPROVED, capture_approved_signals)
68 |         integrated_system.pubsub.subscribe(EventType.EXECUTION_REPORT, capture_execution_reports)
   |

tests/test_integration.py:67:100: E501 Line too long (101 > 99)
   |
65 |         integrated_system.pubsub.subscribe(EventType.PREDICTION, capture_predictions)
66 |         integrated_system.pubsub.subscribe(EventType.TRADE_SIGNAL_PROPOSED, capture_proposed_signals)
67 |         integrated_system.pubsub.subscribe(EventType.TRADE_SIGNAL_APPROVED, capture_approved_signals)
   |                                                                                                    ^^ E501
68 |         integrated_system.pubsub.subscribe(EventType.EXECUTION_REPORT, capture_execution_reports)
   |

tests/test_integration.py:252:38: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
251 |         # Verify state transitions
252 |         assert len(state_changes) >= 3
    |                                      ^ PLR2004
253 |         assert state_changes[0].new_state == "RUNNING"
254 |         assert state_changes[1].new_state == "HALTED"
    |

tests/test_integration.py:323:29: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
322 |         # System should handle at least 50 events/second
323 |         assert throughput > 50
    |                             ^^ PLR2004
324 |
325 |     @pytest.mark.asyncio
    |

tests/test_integration.py:352:13: SIM102 Use a single `if` statement instead of nested `if` statements
    |
351 |           async def track_execution(event):
352 | /             if isinstance(event, ExecutionReportEvent):
353 | |                 if hasattr(event, "metadata") and event.metadata.get("correlation_id") == str(correlation_id):
    | |______________________________________________________________________________________________________________^ SIM102
354 |                       latency = (datetime.now(UTC) - start_time).total_seconds() * 1000
355 |                       latencies.append(latency)
    |
    = help: Combine `if` statements using `and`

tests/test_integration.py:353:100: E501 Line too long (110 > 99)
    |
351 |         async def track_execution(event):
352 |             if isinstance(event, ExecutionReportEvent):
353 |                 if hasattr(event, "metadata") and event.metadata.get("correlation_id") == str(correlation_id):
    |                                                                                                    ^^^^^^^^^^^ E501
354 |                     latency = (datetime.now(UTC) - start_time).total_seconds() * 1000
355 |                     latencies.append(latency)
    |

tests/test_integration.py:372:34: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
370 |         if latencies:
371 |             avg_latency = sum(latencies) / len(latencies)
372 |             assert avg_latency < 1000  # Less than 1 second
    |                                  ^^^^ PLR2004
    |

tests/test_integration.py:384:16: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
383 |         async def track_signals(event):
384 |             if isinstance(event, (TradeSignalApprovedEvent, TradeSignalRejectedEvent)):
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
385 |                 signals_processed.append(event)
    |
    = help: Convert to `X | Y`

tests/test_integration.py:446:42: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
445 |         # Verify all signals were processed
446 |         assert len(signals_processed) == 10
    |                                          ^^ PLR2004
447 |         approved_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalApprovedEvent))
448 |         rejected_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalRejectedEvent))
    |

tests/test_integration.py:447:100: E501 Line too long (101 > 99)
    |
445 |         # Verify all signals were processed
446 |         assert len(signals_processed) == 10
447 |         approved_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalApprovedEvent))
    |                                                                                                    ^^ E501
448 |         rejected_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalRejectedEvent))
449 |         assert approved_count == 5
    |

tests/test_integration.py:448:100: E501 Line too long (101 > 99)
    |
446 |         assert len(signals_processed) == 10
447 |         approved_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalApprovedEvent))
448 |         rejected_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalRejectedEvent))
    |                                                                                                    ^^ E501
449 |         assert approved_count == 5
450 |         assert rejected_count == 5
    |

tests/test_integration.py:449:34: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
447 |         approved_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalApprovedEvent))
448 |         rejected_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalRejectedEvent))
449 |         assert approved_count == 5
    |                                  ^ PLR2004
450 |         assert rejected_count == 5
    |

tests/test_integration.py:450:34: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
448 |         rejected_count = sum(1 for s in signals_processed if isinstance(s, TradeSignalRejectedEvent))
449 |         assert approved_count == 5
450 |         assert rejected_count == 5
    |                                  ^ PLR2004
451 |
452 |     @pytest.mark.asyncio
    |

tests/test_integration.py:487:7: F811 Redefinition of unused `PredictionEvent` from line 19
    |
486 | # Extension for PredictionEvent creation
487 | class PredictionEvent:
    |       ^^^^^^^^^^^^^^^ F811
488 |     """Mock prediction event for testing."""
489 |     def __init__(self, **kwargs):
    |
    = help: Remove definition: `PredictionEvent`

tests/test_integration.py:489:9: D107 Missing docstring in `__init__`
    |
487 | class PredictionEvent:
488 |     """Mock prediction event for testing."""
489 |     def __init__(self, **kwargs):
    |         ^^^^^^^^ D107
490 |         self.__dict__.update(kwargs)
491 |         self.event_type = EventType.PREDICTION
    |

tests/test_integration.py:495:7: F811 Redefinition of unused `TradeSignalRejectedEvent` from line 23
    |
494 | # Extension for TradeSignalRejectedEvent
495 | class TradeSignalRejectedEvent:
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ F811
496 |     """Mock rejected signal event for testing."""
497 |     def __init__(self, **kwargs):
    |
    = help: Remove definition: `TradeSignalRejectedEvent`

tests/test_integration.py:497:9: D107 Missing docstring in `__init__`
    |
495 | class TradeSignalRejectedEvent:
496 |     """Mock rejected signal event for testing."""
497 |     def __init__(self, **kwargs):
    |         ^^^^^^^^ D107
498 |         self.__dict__.update(kwargs)
499 |         self.event_type = EventType.TRADE_SIGNAL_REJECTED
    |

tests/test_intelligence_layer_demo.py:47:100: E501 Line too long (106 > 99)
   |
46 |     for pred in predictions:
47 |         rich_print(f"   - {pred['model']}: {pred['value']:.2f}  {pred['action']} ({pred['confidence']})")
   |                                                                                                    ^^^^^^^ E501
   |

tests/test_model_registry.py:23:9: D107 Missing docstring in `__init__`
   |
21 | class MockConfig:
22 |     """Mock configuration for testing."""
23 |     def __init__(self):
   |         ^^^^^^^^ D107
24 |         self.config = {
25 |             "model_registry.storage_path": "./test_models",
   |

tests/test_model_registry.py:29:9: D102 Missing docstring in public method
   |
27 |         }
28 |
29 |     def get(self, key, default=None):
   |         ^^^ D102
30 |         return self.config.get(key, default)
   |

tests/test_model_registry.py:32:9: D102 Missing docstring in public method
   |
30 |         return self.config.get(key, default)
31 |
32 |     def get_bool(self, key, default=False):
   |         ^^^^^^^^ D102
33 |         return bool(self.config.get(key, default))
   |

tests/test_model_registry.py:38:9: D102 Missing docstring in public method
   |
36 | class MockLogger:
37 |     """Mock logger for testing."""
38 |     def info(self, msg, **kwargs):
   |         ^^^^ D102
39 |         rich_print(f"INFO: {msg}")
   |

tests/test_model_registry.py:41:9: D102 Missing docstring in public method
   |
39 |         rich_print(f"INFO: {msg}")
40 |
41 |     def warning(self, msg, **kwargs):
   |         ^^^^^^^ D102
42 |         rich_print(f"WARNING: {msg}")
   |

tests/test_model_registry.py:44:9: D102 Missing docstring in public method
   |
42 |         rich_print(f"WARNING: {msg}")
43 |
44 |     def error(self, msg, **kwargs):
   |         ^^^^^ D102
45 |         rich_print(f"ERROR: {msg}")
   |

tests/test_model_registry.py:47:9: D102 Missing docstring in public method
   |
45 |         rich_print(f"ERROR: {msg}")
46 |
47 |     def exception(self, msg, **kwargs):
   |         ^^^^^^^^^ D102
48 |         rich_print(f"EXCEPTION: {msg}")
   |

tests/test_model_registry.py:53:9: D107 Missing docstring in `__init__`
   |
51 | class MockModelRepo:
52 |     """Mock model repository for testing."""
53 |     def __init__(self):
   |         ^^^^^^^^ D107
54 |         self.models = {}
   |

tests/test_model_registry.py:56:15: D102 Missing docstring in public method
   |
54 |         self.models = {}
55 |
56 |     async def save_model(self, metadata):
   |               ^^^^^^^^^^ D102
57 |         self.models[metadata.model_id] = metadata
58 |         return metadata.model_id
   |

tests/test_model_registry.py:60:15: D102 Missing docstring in public method
   |
58 |         return metadata.model_id
59 |
60 |     async def get_model_by_id(self, model_id):
   |               ^^^^^^^^^^^^^^^ D102
61 |         return self.models.get(model_id)
   |

tests/test_model_registry.py:63:15: D102 Missing docstring in public method
   |
61 |         return self.models.get(model_id)
62 |
63 |     async def get_model_by_version(self, model_name, version):
   |               ^^^^^^^^^^^^^^^^^^^^ D102
64 |         for model in self.models.values():
65 |             if model.model_name == model_name and model.version == version:
   |

tests/test_model_registry.py:69:15: D102 Missing docstring in public method
   |
67 |         return None
68 |
69 |     async def get_model_by_stage(self, model_name, stage):
   |               ^^^^^^^^^^^^^^^^^^ D102
70 |         for model in self.models.values():
71 |             if model.model_name == model_name and model.stage == stage:
   |

tests/test_model_registry.py:75:15: D102 Missing docstring in public method
   |
73 |         return None
74 |
75 |     async def get_latest_model(self, model_name):
   |               ^^^^^^^^^^^^^^^^ D102
76 |         models = [m for m in self.models.values() if m.model_name == model_name]
77 |         if models:
   |

tests/test_model_registry.py:81:15: D102 Missing docstring in public method
   |
79 |         return None
80 |
81 |     async def list_models(self, model_name=None, stage=None):
   |               ^^^^^^^^^^^ D102
82 |         results = []
83 |         for model in self.models.values():
   |

tests/test_model_registry.py:91:15: D102 Missing docstring in public method
   |
89 |         return results
90 |
91 |     async def update_model_stage(self, model_id, new_stage, updated_by):
   |               ^^^^^^^^^^^^^^^^^^ D102
92 |         if model_id in self.models:
93 |             self.models[model_id].stage = new_stage
   |

tests/test_model_registry.py:120:5: N806 Variable `X_train` in function should be lowercase
    |
119 |     # Create a simple XGBoost model
120 |     X_train = np.random.rand(100, 5)
    |     ^^^^^^^ N806
121 |     y_train = np.random.rand(100)
    |

tests/test_model_registry.py:120:15: NPY002 Replace legacy `np.random.rand` call with `np.random.Generator`
    |
119 |     # Create a simple XGBoost model
120 |     X_train = np.random.rand(100, 5)
    |               ^^^^^^^^^^^^^^ NPY002
121 |     y_train = np.random.rand(100)
    |

tests/test_model_registry.py:121:15: NPY002 Replace legacy `np.random.rand` call with `np.random.Generator`
    |
119 |     # Create a simple XGBoost model
120 |     X_train = np.random.rand(100, 5)
121 |     y_train = np.random.rand(100)
    |               ^^^^^^^^^^^^^^ NPY002
122 |
123 |     model = xgb.XGBRegressor(n_estimators=10, max_depth=3)
    |

tests/test_model_registry.py:175:27: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
173 |     rich_print("\nTest 4: Listing models...")
174 |     models = await registry.list_models("price_predictor")
175 |     assert len(models) == 2
    |                           ^ PLR2004
176 |     rich_print(f" Found {len(models)} models")
    |

tests/test_model_registry_simple.py:14:7: D101 Missing docstring in public class
   |
13 | # Simplified versions of the classes for demonstration
14 | class ModelStage:
   |       ^^^^^^^^^^ D101
15 |     DEVELOPMENT = "development"
16 |     STAGING = "staging"
   |

tests/test_model_registry_simple.py:20:7: D101 Missing docstring in public class
   |
18 |     ARCHIVED = "archived"
19 |
20 | class ModelStatus:
   |       ^^^^^^^^^^^ D101
21 |     TRAINING = "training"
22 |     READY = "ready"
   |

tests/test_model_registry_simple.py:25:7: D101 Missing docstring in public class
   |
23 |     DEPLOYED = "deployed"
24 |
25 | class ModelMetadata:
   |       ^^^^^^^^^^^^^ D101
26 |     def __init__(self):
27 |         self.model_id = str(uuid.uuid4())
   |

tests/test_model_registry_simple.py:26:9: D107 Missing docstring in `__init__`
   |
25 | class ModelMetadata:
26 |     def __init__(self):
   |         ^^^^^^^^ D107
27 |         self.model_id = str(uuid.uuid4())
28 |         self.model_name = ""
   |

tests/test_model_registry_simple.py:40:9: D102 Missing docstring in public method
   |
38 |         self.features = []
39 |
40 |     def to_dict(self):
   |         ^^^^^^^ D102
41 |         return {
42 |             "model_id": self.model_id,
   |

tests/test_model_registry_simple.py:58:9: D107 Missing docstring in `__init__`
   |
56 | class SimpleModel:
57 |     """A simple mock model for testing."""
58 |     def __init__(self, name):
   |         ^^^^^^^^ D107
59 |         self.name = name
60 |         self.params = {"learning_rate": 0.1, "n_estimators": 100}
   |

tests/test_model_registry_simple.py:62:9: D102 Missing docstring in public method
   |
60 |         self.params = {"learning_rate": 0.1, "n_estimators": 100}
61 |
62 |     def predict(self, X):
   |         ^^^^^^^ D102
63 |         return [0.5] * len(X)
   |

tests/test_model_registry_simple.py:62:23: N803 Argument name `X` should be lowercase
   |
60 |         self.params = {"learning_rate": 0.1, "n_estimators": 100}
61 |
62 |     def predict(self, X):
   |                       ^ N803
63 |         return [0.5] * len(X)
   |

tests/test_model_registry_simple.py:65:5: PLR0915 Too many statements (64 > 50)
   |
63 |         return [0.5] * len(X)
64 |
65 | def demonstrate_model_registry():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0915
66 |     """Demonstrate the Model Registry structure and workflow."""
67 |     rich_print("=== Gal-Friday Model Registry Demonstration ===\n")
   |

tests/test_model_registry_simple.py:100:10: PTH123 `open()` should be replaced by `Path.open()`
    |
 99 |     # Save model
100 |     with open(artifact_path / "model.pkl", "wb") as f:
    |          ^^^^ PTH123
101 |         pickle.dump(model, f)
    |

tests/test_model_registry_simple.py:104:10: PTH123 `open()` should be replaced by `Path.open()`
    |
103 |     # Save metadata
104 |     with open(artifact_path / "metadata.json", "w") as f:
    |          ^^^^ PTH123
105 |         json.dump(metadata.to_dict(), f, indent=2)
    |

tests/test_model_registry_simple.py:108:10: PTH123 `open()` should be replaced by `Path.open()`
    |
107 |     # Save features
108 |     with open(artifact_path / "features.json", "w") as f:
    |          ^^^^ PTH123
109 |         json.dump(metadata.features, f)
    |

tests/test_model_registry_simple.py:145:10: PTH123 `open()` should be replaced by `Path.open()`
    |
144 |     # Load model
145 |     with open(artifact_path / "model.pkl", "rb") as f:
    |          ^^^^ PTH123
146 |         loaded_model = pickle.load(f)
    |

tests/test_model_registry_simple.py:146:24: S301 `pickle` and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue
    |
144 |     # Load model
145 |     with open(artifact_path / "model.pkl", "rb") as f:
146 |         loaded_model = pickle.load(f)
    |                        ^^^^^^^^^^^^^^ S301
147 |
148 |     # Load metadata
    |

tests/test_model_registry_simple.py:149:10: PTH123 `open()` should be replaced by `Path.open()`
    |
148 |     # Load metadata
149 |     with open(artifact_path / "metadata.json") as f:
    |          ^^^^ PTH123
150 |         loaded_metadata = json.load(f)
    |

tests/test_performance.py:27:9: D107 Missing docstring in `__init__`
   |
25 |     """Run performance benchmarks on Gal-Friday components."""
26 |
27 |     def __init__(self):
   |         ^^^^^^^^ D107
28 |         self.results = {}
29 |         self.pubsub = PubSubManager()
   |

tests/test_performance.py:43:35: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   |
41 |                 timestamp=datetime.now(UTC),
42 |                 trading_pair="XRP/USD",
43 |                 price=Decimal(str(random.uniform(0.4, 0.6))),
   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ S311
44 |                 volume=Decimal(str(random.uniform(100000, 1000000))),
45 |             )
   |

tests/test_performance.py:44:36: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   |
42 |                 trading_pair="XRP/USD",
43 |                 price=Decimal(str(random.uniform(0.4, 0.6))),
44 |                 volume=Decimal(str(random.uniform(100000, 1000000))),
   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
45 |             )
   |

tests/test_performance.py:70:33: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   |
68 |         for _ in range(num_predictions):
69 |             features = {
70 |                 f"feature_{i}": random.random()
   |                                 ^^^^^^^^^^^^^^^ S311
71 |                 for i in range(50)  # 50 features
72 |             }
   |

tests/test_performance.py:86:28: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   |
84 |                 trading_pair="XRP/USD",
85 |                 prediction_value=prediction_value,
86 |                 confidence=random.uniform(0.7, 0.95),
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^ S311
87 |                 associated_features=features,
88 |             )
   |

tests/test_performance.py:111:100: E501 Line too long (110 > 99)
    |
109 |     async def test_concurrent_load(self, num_workers: int = 10, duration_seconds: int = 30):
110 |         """Test system under concurrent load."""
111 |         rich_print(f"\n=== Testing Concurrent Load (workers={num_workers}, duration={duration_seconds}s) ===")
    |                                                                                                    ^^^^^^^^^^^ E501
112 |
113 |         async def worker(worker_id: int):
    |

tests/test_performance.py:121:33: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
119 |                 try:
120 |                     # Simulate various operations
121 |                     operation = random.choice(["market_data", "prediction", "signal"])
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
122 |
123 |                     if operation == "market_data":
    |

tests/test_performance.py:127:42: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
125 |                      event_type=EventType.PRICE_UPDATE,
126 |                      timestamp=datetime.now(UTC),
127 |                      trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
128 |                      price=Decimal(str(random.uniform(0.1, 1.0))),
129 |                      volume=Decimal(str(random.uniform(10000, 100000))),
    |

tests/test_performance.py:128:47: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
126 |                             timestamp=datetime.now(UTC),
127 |                             trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
128 |                             price=Decimal(str(random.uniform(0.1, 1.0))),
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^ S311
129 |                             volume=Decimal(str(random.uniform(10000, 100000))),
130 |                         )
    |

tests/test_performance.py:129:48: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
127 |                             trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
128 |                             price=Decimal(str(random.uniform(0.1, 1.0))),
129 |                             volume=Decimal(str(random.uniform(10000, 100000))),
    |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
130 |                         )
131 |                         await self.pubsub.publish(EventType.PRICE_UPDATE, event)
    |

tests/test_performance.py:138:42: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
136 |                      timestamp=datetime.now(UTC),
137 |                      model_id=f"model_{worker_id}",
138 |                      trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
139 |                      prediction_value=random.random(),
140 |                      confidence=random.uniform(0.5, 1.0),
    |

tests/test_performance.py:139:46: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
137 |                             model_id=f"model_{worker_id}",
138 |                             trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
139 |                             prediction_value=random.random(),
    |                                              ^^^^^^^^^^^^^^^ S311
140 |                             confidence=random.uniform(0.5, 1.0),
141 |                         )
    |

tests/test_performance.py:140:40: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
138 |                             trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
139 |                             prediction_value=random.random(),
140 |                             confidence=random.uniform(0.5, 1.0),
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^ S311
141 |                         )
142 |                         await self.pubsub.publish(EventType.PREDICTION_GENERATED, event)
    |

tests/test_performance.py:149:42: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
147 |                      timestamp=datetime.now(UTC),
148 |                      signal_id=f"signal_{worker_id}_{events_processed}",
149 |                      trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
150 |                      signal=random.choice(["BUY", "SELL", "HOLD"]),
151 |                      entry_price=Decimal(str(random.uniform(0.1, 1.0))),
    |

tests/test_performance.py:150:36: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
148 |                      signal_id=f"signal_{worker_id}_{events_processed}",
149 |                      trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
150 |                      signal=random.choice(["BUY", "SELL", "HOLD"]),
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
151 |                      entry_price=Decimal(str(random.uniform(0.1, 1.0))),
152 |                      quantity=Decimal(str(random.uniform(100, 1000))),
    |

tests/test_performance.py:151:53: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
149 |                             trading_pair=random.choice(["XRP/USD", "DOGE/USD"]),
150 |                             signal=random.choice(["BUY", "SELL", "HOLD"]),
151 |                             entry_price=Decimal(str(random.uniform(0.1, 1.0))),
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^ S311
152 |                             quantity=Decimal(str(random.uniform(100, 1000))),
153 |                         )
    |

tests/test_performance.py:152:50: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
150 |                             signal=random.choice(["BUY", "SELL", "HOLD"]),
151 |                             entry_price=Decimal(str(random.uniform(0.1, 1.0))),
152 |                             quantity=Decimal(str(random.uniform(100, 1000))),
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^ S311
153 |                         )
154 |                         await self.pubsub.publish(EventType.TRADE_SIGNAL_PROPOSED, event)
    |

tests/test_performance.py:201:17: F841 Local variable `data` is assigned to but never used
    |
199 |             while time.time() - start_time < duration_seconds:
200 |                 # Create various objects to stress memory
201 |                 data = {
    |                 ^^^^ F841
202 |                     "features": np.random.rand(1000, 50),  # 1000 samples, 50 features
203 |                     "predictions": [random.random() for _ in range(1000)],
    |
    = help: Remove assignment to unused variable `data`

tests/test_performance.py:202:33: NPY002 Replace legacy `np.random.rand` call with `np.random.Generator`
    |
200 |                 # Create various objects to stress memory
201 |                 data = {
202 |                     "features": np.random.rand(1000, 50),  # 1000 samples, 50 features
    |                                 ^^^^^^^^^^^^^^ NPY002
203 |                     "predictions": [random.random() for _ in range(1000)],
204 |                     "events": [
    |

tests/test_performance.py:203:37: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
201 |                 data = {
202 |                     "features": np.random.rand(1000, 50),  # 1000 samples, 50 features
203 |                     "predictions": [random.random() for _ in range(1000)],
    |                                     ^^^^^^^^^^^^^^^ S311
204 |                     "events": [
205 |                         MarketDataEvent(
    |

tests/test_performance.py:209:47: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
207 |                             timestamp=datetime.now(UTC),
208 |                             trading_pair="XRP/USD",
209 |                             price=Decimal(str(random.random())),
    |                                               ^^^^^^^^^^^^^^^ S311
210 |                             volume=Decimal(str(random.random() * 1000000)),
211 |                         ) for _ in range(100)
    |

tests/test_performance.py:210:48: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
208 |                             trading_pair="XRP/USD",
209 |                             price=Decimal(str(random.random())),
210 |                             volume=Decimal(str(random.random() * 1000000)),
    |                                                ^^^^^^^^^^^^^^^ S311
211 |                         ) for _ in range(100)
212 |                     ],
    |

tests/test_performance.py:238:100: E501 Line too long (118 > 99)
    |
236 |             "final_rss_mb": memory_samples[-1]["rss_mb"] if memory_samples else 0,
237 |             "mean_rss_mb": statistics.mean(rss_values) if rss_values else 0,
238 |             "memory_growth_mb": (memory_samples[-1]["rss_mb"] - memory_samples[0]["rss_mb"]) if memory_samples else 0,
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^ E501
239 |         }
    |

tests/test_performance.py:262:26: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
261 |         for i in range(operations):
262 |             key = f"key_{random.randint(0, 999)}"
    |                          ^^^^^^^^^^^^^^^^^^^^^^ S311
263 |
264 |             start = time.perf_counter()
    |

tests/test_performance.py:295:27: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
293 |         async def create_mock_connection():
294 |             await asyncio.sleep(0.01)  # Simulate connection time
295 |             return {"id": random.randint(1000, 9999), "created": time.time()}
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
296 |
297 |         pool = ConnectionPool(
    |

tests/test_performance.py:317:34: S311 Standard pseudo-random generators are not suitable for cryptographic purposes
    |
315 |         for _ in range(num_operations):
316 |             start = time.perf_counter()
317 |             await use_connection(random.uniform(0.01, 0.05))
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ S311
318 |             elapsed = time.perf_counter() - start
319 |             operation_times.append(elapsed * 1000)  # ms
    |

tests/test_performance.py:335:9: PLR0912 Too many branches (16 > 12)
    |
333 |         await pool.stop()
334 |
335 |     def generate_report(self) -> str:
    |         ^^^^^^^^^^^^^^^ PLR0912
336 |         """Generate performance test report."""
337 |         report = ["=" * 70]
    |

tests/test_performance.py:335:9: PLR0915 Too many statements (62 > 50)
    |
333 |         await pool.stop()
334 |
335 |     def generate_report(self) -> str:
    |         ^^^^^^^^^^^^^^^ PLR0915
336 |         """Generate performance test report."""
337 |         report = ["=" * 70]
    |

tests/test_performance.py:347:100: E501 Line too long (105 > 99)
    |
345 |             report.append("EVENT THROUGHPUT")
346 |             report.append("-" * 30)
347 |             report.append(f"Events/second: {self.results['event_throughput']['events_per_second']:,.0f}")
    |                                                                                                    ^^^^^^ E501
348 |             report.append("")
    |

tests/test_performance.py:365:100: E501 Line too long (104 > 99)
    |
363 |             report.append(f"Workers: {self.results['concurrent_load']['workers']}")
364 |             report.append(f"Total events: {self.results['concurrent_load']['total_events']:,}")
365 |             report.append(f"Events/second: {self.results['concurrent_load']['events_per_second']:,.0f}")
    |                                                                                                    ^^^^^ E501
366 |             report.append(f"Error rate: {self.results['concurrent_load']['error_rate']:.2%}")
367 |             report.append("")
    |

tests/test_performance.py:383:100: E501 Line too long (104 > 99)
    |
381 |             report.append("-" * 30)
382 |             report.append(f"Hit rate: {self.results['cache_performance']['hit_rate']:.1%}")
383 |             report.append(f"Mean latency: {self.results['cache_performance']['mean_latency_us']:.1f}s")
    |                                                                                                    ^^^^^ E501
384 |             report.append("")
    |

tests/test_performance.py:395:73: PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
    |
393 |         # Check against targets
394 |         if "event_throughput" in self.results:
395 |             if self.results["event_throughput"]["events_per_second"] >= 10000:
    |                                                                         ^^^^^ PLR2004
396 |                 targets_met.append(" Event throughput > 10,000/s")
397 |             else:
    |

tests/test_performance.py:401:64: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
400 |         if "prediction_latency" in self.results:
401 |             if self.results["prediction_latency"]["p99_ms"] <= 50:
    |                                                                ^^ PLR2004
402 |                 targets_met.append(" Prediction P99 latency < 50ms")
403 |             else:
    |

tests/test_performance.py:407:68: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
406 |         if "memory_usage" in self.results:
407 |             if self.results["memory_usage"]["memory_growth_mb"] <= 100:
    |                                                                    ^^^ PLR2004
408 |                 targets_met.append(" Memory growth < 100MB")
409 |             else:
    |

tests/test_performance.py:443:10: PTH123 `open()` should be replaced by `Path.open()`
    |
442 |     # Save report
443 |     with open("performance_test_report.txt", "w") as f:
    |          ^^^^ PTH123
444 |         f.write(report)
445 |     rich_print("\nReport saved to: performance_test_report.txt")
    |

tests/test_risk_management.py:49:100: E501 Line too long (110 > 99)
   |
48 |         # Risk per unit = Entry - Stop Loss
49 |         risk_per_unit = sample_proposed_signal.proposed_entry_price - sample_proposed_signal.proposed_sl_price
   |                                                                                                    ^^^^^^^^^^^ E501
50 |
51 |         # Position size = Risk Amount / Risk per unit
   |

tests/test_websocket_demo.py:35:100: E501 Line too long (104 > 99)
   |
33 |         {"time": "10:00:00.000", "status": "NEW", "latency": "0ms"},
34 |         {"time": "10:00:00.150", "status": "OPEN", "latency": "150ms"},
35 |         {"time": "10:00:02.300", "status": "PARTIALLY_FILLED", "latency": "50ms", "filled": "500/1000"},
   |                                                                                                    ^^^^^ E501
36 |         {"time": "10:00:02.850", "status": "FILLED", "latency": "50ms", "filled": "1000/1000"},
37 |     ]
   |

tests/test_websocket_demo.py:117:100: E501 Line too long (108 > 99)
    |
115 |     for disc in report["position_discrepancies"]:
116 |         rich_print(f"   - {disc['pair']}: {disc['type']}")
117 |         rich_print(f"     Internal: {disc.get('internal', 'N/A')}, Exchange: {disc.get('exchange', 'N/A')}")
    |                                                                                                    ^^^^^^^^^ E501
118 |         rich_print(f"     Severity: {disc['severity']}, Action: {disc['action']}")
    |

tests/unit/dal/conftest.py:1:1: D100 Missing docstring in public module
tests/unit/dal/conftest.py:11:17: PT003 `scope='function'` is implied in `@pytest.fixture()`
   |
11 | @pytest.fixture(scope="function")
   |                 ^^^^^^^^^^^^^^^^ PT003
12 | async def db_engine():
13 |     # Using SQLite in-memory for tests
   |
   = help: Remove implied `scope` argument

tests/unit/dal/conftest.py:12:11: D103 Missing docstring in public function
   |
11 | @pytest.fixture(scope="function")
12 | async def db_engine():
   |           ^^^^^^^^^ D103
13 |     # Using SQLite in-memory for tests
14 |     engine = create_async_engine("sqlite+aiosqlite:///:memory:")
   |

tests/unit/dal/conftest.py:18:17: PT003 `scope='function'` is implied in `@pytest.fixture()`
   |
16 |     await engine.dispose()
17 |
18 | @pytest.fixture(scope="function")
   |                 ^^^^^^^^^^^^^^^^ PT003
19 | async def db_setup(db_engine):
20 |     # Ensures all tables are created and dropped for each test function
   |
   = help: Remove implied `scope` argument

tests/unit/dal/conftest.py:19:11: D103 Missing docstring in public function
   |
18 | @pytest.fixture(scope="function")
19 | async def db_setup(db_engine):
   |           ^^^^^^^^ D103
20 |     # Ensures all tables are created and dropped for each test function
21 |     async with db_engine.begin() as conn:
   |

tests/unit/dal/conftest.py:29:17: PT003 `scope='function'` is implied in `@pytest.fixture()`
   |
27 |         await conn.run_sync(Base.metadata.drop_all)
28 |
29 | @pytest.fixture(scope="function")
   |                 ^^^^^^^^^^^^^^^^ PT003
30 | def db_session_maker(db_engine):
31 |     # Provides an async_sessionmaker for the test db engine.
   |
   = help: Remove implied `scope` argument

tests/unit/dal/conftest.py:30:5: D103 Missing docstring in public function
   |
29 | @pytest.fixture(scope="function")
30 | def db_session_maker(db_engine):
   |     ^^^^^^^^^^^^^^^^ D103
31 |     # Provides an async_sessionmaker for the test db engine.
32 |     maker = async_sessionmaker(bind=db_engine, class_=AsyncSession, expire_on_commit=False)
   |

tests/unit/dal/conftest.py:33:12: RET504 Unnecessary assignment to `maker` before `return` statement
   |
31 |     # Provides an async_sessionmaker for the test db engine.
32 |     maker = async_sessionmaker(bind=db_engine, class_=AsyncSession, expire_on_commit=False)
33 |     return maker
   |            ^^^^^ RET504
34 |
35 | @pytest.fixture(scope="function")
   |
   = help: Remove unnecessary assignment

tests/unit/dal/conftest.py:35:17: PT003 `scope='function'` is implied in `@pytest.fixture()`
   |
33 |     return maker
34 |
35 | @pytest.fixture(scope="function")
   |                 ^^^^^^^^^^^^^^^^ PT003
36 | async def db_session(db_session_maker):
37 |     # Provides an AsyncSession for a test, managing its lifecycle.
   |
   = help: Remove implied `scope` argument

tests/unit/dal/conftest.py:36:11: D103 Missing docstring in public function
   |
35 | @pytest.fixture(scope="function")
36 | async def db_session(db_session_maker):
   |           ^^^^^^^^^^ D103
37 |     # Provides an AsyncSession for a test, managing its lifecycle.
38 |     async with db_session_maker() as session:
   |

tests/unit/dal/test_order_repository.py:1:1: D100 Missing docstring in public module
tests/unit/dal/test_order_repository.py:24:5: D103 Missing docstring in public function
   |
23 | # Helper to create sample order data
24 | def sample_order_data(override: dict = None) -> dict:
   |     ^^^^^^^^^^^^^^^^^ D103
25 |     data = {
26 |         "id": uuid.uuid4(), # Client-generated UUID for PK
   |

tests/unit/dal/test_order_repository.py:24:33: RUF013 PEP 484 prohibits implicit `Optional`
   |
23 | # Helper to create sample order data
24 | def sample_order_data(override: dict = None) -> dict:
   |                                 ^^^^ RUF013
25 |     data = {
26 |         "id": uuid.uuid4(), # Client-generated UUID for PK
   |
   = help: Convert to `T | None`

tests/unit/dal/test_order_repository.py:48:11: D103 Missing docstring in public function
   |
46 | @pytest.mark.unit
47 | @pytest.mark.asyncio
48 | async def test_create_order(db_session_maker, mock_logger, db_setup): # Use db_session_maker
   |           ^^^^^^^^^^^^^^^^^ D103
49 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
   |

tests/unit/dal/test_order_repository.py:69:11: D103 Missing docstring in public function
   |
67 | @pytest.mark.unit
68 | @pytest.mark.asyncio
69 | async def test_get_order_by_id(db_session_maker, mock_logger, db_setup):
   |           ^^^^^^^^^^^^^^^^^^^^ D103
70 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
   |

tests/unit/dal/test_order_repository.py:90:11: D103 Missing docstring in public function
   |
88 | @pytest.mark.unit
89 | @pytest.mark.asyncio
90 | async def test_update_order_status_direct_repo_update(db_session_maker, mock_logger, db_setup):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
91 |     # This tests the BaseRepository's update method as used by OrderRepository
92 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
   |

tests/unit/dal/test_order_repository.py:118:11: D103 Missing docstring in public function
    |
116 | @pytest.mark.unit
117 | @pytest.mark.asyncio
118 | async def test_order_repository_update_order_status_method(db_session_maker, mock_logger, db_setup):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
119 |     # This tests the specific update_order_status method in OrderRepository
120 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
    |

tests/unit/dal/test_order_repository.py:118:100: E501 Line too long (100 > 99)
    |
116 | @pytest.mark.unit
117 | @pytest.mark.asyncio
118 | async def test_order_repository_update_order_status_method(db_session_maker, mock_logger, db_setup):
    |                                                                                                    ^ E501
119 |     # This tests the specific update_order_status method in OrderRepository
120 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
    |

tests/unit/dal/test_order_repository.py:144:11: D103 Missing docstring in public function
    |
142 | @pytest.mark.unit
143 | @pytest.mark.asyncio
144 | async def test_delete_order(db_session_maker, mock_logger, db_setup):
    |           ^^^^^^^^^^^^^^^^^ D103
145 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
    |

tests/unit/dal/test_order_repository.py:168:11: D103 Missing docstring in public function
    |
166 | @pytest.mark.unit
167 | @pytest.mark.asyncio
168 | async def test_get_active_orders(db_session_maker, mock_logger, db_setup):
    |           ^^^^^^^^^^^^^^^^^^^^^^ D103
169 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
    |

tests/unit/dal/test_order_repository.py:185:11: D103 Missing docstring in public function
    |
183 | @pytest.mark.unit
184 | @pytest.mark.asyncio
185 | async def test_get_recent_orders(db_session_maker, mock_logger, db_setup):
    |           ^^^^^^^^^^^^^^^^^^^^^^ D103
186 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
    |

tests/unit/dal/test_order_repository.py:189:100: E501 Line too long (107 > 99)
    |
188 |     now = datetime.now(UTC)
189 |     order_new_dict = sample_order_data({"created_at": now - timedelta(hours=1), "signal_id": uuid.uuid4()})
    |                                                                                                    ^^^^^^^^ E501
190 |     order_old_dict = sample_order_data({"created_at": now - timedelta(hours=48), "signal_id": uuid.uuid4()})
    |

tests/unit/dal/test_order_repository.py:190:100: E501 Line too long (108 > 99)
    |
188 |     now = datetime.now(UTC)
189 |     order_new_dict = sample_order_data({"created_at": now - timedelta(hours=1), "signal_id": uuid.uuid4()})
190 |     order_old_dict = sample_order_data({"created_at": now - timedelta(hours=48), "signal_id": uuid.uuid4()})
    |                                                                                                    ^^^^^^^^^ E501
191 |
192 |     async with db_session_maker() as session:
    |

tests/unit/dal/test_order_repository.py:201:38: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
200 |     all_recent_orders = await repo.get_recent_orders(hours=72)
201 |     assert len(all_recent_orders) == 2
    |                                      ^ PLR2004
202 |
203 | @pytest.mark.unit
    |

tests/unit/dal/test_order_repository.py:205:11: D103 Missing docstring in public function
    |
203 | @pytest.mark.unit
204 | @pytest.mark.asyncio
205 | async def test_get_orders_by_signal(db_session_maker, mock_logger, db_setup):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
206 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
207 |     target_signal_id = uuid.uuid4()
    |

tests/unit/dal/test_order_repository.py:210:100: E501 Line too long (124 > 99)
    |
208 |     other_signal_id = uuid.uuid4()
209 |
210 |     order1_data = sample_order_data({"signal_id": target_signal_id, "created_at": datetime.now(UTC) - timedelta(minutes=2)})
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
211 |     order2_data = sample_order_data({"signal_id": target_signal_id, "created_at": datetime.now(UTC) - timedelta(minutes=1)})
212 |     order3_data = sample_order_data({"signal_id": other_signal_id})
    |

tests/unit/dal/test_order_repository.py:211:100: E501 Line too long (124 > 99)
    |
210 |     order1_data = sample_order_data({"signal_id": target_signal_id, "created_at": datetime.now(UTC) - timedelta(minutes=2)})
211 |     order2_data = sample_order_data({"signal_id": target_signal_id, "created_at": datetime.now(UTC) - timedelta(minutes=1)})
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
212 |     order3_data = sample_order_data({"signal_id": other_signal_id})
    |

tests/unit/dal/test_order_repository.py:218:100: E501 Line too long (119 > 99)
    |
216 |         await session.commit()
217 |
218 |     signal_orders = await repo.get_orders_by_signal(str(target_signal_id)) # Pass ID as string if needed by repo method
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^ E501
219 |     assert len(signal_orders) == 2
220 |     assert signal_orders[0].id == order1_data["id"] # Check order (ASC by created_at)
    |

tests/unit/dal/test_order_repository.py:219:34: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
218 |     signal_orders = await repo.get_orders_by_signal(str(target_signal_id)) # Pass ID as string if needed by repo method
219 |     assert len(signal_orders) == 2
    |                                  ^ PLR2004
220 |     assert signal_orders[0].id == order1_data["id"] # Check order (ASC by created_at)
221 |     assert signal_orders[1].id == order2_data["id"]
    |

tests/unit/dal/test_order_repository.py:227:11: D103 Missing docstring in public function
    |
225 | @pytest.mark.unit
226 | @pytest.mark.asyncio
227 | async def test_find_by_exchange_id(db_session_maker, mock_logger, db_setup):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ D103
228 |     repo = OrderRepository(session_maker=db_session_maker, logger=mock_logger)
229 |     target_exchange_id = "EXCH_ID_123"
    |

tests/unit/dal/test_order_repository.py:231:100: E501 Line too long (111 > 99)
    |
229 |     target_exchange_id = "EXCH_ID_123"
230 |
231 |     order_data_target = sample_order_data({"exchange_order_id": target_exchange_id, "signal_id": uuid.uuid4()})
    |                                                                                                    ^^^^^^^^^^^^ E501
232 |     order_data_other = sample_order_data({"exchange_order_id": "EXCH_ID_456", "signal_id": uuid.uuid4()})
    |

tests/unit/dal/test_order_repository.py:232:100: E501 Line too long (105 > 99)
    |
231 |     order_data_target = sample_order_data({"exchange_order_id": target_exchange_id, "signal_id": uuid.uuid4()})
232 |     order_data_other = sample_order_data({"exchange_order_id": "EXCH_ID_456", "signal_id": uuid.uuid4()})
    |                                                                                                    ^^^^^^ E501
233 |
234 |     async with db_session_maker() as session:
    |

tests/unit/test_feature_engine_pipeline_computations.py:40:5: D103 Missing docstring in public function
   |
38 | # --- New Fixtures ---
39 | @pytest.fixture
40 | def sample_ohlcv_data_long() -> pd.DataFrame:
   |     ^^^^^^^^^^^^^^^^^^^^^^ D103
41 |     data_len = 35 # Enough for typical periods like 14, 20, 26
42 |     data = {
   |

tests/unit/test_feature_engine_pipeline_computations.py:44:55: NPY002 Replace legacy `np.random.randn` call with `np.random.Generator`
   |
42 |     data = {
43 |         "open": np.array([100 + i + np.sin(i/5) for i in range(data_len)], dtype="float64"),
44 |         "high": np.array([102 + i + np.sin(i/5) + abs(np.random.randn()) for i in range(data_len)], dtype="float64"),
   |                                                       ^^^^^^^^^^^^^^^ NPY002
45 |         "low": np.array([98 + i + np.sin(i/5) - abs(np.random.randn()) for i in range(data_len)], dtype="float64"),
46 |         "close": np.array([100 + i + np.cos(i/5) for i in range(data_len)], dtype="float64"), # Use 'close' from sample_close_prices_l
   |

tests/unit/test_feature_engine_pipeline_computations.py:44:100: E501 Line too long (117 > 99)
   |
42 |     data = {
43 |         "open": np.array([100 + i + np.sin(i/5) for i in range(data_len)], dtype="float64"),
44 |         "high": np.array([102 + i + np.sin(i/5) + abs(np.random.randn()) for i in range(data_len)], dtype="float64"),
   |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
45 |         "low": np.array([98 + i + np.sin(i/5) - abs(np.random.randn()) for i in range(data_len)], dtype="float64"),
46 |         "close": np.array([100 + i + np.cos(i/5) for i in range(data_len)], dtype="float64"), # Use 'close' from sample_close_prices_l
   |

tests/unit/test_feature_engine_pipeline_computations.py:45:53: NPY002 Replace legacy `np.random.randn` call with `np.random.Generator`
   |
43 |      "open": np.array([100 + i + np.sin(i/5) for i in range(data_len)], dtype="float64"),
44 |      "high": np.array([102 + i + np.sin(i/5) + abs(np.random.randn()) for i in range(data_len)], dtype="float64"),
45 |      "low": np.array([98 + i + np.sin(i/5) - abs(np.random.randn()) for i in range(data_len)], dtype="float64"),
   |                                                   ^^^^^^^^^^^^^^^ NPY002
46 |      "close": np.array([100 + i + np.cos(i/5) for i in range(data_len)], dtype="float64"), # Use 'close' from sample_close_prices_lon
47 |      "volume": np.array([1000 + i*10 + abs(np.random.randn()*100) for i in range(data_len)], dtype="float64"),
   |

tests/unit/test_feature_engine_pipeline_computations.py:45:100: E501 Line too long (115 > 99)
   |
43 |      "open": np.array([100 + i + np.sin(i/5) for i in range(data_len)], dtype="float64"),
44 |      "high": np.array([102 + i + np.sin(i/5) + abs(np.random.randn()) for i in range(data_len)], dtype="float64"),
45 |      "low": np.array([98 + i + np.sin(i/5) - abs(np.random.randn()) for i in range(data_len)], dtype="float64"),
   |                                                                                                  ^^^^^^^^^^^^^^^^ E501
46 |      "close": np.array([100 + i + np.cos(i/5) for i in range(data_len)], dtype="float64"), # Use 'close' from sample_close_prices_lon
47 |      "volume": np.array([1000 + i*10 + abs(np.random.randn()*100) for i in range(data_len)], dtype="float64"),
   |

tests/unit/test_feature_engine_pipeline_computations.py:46:100: E501 Line too long (152 > 99)
   |
44 | m.randn()) for i in range(data_len)], dtype="float64"),
45 | randn()) for i in range(data_len)], dtype="float64"),
46 | e(data_len)], dtype="float64"), # Use 'close' from sample_close_prices_long for some tests
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
47 | )*100) for i in range(data_len)], dtype="float64"),
48 | 
   |

tests/unit/test_feature_engine_pipeline_computations.py:47:47: NPY002 Replace legacy `np.random.randn` call with `np.random.Generator`
   |
45 |         "low": np.array([98 + i + np.sin(i/5) - abs(np.random.randn()) for i in range(data_len)], dtype="float64"),
46 |         "close": np.array([100 + i + np.cos(i/5) for i in range(data_len)], dtype="float64"), # Use 'close' from sample_close_prices_l
47 |         "volume": np.array([1000 + i*10 + abs(np.random.randn()*100) for i in range(data_len)], dtype="float64"),
   |                                               ^^^^^^^^^^^^^^^ NPY002
48 |     }
49 |     df = pd.DataFrame(data)
   |

tests/unit/test_feature_engine_pipeline_computations.py:47:100: E501 Line too long (113 > 99)
   |
45 |         "low": np.array([98 + i + np.sin(i/5) - abs(np.random.randn()) for i in range(data_len)], dtype="float64"),
46 |         "close": np.array([100 + i + np.cos(i/5) for i in range(data_len)], dtype="float64"), # Use 'close' from sample_close_prices_l
47 |         "volume": np.array([1000 + i*10 + abs(np.random.randn()*100) for i in range(data_len)], dtype="float64"),
   |                                                                                                    ^^^^^^^^^^^^^^ E501
48 |     }
49 |     df = pd.DataFrame(data)
   |

tests/unit/test_feature_engine_pipeline_computations.py:56:5: D103 Missing docstring in public function
   |
55 | @pytest.fixture
56 | def sample_ohlcv_data_short(sample_ohlcv_data_long) -> pd.DataFrame:
   |     ^^^^^^^^^^^^^^^^^^^^^^^ D103
57 |     return sample_ohlcv_data_long.head(5)
   |

tests/unit/test_feature_engine_pipeline_computations.py:60:5: D103 Missing docstring in public function
   |
59 | @pytest.fixture
60 | def sample_ohlcv_data_with_nan(sample_ohlcv_data_long) -> pd.DataFrame:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
61 |     df = sample_ohlcv_data_long.copy()
62 |     df.loc[2, "high"] = np.nan
   |

tests/unit/test_feature_engine_pipeline_computations.py:69:5: D103 Missing docstring in public function
   |
68 | @pytest.fixture
69 | def sample_l2_book_valid() -> dict:
   |     ^^^^^^^^^^^^^^^^^^^^ D103
70 |     return {
71 |         "bids": [[Decimal("100.00"), Decimal("1.5")], [Decimal("99.95"), Decimal("2.0")]],
   |

tests/unit/test_feature_engine_pipeline_computations.py:77:5: D103 Missing docstring in public function
   |
76 | @pytest.fixture
77 | def sample_l2_book_empty() -> dict:
   |     ^^^^^^^^^^^^^^^^^^^^ D103
78 |     return {"bids": [], "asks": [], "timestamp": datetime.now(UTC)}
   |

tests/unit/test_feature_engine_pipeline_computations.py:81:5: D103 Missing docstring in public function
   |
80 | @pytest.fixture
81 | def sample_l2_book_empty_bids() -> dict:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
82 |     return {
83 |         "bids": [],
   |

tests/unit/test_feature_engine_pipeline_computations.py:89:5: D103 Missing docstring in public function
   |
88 | @pytest.fixture
89 | def sample_l2_book_empty_asks() -> dict:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
90 |     return {
91 |         "bids": [[Decimal("100.00"), Decimal("1.5")]],
   |

tests/unit/test_feature_engine_pipeline_computations.py:98:5: D103 Missing docstring in public function
    |
 97 | @pytest.fixture
 98 | def sample_l2_books_series(sample_l2_book_valid, sample_l2_book_empty) -> pd.Series:
    |     ^^^^^^^^^^^^^^^^^^^^^^ D103
 99 |     # Timestamps for indexing the series
100 |     idx = pd.to_datetime([
    |

tests/unit/test_feature_engine_pipeline_computations.py:108:5: D103 Missing docstring in public function
    |
107 | @pytest.fixture
108 | def sample_trades_deque() -> deque:
    |     ^^^^^^^^^^^^^^^^^^^ D103
109 |     return deque([
110 |         {"timestamp": datetime(2023, 1, 1, 12, 0, 0, tzinfo=UTC), "price": Decimal("100.0"), "volume": Decimal("1.0"), "side": "buy"},
    |

tests/unit/test_feature_engine_pipeline_computations.py:110:100: E501 Line too long (134 > 99)
    |
108 | 
109 | 
110 | tzinfo=UTC), "price": Decimal("100.0"), "volume": Decimal("1.0"), "side": "buy"},
    |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
111 |  tzinfo=UTC), "price": Decimal("100.1"), "volume": Decimal("0.5"), "side": "sell"},
112 |  tzinfo=UTC), "price": Decimal("100.2"), "volume": Decimal("1.2"), "side": "buy"},
    |

tests/unit/test_feature_engine_pipeline_computations.py:111:100: E501 Line too long (136 > 99)
    |
109 | 
110 | zinfo=UTC), "price": Decimal("100.0"), "volume": Decimal("1.0"), "side": "buy"},
111 | tzinfo=UTC), "price": Decimal("100.1"), "volume": Decimal("0.5"), "side": "sell"},
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
112 | tzinfo=UTC), "price": Decimal("100.2"), "volume": Decimal("1.2"), "side": "buy"},
113 | zinfo=UTC), "price": Decimal("100.3"), "volume": Decimal("0.8"), "side": "buy"}, # Next bar
    |

tests/unit/test_feature_engine_pipeline_computations.py:112:100: E501 Line too long (135 > 99)
    |
110 | zinfo=UTC), "price": Decimal("100.0"), "volume": Decimal("1.0"), "side": "buy"},
111 | tzinfo=UTC), "price": Decimal("100.1"), "volume": Decimal("0.5"), "side": "sell"},
112 | tzinfo=UTC), "price": Decimal("100.2"), "volume": Decimal("1.2"), "side": "buy"},
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
113 | zinfo=UTC), "price": Decimal("100.3"), "volume": Decimal("0.8"), "side": "buy"}, # Next bar
114 | tzinfo=UTC), "price": Decimal("100.2"), "volume": Decimal("0.3"), "side": "sell"},
    |

tests/unit/test_feature_engine_pipeline_computations.py:113:100: E501 Line too long (145 > 99)
    |
111 | o=UTC), "price": Decimal("100.1"), "volume": Decimal("0.5"), "side": "sell"},
112 | o=UTC), "price": Decimal("100.2"), "volume": Decimal("1.2"), "side": "buy"},
113 | =UTC), "price": Decimal("100.3"), "volume": Decimal("0.8"), "side": "buy"}, # Next bar
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
114 | o=UTC), "price": Decimal("100.2"), "volume": Decimal("0.3"), "side": "sell"},
115 | 
    |

tests/unit/test_feature_engine_pipeline_computations.py:114:100: E501 Line too long (136 > 99)
    |
112 | tzinfo=UTC), "price": Decimal("100.2"), "volume": Decimal("1.2"), "side": "buy"},
113 | zinfo=UTC), "price": Decimal("100.3"), "volume": Decimal("0.8"), "side": "buy"}, # Next bar
114 | tzinfo=UTC), "price": Decimal("100.2"), "volume": Decimal("0.3"), "side": "sell"},
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
115 | 
    |

tests/unit/test_feature_engine_pipeline_computations.py:118:5: D103 Missing docstring in public function
    |
117 | @pytest.fixture
118 | def sample_bar_start_times() -> pd.Series:
    |     ^^^^^^^^^^^^^^^^^^^^^^ D103
119 |     return pd.Series([
120 |         datetime(2023, 1, 1, 12, 0, 0, tzinfo=UTC),
    |

tests/unit/test_feature_engine_pipeline_computations.py:129:7: D101 Missing docstring in public class
    |
128 | # Tests for _pipeline_compute_rsi (existing)
129 | class TestPipelineComputeRSI:
    |       ^^^^^^^^^^^^^^^^^^^^^^ D101
130 |     def test_rsi_basic_calculation(self, sample_close_prices_long):
131 |         period = 14
    |

tests/unit/test_feature_engine_pipeline_computations.py:130:9: D102 Missing docstring in public method
    |
128 | # Tests for _pipeline_compute_rsi (existing)
129 | class TestPipelineComputeRSI:
130 |     def test_rsi_basic_calculation(self, sample_close_prices_long):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
131 |         period = 14
132 |         expected_rsi = sample_close_prices_long.ta.rsi(length=period)
    |

tests/unit/test_feature_engine_pipeline_computations.py:140:9: D102 Missing docstring in public method
    |
138 |         assert actual_rsi.name == f"rsi_{period}"
139 |
140 |     def test_rsi_insufficient_data(self, sample_close_prices_short):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
141 |         period = 14
142 |         expected_rsi = sample_close_prices_short.ta.rsi(length=period)
    |

tests/unit/test_feature_engine_pipeline_computations.py:151:9: D102 Missing docstring in public method
    |
149 |         assert actual_rsi.isna().all()
150 |
151 |     def test_rsi_with_nan_input(self, sample_close_prices_with_nan):
    |         ^^^^^^^^^^^^^^^^^^^^^^^ D102
152 |         period = 14
153 |         expected_rsi = sample_close_prices_with_nan.ta.rsi(length=period)
    |

tests/unit/test_feature_engine_pipeline_computations.py:156:100: E501 Line too long (101 > 99)
    |
154 |         expected_rsi.name = f"rsi_{period}"
155 |
156 |         actual_rsi = FeatureEngine._pipeline_compute_rsi(sample_close_prices_with_nan, period=period)
    |                                                                                                    ^^ E501
157 |
158 |         pd.testing.assert_series_equal(actual_rsi, expected_rsi, check_dtype=True)
    |

tests/unit/test_feature_engine_pipeline_computations.py:161:9: D102 Missing docstring in public method
    |
159 |         assert actual_rsi.name == f"rsi_{period}"
160 |
161 |     def test_rsi_input_not_series(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ D102
162 |         result = FeatureEngine._pipeline_compute_rsi([10, 11, 12], period=5) # type: ignore
163 |         assert isinstance(result, pd.Series)
    |

tests/unit/test_feature_engine_pipeline_computations.py:168:7: D101 Missing docstring in public class
    |
167 | # Tests for _pipeline_compute_macd (existing)
168 | class TestPipelineComputeMACD:
    |       ^^^^^^^^^^^^^^^^^^^^^^^ D101
169 |     def test_macd_basic_calculation(self, sample_close_prices_long):
170 |         fast = 12
    |

tests/unit/test_feature_engine_pipeline_computations.py:169:9: D102 Missing docstring in public method
    |
167 | # Tests for _pipeline_compute_macd (existing)
168 | class TestPipelineComputeMACD:
169 |     def test_macd_basic_calculation(self, sample_close_prices_long):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
170 |         fast = 12
171 |         slow = 26
    |

tests/unit/test_feature_engine_pipeline_computations.py:175:100: E501 Line too long (124 > 99)
    |
174 |         expected_macd_df = sample_close_prices_long.ta.macd(fast=fast, slow=slow, signal=signal)
175 |         actual_macd_df = FeatureEngine._pipeline_compute_macd(sample_close_prices_long, fast=fast, slow=slow, signal=signal)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
176 |         pd.testing.assert_frame_equal(actual_macd_df, expected_macd_df, check_dtype=True)
    |

tests/unit/test_feature_engine_pipeline_computations.py:178:9: D102 Missing docstring in public method
    |
176 |         pd.testing.assert_frame_equal(actual_macd_df, expected_macd_df, check_dtype=True)
177 |
178 |     def test_macd_insufficient_data(self, sample_close_prices_short):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
179 |         fast = 12
180 |         slow = 26
    |

tests/unit/test_feature_engine_pipeline_computations.py:183:100: E501 Line too long (125 > 99)
    |
181 |         signal = 9
182 |         expected_macd_df = sample_close_prices_short.ta.macd(fast=fast, slow=slow, signal=signal)
183 |         actual_macd_df = FeatureEngine._pipeline_compute_macd(sample_close_prices_short, fast=fast, slow=slow, signal=signal)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
184 |         pd.testing.assert_frame_equal(actual_macd_df, expected_macd_df, check_dtype=True)
185 |         assert actual_macd_df.isna().all().all()
    |

tests/unit/test_feature_engine_pipeline_computations.py:187:9: D102 Missing docstring in public method
    |
185 |         assert actual_macd_df.isna().all().all()
186 |
187 |     def test_macd_with_nan_input(self, sample_close_prices_with_nan):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ D102
188 |         fast = 12
189 |         slow = 26
    |

tests/unit/test_feature_engine_pipeline_computations.py:191:100: E501 Line too long (100 > 99)
    |
189 |         slow = 26
190 |         signal = 9
191 |         expected_macd_df = sample_close_prices_with_nan.ta.macd(fast=fast, slow=slow, signal=signal)
    |                                                                                                    ^ E501
192 |         actual_macd_df = FeatureEngine._pipeline_compute_macd(sample_close_prices_with_nan, fast=fast, slow=slow, signal=signal)
193 |         pd.testing.assert_frame_equal(actual_macd_df, expected_macd_df, check_dtype=True)
    |

tests/unit/test_feature_engine_pipeline_computations.py:192:100: E501 Line too long (128 > 99)
    |
190 |         signal = 9
191 |         expected_macd_df = sample_close_prices_with_nan.ta.macd(fast=fast, slow=slow, signal=signal)
192 |         actual_macd_df = FeatureEngine._pipeline_compute_macd(sample_close_prices_with_nan, fast=fast, slow=slow, signal=signal)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
193 |         pd.testing.assert_frame_equal(actual_macd_df, expected_macd_df, check_dtype=True)
    |

tests/unit/test_feature_engine_pipeline_computations.py:195:9: D102 Missing docstring in public method
    |
193 |         pd.testing.assert_frame_equal(actual_macd_df, expected_macd_df, check_dtype=True)
194 |
195 |     def test_macd_input_not_series(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
196 |         result = FeatureEngine._pipeline_compute_macd([10,11,12], fast=12, slow=26, signal=9) # type: ignore
197 |         assert isinstance(result, pd.DataFrame)
    |

tests/unit/test_feature_engine_pipeline_computations.py:203:7: D101 Missing docstring in public class
    |
201 | # --- New Test Classes ---
202 |
203 | class TestPipelineComputeBBands:
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^ D101
204 |     def test_bbands_basic_calculation(self, sample_close_prices_long):
205 |         length = 20
    |

tests/unit/test_feature_engine_pipeline_computations.py:204:9: D102 Missing docstring in public method
    |
203 | class TestPipelineComputeBBands:
204 |     def test_bbands_basic_calculation(self, sample_close_prices_long):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
205 |         length = 20
206 |         std_dev = 2.0
    |

tests/unit/test_feature_engine_pipeline_computations.py:208:100: E501 Line too long (116 > 99)
    |
206 |         std_dev = 2.0
207 |         expected_df = sample_close_prices_long.ta.bbands(length=length, std=std_dev)
208 |         actual_df = FeatureEngine._pipeline_compute_bbands(sample_close_prices_long, length=length, std_dev=std_dev)
    |                                                                                                    ^^^^^^^^^^^^^^^^^ E501
209 |         pd.testing.assert_frame_equal(actual_df, expected_df, check_dtype=True)
    |

tests/unit/test_feature_engine_pipeline_computations.py:211:9: D102 Missing docstring in public method
    |
209 |         pd.testing.assert_frame_equal(actual_df, expected_df, check_dtype=True)
210 |
211 |     def test_bbands_insufficient_data(self, sample_close_prices_short):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
212 |         length = 20
213 |         std_dev = 2.0
    |

tests/unit/test_feature_engine_pipeline_computations.py:215:100: E501 Line too long (117 > 99)
    |
213 |         std_dev = 2.0
214 |         expected_df = sample_close_prices_short.ta.bbands(length=length, std=std_dev) # All NaNs
215 |         actual_df = FeatureEngine._pipeline_compute_bbands(sample_close_prices_short, length=length, std_dev=std_dev)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^ E501
216 |         pd.testing.assert_frame_equal(actual_df, expected_df, check_dtype=True)
217 |         assert actual_df.isna().all().all()
    |

tests/unit/test_feature_engine_pipeline_computations.py:219:9: D102 Missing docstring in public method
    |
217 |         assert actual_df.isna().all().all()
218 |
219 |     def test_bbands_with_nan_input(self, sample_close_prices_with_nan):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
220 |         length = 10 # Shorter to ensure some calculation around NaNs
221 |         std_dev = 2.0
    |

tests/unit/test_feature_engine_pipeline_computations.py:223:100: E501 Line too long (120 > 99)
    |
221 |         std_dev = 2.0
222 |         expected_df = sample_close_prices_with_nan.ta.bbands(length=length, std=std_dev)
223 |         actual_df = FeatureEngine._pipeline_compute_bbands(sample_close_prices_with_nan, length=length, std_dev=std_dev)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^ E501
224 |         pd.testing.assert_frame_equal(actual_df, expected_df, check_dtype=True)
    |

tests/unit/test_feature_engine_pipeline_computations.py:226:7: D101 Missing docstring in public class
    |
224 |         pd.testing.assert_frame_equal(actual_df, expected_df, check_dtype=True)
225 |
226 | class TestPipelineComputeROC:
    |       ^^^^^^^^^^^^^^^^^^^^^^ D101
227 |     def test_roc_basic_calculation(self, sample_close_prices_long):
228 |         period = 10
    |

tests/unit/test_feature_engine_pipeline_computations.py:227:9: D102 Missing docstring in public method
    |
226 | class TestPipelineComputeROC:
227 |     def test_roc_basic_calculation(self, sample_close_prices_long):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
228 |         period = 10
229 |         expected_series = sample_close_prices_long.ta.roc(length=period)
    |

tests/unit/test_feature_engine_pipeline_computations.py:231:100: E501 Line too long (100 > 99)
    |
229 |         expected_series = sample_close_prices_long.ta.roc(length=period)
230 |         expected_series.name = f"roc_{period}"
231 |         actual_series = FeatureEngine._pipeline_compute_roc(sample_close_prices_long, period=period)
    |                                                                                                    ^ E501
232 |         pd.testing.assert_series_equal(actual_series, expected_series, check_dtype=True)
233 |         assert actual_series.name == f"roc_{period}"
    |

tests/unit/test_feature_engine_pipeline_computations.py:235:7: D101 Missing docstring in public class
    |
233 |         assert actual_series.name == f"roc_{period}"
234 |
235 | class TestPipelineComputeATR:
    |       ^^^^^^^^^^^^^^^^^^^^^^ D101
236 |     def test_atr_basic_calculation(self, sample_ohlcv_data_long):
237 |         length = 14
    |

tests/unit/test_feature_engine_pipeline_computations.py:236:9: D102 Missing docstring in public method
    |
235 | class TestPipelineComputeATR:
236 |     def test_atr_basic_calculation(self, sample_ohlcv_data_long):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
237 |         length = 14
238 |         expected_series = ta.atr(high=sample_ohlcv_data_long["high"], low=sample_ohlcv_data_long["low"], close=sample_ohlcv_data_long
    |

tests/unit/test_feature_engine_pipeline_computations.py:238:100: E501 Line too long (158 > 99)
    |
236 | 
237 | 
238 | h"], low=sample_ohlcv_data_long["low"], close=sample_ohlcv_data_long["close"], length=length)
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
239 | 
240 | e_ohlcv_data_long, length=length)
    |

tests/unit/test_feature_engine_pipeline_computations.py:244:9: D102 Missing docstring in public method
    |
242 |         assert actual_series.name == f"atr_{length}"
243 |
244 |     def test_atr_missing_columns(self, sample_ohlcv_data_long):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ D102
245 |         length = 14
246 |         df_missing_high = sample_ohlcv_data_long.drop(columns=["high"])
    |

tests/unit/test_feature_engine_pipeline_computations.py:250:7: D101 Missing docstring in public class
    |
248 |         assert actual_series.empty # Or specific error handling if implemented
249 |
250 | class TestPipelineComputeStdev:
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ D101
251 |     def test_stdev_basic_calculation(self, sample_close_prices_long):
252 |         length = 20
    |

tests/unit/test_feature_engine_pipeline_computations.py:251:9: D102 Missing docstring in public method
    |
250 | class TestPipelineComputeStdev:
251 |     def test_stdev_basic_calculation(self, sample_close_prices_long):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
252 |         length = 20
253 |         expected_series = sample_close_prices_long.rolling(window=length).std()
    |

tests/unit/test_feature_engine_pipeline_computations.py:255:100: E501 Line too long (102 > 99)
    |
253 |         expected_series = sample_close_prices_long.rolling(window=length).std()
254 |         expected_series.name = f"stdev_{length}"
255 |         actual_series = FeatureEngine._pipeline_compute_stdev(sample_close_prices_long, length=length)
    |                                                                                                    ^^^ E501
256 |         pd.testing.assert_series_equal(actual_series, expected_series, check_dtype=True)
257 |         assert actual_series.name == f"stdev_{length}"
    |

tests/unit/test_feature_engine_pipeline_computations.py:259:7: N801 Class name `TestPipelineComputeVWAP_OHLCV` should use CapWords convention
    |
257 |         assert actual_series.name == f"stdev_{length}"
258 |
259 | class TestPipelineComputeVWAP_OHLCV:
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ N801
260 |     def test_vwap_ohlcv_basic(self, sample_ohlcv_data_long):
261 |         length = 14
    |

tests/unit/test_feature_engine_pipeline_computations.py:259:7: D101 Missing docstring in public class
    |
257 |         assert actual_series.name == f"stdev_{length}"
258 |
259 | class TestPipelineComputeVWAP_OHLCV:
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D101
260 |     def test_vwap_ohlcv_basic(self, sample_ohlcv_data_long):
261 |         length = 14
    |

tests/unit/test_feature_engine_pipeline_computations.py:260:9: D102 Missing docstring in public method
    |
259 | class TestPipelineComputeVWAP_OHLCV:
260 |     def test_vwap_ohlcv_basic(self, sample_ohlcv_data_long):
    |         ^^^^^^^^^^^^^^^^^^^^^ D102
261 |         length = 14
262 |         # Manual or trusted calculation for VWAP is complex for a rolling version.
    |

tests/unit/test_feature_engine_pipeline_computations.py:277:100: E501 Line too long (145 > 99)
    |
275 | ds=length).sum()
276 | 
277 | ([Decimal("Infinity"), Decimal("-Infinity")], np.nan).astype("float64").fillna(np.nan)
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
278 | 
    |

tests/unit/test_feature_engine_pipeline_computations.py:280:100: E501 Line too long (102 > 99)
    |
278 |         expected_vwap_float.name = f"vwap_ohlcv_{length}"
279 |
280 |         actual_series = FeatureEngine._pipeline_compute_vwap_ohlcv(df, length=length) # df has float64
    |                                                                                                    ^^^ E501
281 |         pd.testing.assert_series_equal(actual_series, expected_vwap_float, check_dtype=True, atol=1e-9) # Added atol for float precis
282 |         assert actual_series.name == f"vwap_ohlcv_{length}"
    |

tests/unit/test_feature_engine_pipeline_computations.py:281:100: E501 Line too long (136 > 99)
    |
280 | e_vwap_ohlcv(df, length=length) # df has float64
281 | expected_vwap_float, check_dtype=True, atol=1e-9) # Added atol for float precision
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
282 | gth}"
    |

tests/unit/test_feature_engine_pipeline_computations.py:284:9: D102 Missing docstring in public method
    |
282 |         assert actual_series.name == f"vwap_ohlcv_{length}"
283 |
284 |     def test_vwap_ohlcv_zero_volume(self, sample_ohlcv_data_long):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
285 |         length = 5
286 |         df = sample_ohlcv_data_long.copy()
    |

tests/unit/test_feature_engine_pipeline_computations.py:290:100: E501 Line too long (112 > 99)
    |
288 |         actual_series = FeatureEngine._pipeline_compute_vwap_ohlcv(df, length=length)
289 |         # Expect NaN where sum_vol over window is 0
290 |         assert actual_series.iloc[length-1:].isna().any() # Check that some NaNs are produced due to zero volume
    |                                                                                                    ^^^^^^^^^^^^^ E501
291 |         assert actual_series.name == f"vwap_ohlcv_{length}"
    |

tests/unit/test_feature_engine_pipeline_computations.py:294:7: D101 Missing docstring in public class
    |
294 | class TestPipelineL2Features:
    |       ^^^^^^^^^^^^^^^^^^^^^^ D101
295 |     def test_l2_spread(self, sample_l2_books_series, sample_l2_book_valid):
296 |         actual_df = FeatureEngine._pipeline_compute_l2_spread(sample_l2_books_series)
    |

tests/unit/test_feature_engine_pipeline_computations.py:295:9: D102 Missing docstring in public method
    |
294 | class TestPipelineL2Features:
295 |     def test_l2_spread(self, sample_l2_books_series, sample_l2_book_valid):
    |         ^^^^^^^^^^^^^^ D102
296 |         actual_df = FeatureEngine._pipeline_compute_l2_spread(sample_l2_books_series)
297 |         assert isinstance(actual_df, pd.DataFrame)
    |

tests/unit/test_feature_engine_pipeline_computations.py:305:100: E501 Line too long (124 > 99)
    |
303 |         valid_book = sample_l2_book_valid
304 |         expected_abs = float(valid_book["asks"][0][0] - valid_book["bids"][0][0])
305 |         expected_pct = float((expected_abs / float(valid_book["bids"][0][0] + valid_book["asks"][0][0])*Decimal("2")) * 100)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ E501
306 |         assert np.isclose(actual_df["abs_spread"].iloc[0], expected_abs)
307 |         assert np.isclose(actual_df["pct_spread"].iloc[0], expected_pct)
    |

tests/unit/test_feature_engine_pipeline_computations.py:310:9: D102 Missing docstring in public method
    |
308 |         assert actual_df["abs_spread"].iloc[1:].isna().all() # None and empty book
309 |
310 |     def test_l2_imbalance(self, sample_l2_books_series, sample_l2_book_valid):
    |         ^^^^^^^^^^^^^^^^^ D102
311 |         levels = 2
312 |         actual_series = FeatureEngine._pipeline_compute_l2_imbalance(sample_l2_books_series, levels=levels)
    |

tests/unit/test_feature_engine_pipeline_computations.py:312:100: E501 Line too long (107 > 99)
    |
310 |     def test_l2_imbalance(self, sample_l2_books_series, sample_l2_book_valid):
311 |         levels = 2
312 |         actual_series = FeatureEngine._pipeline_compute_l2_imbalance(sample_l2_books_series, levels=levels)
    |                                                                                                    ^^^^^^^^ E501
313 |         assert isinstance(actual_series, pd.Series)
314 |         assert actual_series.name == f"imbalance_{levels}"
    |

tests/unit/test_feature_engine_pipeline_computations.py:325:9: D102 Missing docstring in public method
    |
323 |         assert actual_series.iloc[2] == 0.0 # Empty book (or nan depending on impl choice)
324 |
325 |     def test_l2_wap(self, sample_l2_books_series, sample_l2_book_valid):
    |         ^^^^^^^^^^^ D102
326 |         levels = 1
327 |         actual_series = FeatureEngine._pipeline_compute_l2_wap(sample_l2_books_series, levels=levels)
    |

tests/unit/test_feature_engine_pipeline_computations.py:327:100: E501 Line too long (101 > 99)
    |
325 |     def test_l2_wap(self, sample_l2_books_series, sample_l2_book_valid):
326 |         levels = 1
327 |         actual_series = FeatureEngine._pipeline_compute_l2_wap(sample_l2_books_series, levels=levels)
    |                                                                                                    ^^ E501
328 |         assert isinstance(actual_series, pd.Series)
329 |         assert actual_series.name == f"wap_{levels}"
    |

tests/unit/test_feature_engine_pipeline_computations.py:332:39: E702 Multiple statements on one line (semicolon)
    |
331 |         valid_book = sample_l2_book_valid
332 |         bbp = valid_book["bids"][0][0]; bbv = valid_book["bids"][0][1]
    |                                       ^ E702
333 |         bap = valid_book["asks"][0][0]; bav = valid_book["asks"][0][1]
334 |         expected_wap = float((bbp * bav + bap * bbv) / (bbv + bav))
    |

tests/unit/test_feature_engine_pipeline_computations.py:333:39: E702 Multiple statements on one line (semicolon)
    |
331 |         valid_book = sample_l2_book_valid
332 |         bbp = valid_book["bids"][0][0]; bbv = valid_book["bids"][0][1]
333 |         bap = valid_book["asks"][0][0]; bav = valid_book["asks"][0][1]
    |                                       ^ E702
334 |         expected_wap = float((bbp * bav + bap * bbv) / (bbv + bav))
335 |         assert np.isclose(actual_series.iloc[0], expected_wap)
    |

tests/unit/test_feature_engine_pipeline_computations.py:339:9: D102 Missing docstring in public method
    |
339 |     def test_l2_depth(self, sample_l2_books_series, sample_l2_book_valid):
    |         ^^^^^^^^^^^^^ D102
340 |         levels = 2
341 |         actual_df = FeatureEngine._pipeline_compute_l2_depth(sample_l2_books_series, levels=levels)
    |

tests/unit/test_feature_engine_pipeline_computations.py:353:7: D101 Missing docstring in public class
    |
353 | class TestPipelineTradeBasedFeatures:
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D101
354 |     def test_vwap_trades(self, sample_trades_deque, sample_bar_start_times):
355 |         interval = 60
    |

tests/unit/test_feature_engine_pipeline_computations.py:354:9: D102 Missing docstring in public method
    |
353 | class TestPipelineTradeBasedFeatures:
354 |     def test_vwap_trades(self, sample_trades_deque, sample_bar_start_times):
    |         ^^^^^^^^^^^^^^^^ D102
355 |         interval = 60
356 |         actual_series = FeatureEngine._pipeline_compute_vwap_trades(sample_trades_deque, sample_bar_start_times, interval)
    |

tests/unit/test_feature_engine_pipeline_computations.py:356:100: E501 Line too long (122 > 99)
    |
354 |     def test_vwap_trades(self, sample_trades_deque, sample_bar_start_times):
355 |         interval = 60
356 |         actual_series = FeatureEngine._pipeline_compute_vwap_trades(sample_trades_deque, sample_bar_start_times, interval)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^ E501
357 |         assert isinstance(actual_series, pd.Series)
358 |         assert actual_series.name == f"vwap_trades_{interval}s"
    |

tests/unit/test_feature_engine_pipeline_computations.py:362:100: E501 Line too long (170 > 99)
    |
361 | 270.35 / 2.7 = 100.1296...
362 | al('0.5') + Decimal('100.2') * Decimal('1.2')) / (Decimal('1.0') + Decimal('0.5') + Decimal('1.2'))
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
363 | 
364 | 
    |

tests/unit/test_feature_engine_pipeline_computations.py:366:100: E501 Line too long (104 > 99)
    |
364 |         assert np.isclose(actual_series.iloc[0], expected_bar1_vwap)
365 |
366 |         # Bar 2: (100.3*0.8 + 100.2*0.3) / (0.8+0.3) = (80.24 + 30.06) / 1.1 = 110.3 / 1.1 = 100.2727...
    |                                                                                                    ^^^^^ E501
367 |         expected_bar2_vwap = float(Decimal("110.3") / Decimal("1.1"))
368 |         assert np.isclose(actual_series.iloc[1], expected_bar2_vwap)
    |

tests/unit/test_feature_engine_pipeline_computations.py:372:9: D102 Missing docstring in public method
    |
370 |         assert np.isnan(actual_series.iloc[2]) # No trades in bar 3
371 |
372 |     def test_volume_delta(self, sample_trades_deque, sample_bar_start_times):
    |         ^^^^^^^^^^^^^^^^^ D102
373 |         interval = 60
374 |         actual_series = FeatureEngine._pipeline_compute_volume_delta(sample_trades_deque, sample_bar_start_times, interval)
    |

tests/unit/test_feature_engine_pipeline_computations.py:374:100: E501 Line too long (123 > 99)
    |
372 |     def test_volume_delta(self, sample_trades_deque, sample_bar_start_times):
373 |         interval = 60
374 |         actual_series = FeatureEngine._pipeline_compute_volume_delta(sample_trades_deque, sample_bar_start_times, interval)
    |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^ E501
375 |         assert isinstance(actual_series, pd.Series)
376 |         assert actual_series.name == f"volume_delta_{interval}s"
    |

tests/unit/test_feature_engine_pipeline_computations.py:378:100: E501 Line too long (106 > 99)
    |
376 |         assert actual_series.name == f"volume_delta_{interval}s"
377 |
378 |         # Bar 1: buy(1.0) + sell(0.5) + buy(1.2) -> total_buy=2.2, total_sell=0.5. Delta = 2.2 - 0.5 = 1.7
    |                                                                                                    ^^^^^^^ E501
379 |         assert np.isclose(actual_series.iloc[0], 1.7)
380 |         # Bar 2: buy(0.8) + sell(0.3) -> total_buy=0.8, total_sell=0.3. Delta = 0.8 - 0.3 = 0.5
    |

tests/unit/test_feature_engine_pipeline_computations.py:385:9: D102 Missing docstring in public method
    |
383 |         assert np.isclose(actual_series.iloc[2], 0.0)
384 |
385 |     def test_volume_delta_no_trades(self, sample_bar_start_times):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
386 |         interval = 60
387 |         empty_deque = deque()
    |

tests/unit/test_feature_engine_pipeline_computations.py:388:100: E501 Line too long (115 > 99)
    |
386 |         interval = 60
387 |         empty_deque = deque()
388 |         actual_series = FeatureEngine._pipeline_compute_volume_delta(empty_deque, sample_bar_start_times, interval)
    |                                                                                                    ^^^^^^^^^^^^^^^^ E501
389 |         assert actual_series.isna().all() # No trades in deque means NaN for all bars
    |

tests/unit/test_feature_engine_pipeline_computations.py:391:9: D102 Missing docstring in public method
    |
389 |         assert actual_series.isna().all() # No trades in deque means NaN for all bars
390 |
391 |     def test_vwap_trades_no_trades(self, sample_bar_start_times):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
392 |         interval = 60
393 |         empty_deque = deque()
    |

tests/unit/test_feature_engine_pipeline_computations.py:394:100: E501 Line too long (114 > 99)
    |
392 |         interval = 60
393 |         empty_deque = deque()
394 |         actual_series = FeatureEngine._pipeline_compute_vwap_trades(empty_deque, sample_bar_start_times, interval)
    |                                                                                                    ^^^^^^^^^^^^^^^ E501
395 |         assert actual_series.isna().all()
    |

tests/unit/test_feature_engine_pipeline_construction.py:15:5: D103 Missing docstring in public function
   |
14 | @pytest.fixture
15 | def mock_logger():
   |     ^^^^^^^^^^^ D103
16 |     return MagicMock()
   |

tests/unit/test_feature_engine_pipeline_construction.py:19:5: D103 Missing docstring in public function
   |
18 | @pytest.fixture
19 | def mock_pubsub_manager():
   |     ^^^^^^^^^^^^^^^^^^^ D103
20 |     return MagicMock()
   |

tests/unit/test_feature_engine_pipeline_construction.py:33:100: E501 Line too long (100 > 99)
   |
31 |         "features": feature_config,
32 |     }
33 |     engine = FeatureEngine(config=base_config, pubsub_manager=pubsub_manager, logger_service=logger)
   |                                                                                                    ^ E501
34 |     return engine
   |

tests/unit/test_feature_engine_pipeline_construction.py:34:12: RET504 Unnecessary assignment to `engine` before `return` statement
   |
32 |     }
33 |     engine = FeatureEngine(config=base_config, pubsub_manager=pubsub_manager, logger_service=logger)
34 |     return engine
   |            ^^^^^^ RET504
35 |
36 | # --- Test Cases ---
   |
   = help: Remove unnecessary assignment

tests/unit/test_feature_engine_pipeline_construction.py:62:41: PLR2004 Magic value used in comparison, consider replacing `14` with a constant variable
   |
60 |     assert isinstance(spec, InternalFeatureSpec)
61 |     assert spec.key == feature_key
62 |     assert spec.parameters["period"] == 14
   |                                         ^^ PLR2004
63 |
64 |     # Expected steps: input_imputer, rsi_calculator, reshape_before_impute, output_imputer, reshape_after_impute, output_scaler
   |

tests/unit/test_feature_engine_pipeline_construction.py:64:100: E501 Line too long (127 > 99)
   |
62 |     assert spec.parameters["period"] == 14
63 |
64 |     # Expected steps: input_imputer, rsi_calculator, reshape_before_impute, output_imputer, reshape_after_impute, output_scaler
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
65 |     # Check number of steps (can be fragile if reshape steps are conditional)
66 |     # For constant SimpleImputer, it should be: input_imputer, calculator, reshape_before, SimpleImputer, reshape_after, scaler
   |

tests/unit/test_feature_engine_pipeline_construction.py:66:100: E501 Line too long (127 > 99)
   |
64 |     # Expected steps: input_imputer, rsi_calculator, reshape_before_impute, output_imputer, reshape_after_impute, output_scaler
65 |     # Check number of steps (can be fragile if reshape steps are conditional)
66 |     # For constant SimpleImputer, it should be: input_imputer, calculator, reshape_before, SimpleImputer, reshape_after, scaler
   |                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
67 |     # For fillna func transformer: input_imputer, calculator, fillna_transformer, scaler
   |

tests/unit/test_feature_engine_pipeline_construction.py:88:47: PLR2004 Magic value used in comparison, consider replacing `50.0` with a constant variable
   |
86 |     assert isinstance(pipeline.steps[3][1], SimpleImputer) # If using SimpleImputer path
87 |     assert pipeline.steps[3][1].strategy == "constant"
88 |     assert pipeline.steps[3][1].fill_value == 50.0
   |                                               ^^^^ PLR2004
89 |
90 |     assert pipeline.steps[5][0] == f"{feature_key}_output_scaler_MinMaxScaler" # Name from helper
   |

tests/unit/test_feature_engine_pipeline_construction.py:135:35: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
133 |     pipeline = engine.feature_pipelines[pipeline_name]["pipeline"]
134 |     # Expected: input_imputer, calculator ONLY
135 |     assert len(pipeline.steps) == 2
    |                                   ^ PLR2004
136 |     assert pipeline.steps[0][0] == f"{feature_key}_input_imputer"
137 |     assert pipeline.steps[1][0] == f"{feature_key}_calculator"
    |

tests/unit/test_feature_engine_pipeline_construction.py:140:5: D103 Missing docstring in public function
    |
140 | def test_build_macd_pipeline(mock_logger, mock_pubsub_manager):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ D103
141 |     feature_key = "macd_custom"
142 |     macd_config = {
    |

tests/unit/test_feature_engine_pipeline_construction.py:177:35: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
176 |     # Expected: calculator, output_imputer (df.fillna(df.mean()))
177 |     assert len(pipeline.steps) == 2
    |                                   ^ PLR2004
178 |     assert pipeline.steps[0][0] == f"{feature_key}_calculator"
179 |     assert pipeline.steps[1][0] == f"{feature_key}_output_fillna" # Default for DataFrame
    |

tests/unit/test_feature_engine_pipeline_construction.py:200:35: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
198 |     assert spec.input_type == "trades_and_bar_starts"
199 |     # Expected: calculator, output_imputer, output_scaler
200 |     assert len(pipeline.steps) == 3
    |                                   ^ PLR2004
201 |     assert pipeline.steps[0][0] == f"{feature_key}_calculator"
202 |     assert pipeline.steps[0][1].kw_args == {"bar_interval_seconds": 120}
    |

tests/unit/test_feature_engine_pipeline_construction.py:208:100: E501 Line too long (101 > 99)
    |
207 | def test_missing_critical_parameter(mock_logger, mock_pubsub_manager):
208 |     """Test that a feature pipeline might not be built or logs error if critical param is missing."""
    |                                                                                                    ^^ E501
209 |     feature_key = "rsi_no_period"
210 |     rsi_config = {
    |

tests/unit/test_feature_engine_pipeline_construction.py:221:97: PLR2004 Magic value used in comparison, consider replacing `14` with a constant variable
    |
219 |     pipeline_name = f"{feature_key}_pipeline"
220 |     assert pipeline_name in engine.feature_pipelines
221 |     assert engine.feature_pipelines[pipeline_name]["pipeline"].steps[1][1].kw_args["period"] == 14
    |                                                                                                 ^^ PLR2004
222 |     # Check if logger was called with a debug message (or warning if we change it)
223 |     # This requires more advanced mock inspection, e.g. mock_logger.debug.assert_any_call(...)
    |

tests/unit/test_feature_engine_pipeline_construction.py:236:100: E501 Line too long (111 > 99)
    |
234 |     engine_bad = create_feature_engine_with_config(custom_config, mock_logger, mock_pubsub_manager)
235 |     assert f"{feature_key_bad}_pipeline" not in engine_bad.feature_pipelines
236 |     # Check for error log: mock_logger.error.assert_called_with(...) containing "No _pipeline_compute function"
    |                                                                                                    ^^^^^^^^^^^^ E501
237 |     # This can be done by inspecting mock_logger.error.call_args_list in a real test runner.
    |

Found 1190 errors.
[*] 76 fixable with the `--fix` option (90 hidden fixes can be enabled with the `--unsafe-fixes` option).
